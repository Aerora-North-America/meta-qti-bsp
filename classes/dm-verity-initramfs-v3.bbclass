# Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
# SPDX-License-Identifier: BSD-3-Clause-Clear

DEPENDS += "cryptsetup-native openssl-native"

CONFLICT_MACHINE_FEATURES += " dm-verity-bootloader dm-verity-none dm-verity-initramfs dm-verity-initramfs-v2"

CORE_IMAGE_EXTRA_INSTALL += "cryptsetup"

VERITY_SALT = "aee087a5be3b982978c923f566a94613496b417f2af592639bc80d141e34dfe7"
BLOCK_SIZE = "4096"
FEC_ROOTS = "2"

VERITY_HASH_DEVICE = "${WORKDIR}/${IMAGE_NAME}.verityhash"
VERITY_FEC_DEVICE = "${WORKDIR}/${IMAGE_NAME}.verityfec"
SYSTEM_IMAGE_ROOTFS_SIZE   = "${@get_size_in_bytes(d.getVar('SYSTEM_SIZE_EXT4') or '256MB')}"
UNSPARSED_SYSTEMIMAGE = "${IMGDEPLOYDIR}/${IMAGE_BASENAME}/${SYSTEMIMAGE_TARGET}.raw"
SYSTEMIMAGE_MAP_TARGET ?= "system.map"

# Ensure SELinux file context variable is defined
SELINUX_FILE_CONTEXTS ?= ""
SELINUX_IMG_S = "${@['-S ${SELINUX_FILE_CONTEXTS}', ''][d.getVar('SELINUX_FILE_CONTEXTS') == '']}"
IMAGE_EXT4_SELINUX_OPTIONS = "${@bb.utils.contains('DISTRO_FEATURES', 'selinux', '${SELINUX_IMG_S}', '', d)}"
SYSTEMIMAGE_TARGET ?= "system.img"

########adding the setps that we need

# 1.  from RAW image to be adjusted for size adjust_system_size_for_verity
# 2.  calculate the rqueired offset that needed to be used
# 3.  call veritysetup format
# 4.  create the enviroment file that is needed for ramdisk
# 5.  append the details to the image
# 6.  create the sign key

##############################################
# To successfully flash generated images on device, need to ensure combined size of
# unsparsed image and verity fec metadata is with in actual rootfs size. As there is
# no easy way to know the best fit values upfront, images and fec metadata are repeatedly
# generated by reducing size by 1% every time till a suitable image is avilable.
adjust_system_size_for_verity () {
     #Set -x
     adjustedSize=$(echo ${SYSTEM_IMAGE_ROOTFS_SIZE} |egrep -o '^[0-9]+')
     percent=$(echo ${1} |egrep -o '^[0-9]+')
     adjustedSize=`expr $adjustedSize \* $percent`
     adjustedSize=`expr $adjustedSize / 100`

     #Align to 4096 block size
     adjustedSize=`expr $adjustedSize + 4095`
     adjustedSize=`expr $adjustedSize / 4096`
     adjustedSize=`expr $adjustedSize \* 4096`
     echo "$adjustedSize"
}


#$1 is path of system image.
get_system_verity_metdata_info() {
     VERITY_SALT="aee087a5be3b982978c923f566a94613496b417f2af592639bc80d141e34dfe7"
     FEC_ROOTS="2"

# Remove files from previous run
# rm -f ${WORKDIR}/verity_metadata.txt

 echo "calling veritysetup format "
     veritysetup format $1 \
       ${VERITY_HASH_DEVICE}  \
         --fec-device  ${VERITY_FEC_DEVICE} \
         --fec-roots ${FEC_ROOTS} \
         --salt ${VERITY_SALT} > ${WORKDIR}/verity_metadata.txt

}

append_verity_metadata_to_system_image2() {
#Step 1
  for count in {99..1}
     do
         invalid_image=0
         adjustedSystemSize=$(echo $(adjust_system_size_for_verity "${count}" ))
         echo adjustedSystemSize: $adjustedSystemSize
         ImgPath="${UNSPARSED_SYSTEMIMAGE}"
# remake the system image size with  returend value .
         make_ext4fs  -C ${WORKDIR}/rootfs-fsconfig.conf \
              -B ${IMGDEPLOYDIR}/${IMAGE_BASENAME}/${SYSTEMIMAGE_MAP_TARGET} \
              -a / -b 4096 -l ${adjustedSystemSize}  ${IMAGE_EXT4_SELINUX_OPTIONS} \
                      ${ImgPath}  ${IMAGE_ROOTFS_EXT4} /dev/null || invalid_image=1

         if [ $invalid_image -eq 1 ]; then
             echo "Unsparse image generation failed...exiting."
             break
         fi

         # Get verity metadata for generated image.
           get_system_verity_metdata_info "${ImgPath}"

         # Append hash and fec data to the image
         cat ${VERITY_HASH_DEVICE} >> ${ImgPath}
         cat ${VERITY_FEC_DEVICE}  >> ${ImgPath}

         # Check if size is within the range

         systemSize=`wc -c ${ImgPath} | awk '{print $1}'`
         if [ "$systemSize" -gt "${SYSTEM_IMAGE_ROOTFS_SIZE}" ]; then
             echo "Size mismatch ($systemSize Vs ${SYSTEM_IMAGE_ROOTFS_SIZE})...recreating unsparse image."
             continue
         fi

         # Calculate offset
         hash_offset=$adjustedSystemSize
         hash_size=`wc -c ${WORKDIR}/${IMAGE_NAME}.verityhash | awk '{print $1}'`
         fec_offset=`expr ${hash_offset} + ${hash_size}`
         echo "fec_offset:$fec_offset" >> ${WORKDIR}/verity_metadata.txt
         echo "Calculated fec offset: $fec_offset"
         DATA_BLOCK1=`expr ${SYSTEM_IMAGE_ROOTFS_SIZE} / ${BLOCK_SIZE}`
         # Generate environment variables for veritysetup on target system

	root_hash=`awk -F ':' '{ if ($1 == "Root hash") print $2 }' ${WORKDIR}/verity_metadata.txt | sed "s/^[ \t]*//"`
	cat <<-EOF > ${WORKDIR}/verity.env
	VERITY_DATA_BLOCKS=${DATA_BLOCK1}
	VERITY_HASH_OFFSET=${hash_offset}
	VERITY_FEC_OFFSET=${fec_offset}
	VERITY_FEC_ROOTS=${FEC_ROOTS}
	VERITY_SALT=${VERITY_SALT}
	VERITY_ROOT_HASH=${root_hash}
	EOF

         # Convert to sparse image
         sparseImgPath="${IMGDEPLOYDIR}/${IMAGE_BASENAME}/${SYSTEMIMAGE_TARGET}"
         img2simg ${ImgPath} ${sparseImgPath}

         echo "image is good to use. ${sparseImgPath}.."
         break
     done



# Sign the root hash
     echo -n "${root_hash}" > ${WORKDIR}/roothash.txt
     echo "WORKDIR ${WORKDIR}"
     echo  "KERNEL_PREBUILT_DISTDIR  : ${KERNEL_PREBUILT_DISTDIR}"
     echo "IMGDEPLOYDIR :  ${IMGDEPLOYDIR}"
    openssl smime -sign -nocerts -noattr -binary -in ${WORKDIR}/roothash.txt -inkey ${STAGING_KERNEL_BUILDDIR}/certs/verity_key.pem  -signer ${STAGING_KERNEL_BUILDDIR}/certs/verity_cert.pem  -outform der -out ${WORKDIR}/verity_sig.txt

    # Clean up large files that are no longer needed
    rm ${VERITY_HASH_DEVICE}
    rm ${VERITY_FEC_DEVICE}
}
do_makesystem[postfuncs] += "do_unsparse_images  append_verity_metadata_to_system_image2"

# ramdisk creation now requires the verity artifacts
do_ramdisk_create[depends] += "${PN}:do_makesystem"

##### Generate boot.img ######
BOOTIMGDEPLOYDIR = "${WORKDIR}/deploy-${PN}-bootimage-complete"

INITRAMFS_IMAGE ?= ''
RAMDISK ?= "${DEPLOY_DIR_IMAGE}/${INITRAMFS_IMAGE}-${MACHINE}.${INITRAMFS_FSTYPES}"
def get_ramdisk_path(d):
    if os.path.exists(d.getVar('RAMDISK')):
        return '%s' %(d.getVar('RAMDISK'))
    return '/dev/null'

RAMDISK_PATH = "${@get_ramdisk_path(d)}"

MKBOOTUTIL = '${@oe.utils.conditional("PREFERRED_PROVIDER_virtual/mkbootimg-native", "mkbootimg-gki-native", "scripts/mkbootimg.py", "mkbootimg", d)}'

python do_makeboot () {
    import subprocess

    xtra_parms=""
    if bb.utils.contains('MACHINE_FEATURES', 'nand-boot', True, False, d):
        xtra_parms = " --tags-addr" + " " + d.getVar('KERNEL_TAGS_OFFSET')
    if (d.getVar("BOOT_HEADER_VERSION") or "0") != "0":
        xtra_parms += " --header_version " + d.getVar('BOOT_HEADER_VERSION')
        # header version setting expects dtb to be passed seprately but not appended to kernel
        xtra_parms += " --dtb " + d.getVar('DEPLOY_DIR_IMAGE', True) + "/" + d.getVar('KERNEL_DTB_NAMES').strip()

    mkboot_bin_path = d.getVar('STAGING_BINDIR_NATIVE', True) + "/" + d.getVar('MKBOOTUTIL')
    ramdisk_path    = d.getVar('RAMDISK_PATH')
    zimg_path       = d.getVar('DEPLOY_DIR_IMAGE', True) + "/" + d.getVar('KERNEL_IMAGETYPE', True)
    cmdline         = "\"" + d.getVar('KERNEL_CMD_PARAMS', True) + "\""
    pagesize        = d.getVar('PAGE_SIZE', True)
    base            = d.getVar('KERNEL_BASE', True)
    output          = d.getVar('BOOTIMAGE_TARGET', True)

    # cmd to make boot.img
    cmd =  mkboot_bin_path + " --kernel %s --cmdline %s --pagesize %s --base %s --ramdisk %s --ramdisk_offset 0x0 %s --output %s" \
           % (zimg_path, cmdline, pagesize, base, ramdisk_path, xtra_parms, output )
    bb.debug(1, "dm-verity-initramfs do_makeboot cmd: %s" % (cmd))
    try:
        ret = subprocess.check_output(cmd, shell=True)
    except RuntimeError as e:
        bb.error("dm-verity-initramfs cmd: %s failed with error %s" % (cmd, str(e)))

}
do_makeboot[dirs]      = "${BOOTIMGDEPLOYDIR}/${IMAGE_BASENAME}"
# Make sure native tools and vmlinux ready to create boot.img
do_makeboot[depends] += "virtual/kernel:do_deploy virtual/mkbootimg-native:do_populate_sysroot"
SSTATETASKS += "do_makeboot"
SSTATE_SKIP_CREATION_task-makeboot = '1'
do_makeboot[sstate-inputdirs] = "${BOOTIMGDEPLOYDIR}"
do_makeboot[sstate-outputdirs] = "${DEPLOY_DIR_IMAGE}"
do_makeboot[stamp-extra-info] = "${MACHINE_ARCH}"

python do_makeboot_setscene () {
    sstate_setscene(d)
}
addtask do_makeboot_setscene

addtask do_makeboot before do_image_complete
