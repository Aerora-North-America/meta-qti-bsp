#!/bin/sh
# Copyright (c) 2021 Qualcomm Innovation Center, Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted (subject to the limitations in the
# disclaimer below) provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#     * Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials provided
#       with the distribution.
#
#     * Neither the name of Qualcomm Innovation Center, Inc. nor the names of its
#       contributors may be used to endorse or promote products derived
#       from this software without specific prior written permission.
#
# NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE
# GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
# HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
# IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

err() {
	echo "<3>$*" > /dev/kmsg
}
warn() {
	echo "<4>$*" > /dev/kmsg
}
notice() {
	echo "<5>$*" > /dev/kmsg
}
info() {
	echo "<6>$*" > /dev/kmsg
}

extract_bootconfig() {
	sed -n 's/^'"$1"' = "\(.*\)"$/\1/p' /proc/bootconfig
}
extract_cmdline() {
	sed -e 's/ /\n/g' /proc/cmdline | sed -n 's/^'"$1"'=\(.*\)$/\1/p'
}
extract_config() {
	local res="$(extract_cmdline $1)"
	[ -z "$res" ] && res="$(extract_bootconfig $1)"
	echo $res
}

start_adbd()
{
	echo "start_adbd: setting up device for adbd"
	# get soc platform
	if [ -f /sys/devices/soc0/machine ]; then
		socplatform=`cat /sys/devices/soc0/machine` 2> /dev/null
	elif [ -f /sys/devices/system/soc/soc0/machine ]; then
		socplatform=`cat /sys/devices/system/soc/soc0/machine` 2> /dev/null
	else
		socplatform=$(uname -r | cut -d "-" -f1-4)
	fi
	echo "start_adbd: soc: $socplatform"

	# find serialno from cmdline
	serialno="$(extract_config "androidboot.serialno")"
	echo "$serialno" | grep -qv "[^A-Za-z0-9]"
	valid_serial=$?
	if [ -z "$serialno" -o $valid_serial -ne 0 ]; then
		echo "start_adbd: serialno not found with cmdline or bootconfig, using default value"
		serialno="12345678"
	fi

	echo "start_adbd: serialno: $serialno"
	mount -t configfs configfs /sys/kernel/config
	if [ -d /sys/kernel/config/usb_gadget ]; then
		notice "start_adbd: Configuring the USB gadget using ConfigFS"
		cd /sys/kernel/config/usb_gadget
		mkdir g1
		cd g1
		mkdir strings/0x409
		mkdir configs/c.1
		mkdir configs/c.1/strings/0x409
		mkdir functions/ffs.adb

		echo "$serialno" > strings/0x409/serialnumber
		echo "QCOM" > strings/0x409/manufacturer
		echo "$socplatform" > strings/0x409/product
		echo 0x18d1 > /sys/kernel/config/usb_gadget/g1/idVendor
		echo 0x4EE7 > /sys/kernel/config/usb_gadget/g1/idProduct
		echo "ADB" > configs/c.1/strings/0x409/configuration
	else
		notice "start_adbd: Configuring the USB gadget using legacy method"
		cd /sys/class/android_usb/android0/
		echo 0 > enable
		echo 05C6 > idVendor
		echo 901D > idProduct
		echo "$serialno" > iSerial
		echo "QCOM" > iManufacturer
		echo "$socplatform" > iProduct
		echo diag > f_diag/clients
		echo diag,ffs > functions
		echo 1 > enable
	fi
	cd /

	echo "start_adbd: Configuring FunctionFS endpoints for adbd"
	if [ ! -d /dev/usb-ffs/adb ]; then
	mkdir -p /dev/usb-ffs/adb
	fi
	if [ ! -e /dev/usb-ffs/adb/ep0 ]; then
	mount -o uid=2000,gid=2000 -t functionfs adb /dev/usb-ffs/adb
	fi

	echo "start_adbd: Launching adbd"
	/sbin/adbd &

	if [ -d /sys/kernel/config/usb_gadget/g1 ]; then
		cd /sys/kernel/config/usb_gadget/g1
		sleep 1
		ln -s functions/ffs.adb configs/c.1/f1
		echo 0x80 > configs/c.1/bmAttributes

		udcname=`ls -1 /sys/bus/platform/devices/ | grep ssusb | head -n 1`

		# Force USB to be in peripheral mode in case cable plug detection
		# is not working or not enabled.
		# This assumes we are using "dwc3/ssusb" based USB devices.
		#    e.g. a600000.dwc3 -> a600000.ssusb
		echo peripheral > /sys/bus/platform/devices/${udcname}/mode

		echo "start_adbd: waiting for USB device..."
		i=1
		while [ $i -lt 60 ]
		do
			udcname=`ls -1 /sys/class/udc | grep -v dummy_udc | head -n 1`
			if [ -n "$udcname" ]; then
				break
			fi
			sleep 1
			((i=i+1))
		done

		if [ -z "$udcname" ]; then
			echo "start_adbd: UDC didn't come up, won't be able to connect to adbd"
		fi

		echo "start_adbd: binding $udcname with gadget"
		echo $udcname > UDC
		cd /

		echo "start_adbd: adbd successfully launched"
	else
		echo "start_adbd: USB gadget didn't get created /sys/kernel/config/usb_gadget/g1"
	fi
}

start_rdshell()
{
    echo "mdev -s"
    /usr/bin/mdev -s

    echo /usr/bin/mdev > /proc/sys/kernel/hotplug

    # This is necessary to emulate the android environment expected by adbd
    echo "Configuring the Kdev environment to support 'adb shell' ..."
    mkdir /dev/pts
    mount -t devpts devpts /dev/pts
    chmod 0666 /dev/ptmx
    mkdir -p /system/bin
    ln -s /bin/sh /system/bin/sh
    chmod 4755 /bin/su

    # Set adb root cookie
    mkdir /tmp
    echo "#ROOT###" > /tmp/.adb.root
    start_adbd

    echo "Shell environment for ramdisk"
    exec /bin/mksh
}

config_interface()
{
    LOCAL_INTERFACE="$1"
    LOCAL_ADDR="$2"
    REMOTE_ADDR="$3"

    INTERFACE_TIMEOUT=60
    ifconfig -a $LOCAL_INTERFACE >/dev/null 2>&1
    while [ "$?" -ne 0 ]; do
        echo "Waiting for $LOCAL_INTERFACE..."
        sleep 1
        if [ "$INTERFACE_TIMEOUT" -le 0 ]; then
            return 1
        fi
        (( INTERFACE_TIMEOUT -= 1 ))
        ifconfig -a $LOCAL_INTERFACE >/dev/null 2>&1
    done

    # Bringup interface
    ifconfig $LOCAL_INTERFACE $LOCAL_ADDR up

    # Configure route
    ip route add $REMOTE_ADDR via $LOCAL_ADDR

    sleep 2

    return 0
}

do_mounts()
{
    if [ -f /etc/fstab ]; then
        echo "mount -a"
        /bin/mount -a
    fi

    echo "mount sysfs"
    mount -t sysfs sysfs /sys

    echo "mount debugfs"
    mount -t debugfs debugfs /sys/kernel/debug

    echo "mount proc"
    mount proc /proc -t proc

    echo "mount devtmpfs"
    mount -t devtmpfs devtmpfs /dev

    echo "mount tmpfs"
    mkdir -p /tmp
    mount -t tmpfs tmpfs /tmp
}

do_mounts

do_nbdtab()
{
# Create nbd-server config
echo "nbd0 $1 system.img.raw persist" > /etc/nbdtab
echo "nbd1 $1 systemrw.img.raw  persist" >> /etc/nbdtab
echo "nbd2 $1 persist.img.raw  persist" >> /etc/nbdtab
echo "nbd3 $1 userdata.img.raw  persist" >> /etc/nbdtab
echo "nbd4 $1 cache.img.raw  persist" >> /etc/nbdtab
echo "nbd5 $1 NON-HLOS.bin persist" >> /etc/nbdtab

    /usr/sbin/nbd nbd0 # connect remote system.img
    /usr/sbin/nbd nbd1 # connect remote systemrw.img
    /usr/sbin/nbd nbd2 # connect remote persist.img
    /usr/sbin/nbd nbd3 # connect remote userdata.img
    /usr/sbin/nbd nbd4 # connect remote cache.img
    /usr/sbin/nbd nbd5 # connect NON-HLOS

    # mount system.img
    mnt_dir="/mnt/system"
    mkdir -p $mnt_dir
    mount -o rw /dev/nbd0 $mnt_dir
    #umount /sys/kernel/debug /sys /proc /dev

    # update systemd mount files to mount it from nbd devices
    cd /mnt/system/lib/systemd/system/
    sed -i 's+/dev/disk/by-partlabel/systemrw+/dev/nbd1+g' systemrw.mount
    sed -i 's+/dev/disk/by-partlabel/persist+/dev/nbd2+g' persist.mount
    sed -i 's+/dev/disk/by-partlabel/userdata+/dev/nbd3+g' data.mount
    sed -i 's+/dev/disk/by-partlabel/cache+/dev/nbd4+g' cache.mount
    sed -i 's+/dev/disk/by-partlabel/modem+/dev/nbd5+g' firmware.mount

    # Switch root to remote sysfs
    echo "Switching to system partition on $partition"
    exec /bin/switch_root -c /dev/console $mnt_dir /sbin/init
}

fstab_suffix="$(extract_config androidboot.fstab_suffix)"
if [ -z "$fstab_suffix" ]; then
    echo "No boot suffix detected, using default"
    fstab_suffix="default"
else
    echo "Detected boot from: $fstab_suffix"
fi

case $fstab_suffix in
    emmc)
        partition="$(extract_config root)"
        if [ -e "$partition" ]; then
            mnt_dir="/mnt/system"
            mkdir -p $mnt_dir
            mount -o ro $partition $mnt_dir

            umount /sys/kernel/debug /sys /proc /dev
            echo "Switching to system partition on $partition"
            exec /bin/switch_root -c /dev/console $mnt_dir /sbin/init
        fi
        ;;
    default)
        # default --> flashless
        # change log level
        echo 2 > /proc/sys/kernel/printk
        HOST_ADDR="192.168.1.172"
        LOCAL_ADDR="192.168.1.173"
        LOCAL_INTERFACE="mhi_swip0"
        config_interface "$LOCAL_INTERFACE" "$LOCAL_ADDR" "$HOST_ADDR"
        if [ "$?" -ne 0 ]; then
            echo "Failed to config interface: $LOCAL_INTERFACE"
            start_rdshell
        fi
        # Create /etc/nbdtab and nbd-client connect remote nbdkit
        do_nbdtab "$HOST_ADDR"
        ;;
    rdshell)
        echo "Starting ramdisk shell"
        start_rdshell
        ;;
    *)
        echo "Unknown boot: $fstab_suffix"
        ;;
esac

echo "Defaulting to ramdisk shell"
start_rdshell
