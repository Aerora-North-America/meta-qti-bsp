#!/bin/sh
# Copyright (c) 2021 Qualcomm Innovation Center, Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted (subject to the limitations in the
# disclaimer below) provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#     * Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials provided
#       with the distribution.
#
#     * Neither the name of Qualcomm Innovation Center, Inc. nor the names of its
#       contributors may be used to endorse or promote products derived
#       from this software without specific prior written permission.
#
# NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE
# GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
# HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
# IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

err() {
	echo "<3>$*" > /dev/kmsg
}
warn() {
	echo "<4>$*" > /dev/kmsg
}
notice() {
	echo "<5>$*" > /dev/kmsg
}
info() {
	echo "<6>$*" > /dev/kmsg
}

extract_bootconfig() {
	sed -n 's/^'"$1"' = "\(.*\)"$/\1/p' /proc/bootconfig
}
extract_cmdline() {
	sed -e 's/ /\n/g' /proc/cmdline | sed -n 's/^'"$1"'=\(.*\)$/\1/p'
}
extract_config() {
	local res="$(extract_cmdline $1)"
	[ -z "$res" ] && res="$(extract_bootconfig $1)"
	echo $res
}

start_adbd()
{
	echo "start_adbd: setting up device for adbd"
	# get soc platform
	if [ -f /sys/devices/soc0/machine ]; then
		socplatform=`cat /sys/devices/soc0/machine` 2> /dev/null
	elif [ -f /sys/devices/system/soc/soc0/machine ]; then
		socplatform=`cat /sys/devices/system/soc/soc0/machine` 2> /dev/null
	else
		socplatform=$(uname -r | cut -d "-" -f1-4)
	fi
	echo "start_adbd: soc: $socplatform"

	# find serialno from cmdline
	serialno="$(extract_config "androidboot.serialno")"
	echo "$serialno" | grep -qv "[^A-Za-z0-9]"
	valid_serial=$?
	if [ -z "$serialno" -o $valid_serial -ne 0 ]; then
		echo "start_adbd: serialno not found with cmdline or bootconfig, using default value"
		serialno="12345678"
	fi

	echo "start_adbd: serialno: $serialno"
	mount -t configfs configfs /sys/kernel/config
	if [ -d /sys/kernel/config/usb_gadget ]; then
		notice "start_adbd: Configuring the USB gadget using ConfigFS"
		cd /sys/kernel/config/usb_gadget
		mkdir g1
		cd g1
		mkdir strings/0x409
		mkdir configs/c.1
		mkdir configs/c.1/strings/0x409
		mkdir functions/ffs.adb

		echo "$serialno" > strings/0x409/serialnumber
		echo "QCOM" > strings/0x409/manufacturer
		echo "$socplatform" > strings/0x409/product
		echo 0x18d1 > /sys/kernel/config/usb_gadget/g1/idVendor
		echo 0x4EE7 > /sys/kernel/config/usb_gadget/g1/idProduct
		echo "ADB" > configs/c.1/strings/0x409/configuration
	else
		notice "start_adbd: Configuring the USB gadget using legacy method"
		cd /sys/class/android_usb/android0/
		echo 0 > enable
		echo 05C6 > idVendor
		echo 901D > idProduct
		echo "$serialno" > iSerial
		echo "QCOM" > iManufacturer
		echo "$socplatform" > iProduct
		echo diag > f_diag/clients
		echo diag,ffs > functions
		echo 1 > enable
	fi
	cd /

	echo "start_adbd: Configuring FunctionFS endpoints for adbd"
	if [ ! -d /dev/usb-ffs/adb ]; then
	mkdir -p /dev/usb-ffs/adb
	fi
	if [ ! -e /dev/usb-ffs/adb/ep0 ]; then
	mount -o uid=2000,gid=2000 -t functionfs adb /dev/usb-ffs/adb
	fi

	echo "start_adbd: Launching adbd"
	/sbin/adbd &

	if [ -d /sys/kernel/config/usb_gadget/g1 ]; then
		cd /sys/kernel/config/usb_gadget/g1
		sleep 1
		ln -s functions/ffs.adb configs/c.1/f1
		echo 0x80 > configs/c.1/bmAttributes

		udcname=`ls -1 /sys/bus/platform/devices/ | grep ssusb | head -n 1`

		# Force USB to be in peripheral mode in case cable plug detection
		# is not working or not enabled.
		# This assumes we are using "dwc3/ssusb" based USB devices.
		#    e.g. a600000.dwc3 -> a600000.ssusb
		echo peripheral > /sys/bus/platform/devices/${udcname}/mode

		echo "start_adbd: waiting for USB device..."
		i=1
		while [ $i -lt 60 ]
		do
			udcname=`ls -1 /sys/class/udc | grep -v dummy_udc | head -n 1`
			if [ -n "$udcname" ]; then
				break
			fi
			sleep 1
			((i=i+1))
		done

		if [ -z "$udcname" ]; then
			echo "start_adbd: UDC didn't come up, won't be able to connect to adbd"
		fi

		echo "start_adbd: binding $udcname with gadget"
		echo $udcname > UDC
		cd /

		echo "start_adbd: adbd successfully launched"
	else
		echo "start_adbd: USB gadget didn't get created /sys/kernel/config/usb_gadget/g1"
	fi
}

start_rdshell()
{
    echo "mdev -s"
    /usr/bin/mdev -s

    echo /usr/bin/mdev > /proc/sys/kernel/hotplug

    # This is necessary to emulate the android environment expected by adbd
    echo "Configuring the Kdev environment to support 'adb shell' ..."
    mkdir /dev/pts
    mount -t devpts devpts /dev/pts
    chmod 0666 /dev/ptmx
    mkdir -p /system/bin
    ln -s /bin/sh /system/bin/sh
    chmod 4755 /bin/su

    # Set adb root cookie
    mkdir /tmp
    echo "#ROOT###" > /tmp/.adb.root
    start_adbd

    echo "Shell environment for ramdisk"
    exec /bin/mksh
}

do_mounts()
{
    if [ -f /etc/fstab ]; then
        echo "mount -a"
        /bin/mount -a
    fi

    echo "mount sysfs"
    mount -t sysfs sysfs /sys

    echo "mount debugfs"
    mount -t debugfs debugfs /sys/kernel/debug

    echo "mount proc"
    mount proc /proc -t proc

    echo "mount devtmpfs"
    mount -t devtmpfs devtmpfs /dev
}

do_mounts

fstab_suffix="$(extract_config androidboot.fstab_suffix)"
echo "Detected boot from: $fstab_suffix"

case $fstab_suffix in
    emmc)
        partition="$(extract_config root)"
        if [ -e "$partition" ]; then
            mnt_dir="/mnt/system"
            mkdir -p $mnt_dir
            mount -o ro $partition $mnt_dir

            umount /sys/kernel/debug /sys /proc /dev
            echo "Switching to system partition on $partition"
            exec /bin/switch_root -c /dev/console $mnt_dir /sbin/init
        fi
        ;;
    rdshell)
        echo "Starting ramdisk shell"
        start_rdshell
        ;;
    *)
        echo "Unknown boot: $fstab_suffix"
        ;;
esac

echo "Defaulting to ramdisk shell"
start_rdshell
