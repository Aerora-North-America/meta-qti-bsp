diff --git a/arch/arm/configs/msm7630-perf_defconfig b/arch/arm/configs/msm7630-perf_defconfig
index 97c2ac6..56b9ae19 100644
--- a/arch/arm/configs/msm7630-perf_defconfig
+++ b/arch/arm/configs/msm7630-perf_defconfig
@@ -260,6 +260,7 @@ CONFIG_VIDEO_DEV=y
 CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
 CONFIG_WEBCAM_OV9726=y
 CONFIG_MT9E013=y
+CONFIG_MSM_CAMERA_V4L2=y
 CONFIG_MSM_GEMINI=y
 CONFIG_RADIO_TAVARUA=y
 CONFIG_MSM_KGSL=y
diff --git a/arch/arm/mach-msm/board-msm7x30.c b/arch/arm/mach-msm/board-msm7x30.c
index eda29cd..0e3ae26 100644
--- a/arch/arm/mach-msm/board-msm7x30.c
+++ b/arch/arm/mach-msm/board-msm7x30.c
@@ -867,6 +867,11 @@ static struct i2c_board_info msm_camera_boardinfo[] __initdata = {
 		I2C_BOARD_INFO("mt9t013", 0x6C),
 	},
 #endif
+#ifdef CONFIG_S5K4ECGX
+	{
+		I2C_BOARD_INFO("s5k4ecgx", 0xAC >> 1),
+	},
+#endif
 
 };
 
@@ -987,22 +992,6 @@ static void config_camera_off_gpios(void)
 	}
 }
 
-struct resource msm_camera_resources[] = {
-	{
-		.start	= 0xA6000000,
-		.end	= 0xA6000000 + SZ_1M - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_VFE,
-		.end	= INT_VFE,
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		.flags  = IORESOURCE_DMA,
-	}
-};
-
 struct msm_camera_device_platform_data msm_camera_device_data = {
 	.camera_gpio_on  = config_camera_on_gpios,
 	.camera_gpio_off = config_camera_off_gpios,
@@ -1184,8 +1173,10 @@ static struct msm_camera_sensor_info msm_camera_sensor_vx6953_data = {
 	.vcm_pwd        = 1,
 	.vcm_enable		= 0,
 	.pdata          = &msm_camera_device_data,
+#if 0
 	.resource       = msm_camera_resources,
 	.num_resources  = ARRAY_SIZE(msm_camera_resources),
+#endif
 	.sensor_platform_info = &vx6953_sensor_7630_info,
 	.flash_data     = &flash_vx6953,
 	.csi_if         = 1
@@ -1258,6 +1249,50 @@ static struct platform_device msm_camera_sensor_mt9t013 = {
 };
 #endif
 
+#ifdef CONFIG_S5K4ECGX
+static struct msm_camera_sensor_flash_data flash_s5k4ecgx = {
+	.flash_type = MSM_CAMERA_FLASH_LED,
+	.flash_src  = &msm_flash_src_pwm
+};
+
+static struct msm_camera_sensor_info msm_camera_sensor_s5k4ecgx_data = {
+	.sensor_name    = "s5k4ecgx",
+	.sensor_reset   = 0,
+	.sensor_pwd     = 85,
+	.vcm_pwd        = 1,
+	.vcm_enable     = 1,
+	.pdata          = &msm_camera_device_data,
+	.flash_data     = &flash_s5k4ecgx,
+	.csi_if         = 0
+};
+
+static struct platform_device msm_camera_sensor_s5k4ecgx = {
+	.name      = "msm_camera_s5k4ecgx",
+	.dev       = {
+		.platform_data = &msm_camera_sensor_s5k4ecgx_data,
+	},
+};
+#endif
+
+static void __init msm7x30_init_cam(void)
+{
+	int i;
+	struct platform_device *cam_dev[] = {
+		&msm_camera_sensor_vx6953,
+		&msm_camera_sensor_s5k4ecgx,
+	};
+
+	for (i = 0; i < ARRAY_SIZE(cam_dev); i++) {
+		struct msm_camera_sensor_info *s_info;
+		s_info = cam_dev[i]->dev.platform_data;
+		msm_get_cam_resources(s_info);
+		platform_device_register(cam_dev[i]);
+	}
+
+	platform_device_register(&msm7x30_device_vfe);
+	//platform_device_register(&msm8960_device_vpe);
+}
+
 #ifdef CONFIG_MSM_GEMINI
 static struct resource msm_gemini_resources[] = {
 	{
@@ -5344,9 +5379,6 @@ static struct platform_device *devices[] __initdata = {
 #ifdef CONFIG_MT9E013
 	&msm_camera_sensor_mt9e013,
 #endif
-#ifdef CONFIG_VX6953
-	&msm_camera_sensor_vx6953,
-#endif
 #ifdef CONFIG_SN12M0PZ
 	&msm_camera_sensor_sn12m0pz,
 #endif
@@ -6983,6 +7015,7 @@ static void __init msm7x30_init(void)
 	msm_add_host(0, &msm_usb_host_pdata);
 #endif
 	msm7x30_init_mmc();
+	msm7x30_init_cam();
 	msm7x30_init_nand();
 	msm_qsd_spi_init();
 
diff --git a/arch/arm/mach-msm/devices-msm7x30.c b/arch/arm/mach-msm/devices-msm7x30.c
index 017eed9..3befbe0 100644
--- a/arch/arm/mach-msm/devices-msm7x30.c
+++ b/arch/arm/mach-msm/devices-msm7x30.c
@@ -346,6 +346,55 @@ struct platform_device msm_device_ssbi7 = {
 };
 #endif /* CONFIG_I2C_SSBI */
 
+static struct resource msm_vfe_resources[] = {
+#if 0
+	{
+		.name	= "vfe31",
+		.start	= 0x04500000,
+		.end	= 0x04500000 + SZ_1M - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "vfe31",
+		.start	= VFE_IRQ,
+		.end	= VFE_IRQ,
+		.flags	= IORESOURCE_IRQ,
+ 	},
+#endif
+	{
+		.name	= "vfe31",
+		.start	= 0xA6000000,
+		.end	= 0xA6000000 + SZ_1M - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "vfe31",
+		.start	= INT_VFE,
+		.end	= INT_VFE,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device msm7x30_device_vfe = {
+	.name           = "msm_vfe",
+	.id             = 0,
+	.resource       = msm_vfe_resources,
+	.num_resources  = ARRAY_SIZE(msm_vfe_resources),
+};
+
+struct resource msm_camera_resources[] = {
+	{
+		.flags  = IORESOURCE_DMA,
+	}
+};
+
+int __init msm_get_cam_resources(struct msm_camera_sensor_info *s_info)
+{
+	s_info->resource = msm_camera_resources;
+	s_info->num_resources = ARRAY_SIZE(msm_camera_resources);
+	return 0;
+}
+
 #define MSM_HSUSB_PHYS        0xA3600000
 static struct resource resources_hsusb_otg[] = {
 	{
diff --git a/arch/arm/mach-msm/devices.h b/arch/arm/mach-msm/devices.h
index 48686f0..5c2c895 100644
--- a/arch/arm/mach-msm/devices.h
+++ b/arch/arm/mach-msm/devices.h
@@ -65,6 +65,7 @@ extern struct platform_device msm8960_device_csid1;
 extern struct platform_device msm8960_device_ispif;
 extern struct platform_device msm8960_device_vfe;
 extern struct platform_device msm8960_device_vpe;
+extern struct platform_device msm7x30_device_vfe;
 
 extern struct platform_device apq8064_device_uart_gsbi1;
 extern struct platform_device apq8064_device_uart_gsbi3;
diff --git a/arch/arm/mach-msm/include/mach/camera.h b/arch/arm/mach-msm/include/mach/camera.h
index 1745f26..d77ac18 100644
--- a/arch/arm/mach-msm/include/mach/camera.h
+++ b/arch/arm/mach-msm/include/mach/camera.h
@@ -28,7 +28,7 @@
 
 #define CONFIG_MSM_CAMERA_DEBUG
 #ifdef CONFIG_MSM_CAMERA_DEBUG
-#define CDBG(fmt, args...) pr_debug(fmt, ##args)
+#define CDBG(fmt, args...) printk(fmt, ##args)
 #else
 #define CDBG(fmt, args...) do { } while (0)
 #endif
diff --git a/drivers/media/video/msm/Kconfig b/drivers/media/video/msm/Kconfig
index 0d822bb..24f2b68 100644
--- a/drivers/media/video/msm/Kconfig
+++ b/drivers/media/video/msm/Kconfig
@@ -65,7 +65,7 @@ config WEBCAM_OV9726
 #	This uses the CSI interface.
 config VX6953
 	bool "Sensor VX6953 (BAYER 5M)"
-	depends on MSM_CAMERA && (ARCH_MSM7X30 || ARCH_MSM8X60)
+	depends on MSM_CAMERA && (ARCH_MSM7X30 || ARCH_MSM8X60 || ARCH_MSM8960)
 	default y
 	---help---
 	STM 5M Bayer Sensor with EDOF
@@ -214,3 +214,9 @@ config QUP_EXCLUSIVE_TO_CAMERA
 	  by QUP in the board file as QUP is used by
 	  applications other than camera.
 
+config S5K4ECGX
+	bool "Sensor s5k4ecgx (BAYER / JPG 5M)"
+	depends on MSM_CAMERA && ARCH_MSM7X30
+	default y
+	---help---
+	  SAMSUNG 5M Bayer / JPG Sensor
diff --git a/drivers/media/video/msm/Makefile b/drivers/media/video/msm/Makefile
index 6f39576..d7aa7cb 100644
--- a/drivers/media/video/msm/Makefile
+++ b/drivers/media/video/msm/Makefile
@@ -14,34 +14,36 @@ obj-$(CONFIG_MSM_CAMERA) += msm_axi_qos.o gemini/
 obj-$(CONFIG_MSM_CAMERA_FLASH) += flash.o
 obj-$(CONFIG_ARCH_MSM_ARM11) += msm_vfe7x.o msm_io7x.o
 obj-$(CONFIG_ARCH_MSM7X27A) += msm_vfe7x27a.o msm_io_7x27a.o
-obj-$(CONFIG_ARCH_MSM7X30) += msm_vfe31.o msm_io_vfe31.o msm_vpe1.o
+ifeq ($(CONFIG_MSM_CAMERA_V4L2),y)
+  obj-$(CONFIG_ARCH_MSM7X30) += msm_vfe31_v4l2.o msm_io_vfe31.o msm_vpe.o
+else
+  obj-$(CONFIG_ARCH_MSM7X30) += msm_vfe31.o msm_io_vfe31.o msm_vpe1.o
+endif
 obj-$(CONFIG_ARCH_QSD8X50) += msm_vfe8x.o msm_vfe8x_proc.o msm_io8x.o
 obj-$(CONFIG_ARCH_MSM8X60) += msm_vfe31.o msm_io_8x60.o msm_vpe1.o
 obj-$(CONFIG_ARCH_MSM8960) += msm_io_8960.o msm_vfe32.o msm_vpe.o
-obj-$(CONFIG_MT9T013) += mt9t013.o mt9t013_reg.o
-obj-$(CONFIG_SN12M0PZ) += sn12m0pz.o sn12m0pz_reg.o
-obj-$(CONFIG_MT9P012) += mt9p012_reg.o
-obj-$(CONFIG_MSM_CAMERA_AF_FOXCONN) += mt9p012_fox.o
-obj-$(CONFIG_MSM_CAMERA_AF_BAM) += mt9p012_bam.o
-obj-$(CONFIG_MT9P012_KM) += mt9p012_km.o mt9p012_km_reg.o
-obj-$(CONFIG_MT9E013) += mt9e013.o mt9e013_reg.o
-obj-$(CONFIG_S5K3E2FX) += s5k3e2fx.o
-obj-$(CONFIG_S5K4E1) += s5k4e1.o s5k4e1_reg.o
 #FIXME: Merge the two ifeq causes VX6953 preview not coming up.
-ifeq ($(CONFIG_MSM_CAMERA_V4L2),y)
-  obj-$(CONFIG_VX6953) += vx6953_v4l2.o vx6953_reg_v4l2.o
-else
+ifeq ($(CONFIG_MSM_CAMERA_V4L2),n)
   obj-$(CONFIG_VX6953) += vx6953.o vx6953_reg.o
   obj-$(CONFIG_IMX074) += imx074.o imx074_reg.o
+  obj-$(CONFIG_MT9T013) += mt9t013.o mt9t013_reg.o
+  obj-$(CONFIG_SN12M0PZ) += sn12m0pz.o sn12m0pz_reg.o
+  obj-$(CONFIG_MT9P012) += mt9p012_reg.o
+  obj-$(CONFIG_MSM_CAMERA_AF_FOXCONN) += mt9p012_fox.o
+  obj-$(CONFIG_MSM_CAMERA_AF_BAM) += mt9p012_bam.o
+  obj-$(CONFIG_MT9P012_KM) += mt9p012_km.o mt9p012_km_reg.o
+  obj-$(CONFIG_MT9E013) += mt9e013.o mt9e013_reg.o
+  obj-$(CONFIG_S5K3E2FX) += s5k3e2fx.o
+  obj-$(CONFIG_S5K4E1) += s5k4e1.o s5k4e1_reg.o
+  obj-$(CONFIG_QS_S5K4E1) += qs_s5k4e1.o qs_s5k4e1_reg.o
+  obj-$(CONFIG_VB6801) += vb6801.o
+  obj-$(CONFIG_IMX072) += imx072.o imx072_reg.o
+  obj-$(CONFIG_WEBCAM_OV9726) += ov9726.o ov9726_reg.o
+  obj-$(CONFIG_WEBCAM_OV7692) += ov7692.o
+  obj-$(CONFIG_WEBCAM_OV7692_QRD) += ov7692_qrd.o
+  obj-$(CONFIG_OV5640) += ov5640.o
+  obj-$(CONFIG_MT9D112) += mt9d112.o mt9d112_reg.o
+  obj-$(CONFIG_MT9D113) += mt9d113.o mt9d113_reg.o
 endif
-obj-$(CONFIG_QS_S5K4E1) += qs_s5k4e1.o qs_s5k4e1_reg.o
-obj-$(CONFIG_VB6801) += vb6801.o
-obj-$(CONFIG_IMX072) += imx072.o imx072_reg.o
-obj-$(CONFIG_WEBCAM_OV9726) += ov9726.o ov9726_reg.o
-obj-$(CONFIG_WEBCAM_OV7692) += ov7692.o
-obj-$(CONFIG_WEBCAM_OV7692_QRD) += ov7692_qrd.o
-obj-$(CONFIG_OV5640) += ov5640.o
-obj-$(CONFIG_MT9D112) += mt9d112.o mt9d112_reg.o
 
-obj-$(CONFIG_MT9D113) += mt9d113.o mt9d113_reg.o
 obj-$(CONFIG_FB_MSM_WRITEBACK_MSM_PANEL) += wfd/
diff --git a/drivers/media/video/msm/msm.c b/drivers/media/video/msm/msm.c
index 251f12d..1ac68a9 100644
--- a/drivers/media/video/msm/msm.c
+++ b/drivers/media/video/msm/msm.c
@@ -23,6 +23,8 @@
 
 #define MSM_MAX_CAMERA_SENSORS 5
 
+//#define CONFIG_MSM_CAMERA_DEBUG
+
 #ifdef CONFIG_MSM_CAMERA_DEBUG
 #define D(fmt, args...) pr_debug("msm: " fmt, ##args)
 #else
@@ -909,17 +911,17 @@ static int msm_camera_v4l2_streamon(struct file *f, void *pctx,
 		return -EINVAL;
 	}
 
-	D("%s Calling videobuf_streamon", __func__);
+	pr_err("%s Calling videobuf_streamon", __func__);
 	/* if HW streaming on is successful, start buffer streaming */
 	rc = vb2_streamon(&pcam_inst->vid_bufq, buf_type);
-	D("%s, videobuf_streamon returns %d\n", __func__, rc);
+	pr_err("%s, videobuf_streamon returns %d\n", __func__, rc);
 
 	mutex_lock(&pcam->vid_lock);
 	/* turn HW (VFE/sensor) streaming */
 	pcam_inst->streamon = 1;
 	rc = msm_server_streamon(pcam, pcam_inst->my_index);
 	mutex_unlock(&pcam->vid_lock);
-	D("%s rc = %d\n", __func__, rc);
+	pr_err("%s rc = %d\n", __func__, rc);
 	return rc;
 }
 
@@ -1418,7 +1420,11 @@ static int msm_open(struct file *f)
 		pr_err("%s NULL pointer passed in!\n", __func__);
 		return rc;
 	}
-	mutex_lock(&pcam->vid_lock);
+	if (0 == g_server_dev.use_count) {
+		D("%s: daemon not yet started, returning -1", __func__);
+		return -1;
+	}
+ 	mutex_lock(&pcam->vid_lock);
 	for (i = 0; i < MSM_DEV_INST_MAX; i++) {
 		if (pcam->dev_inst[i] == NULL)
 			break;
@@ -1480,6 +1486,9 @@ static int msm_open(struct file *f)
 				__func__, rc);
 			return rc;
 		}
+		pr_err("%s: vpe v4l2_device_register_subdev %p\n",
+			__func__, pcam->mctl.isp_sdev->sd_vpe);
+#if 0
 		rc = v4l2_device_register_subdev(&pcam->v4l2_dev,
 					pcam->mctl.isp_sdev->sd_vpe);
 		if (rc < 0) {
@@ -1488,7 +1497,7 @@ static int msm_open(struct file *f)
 				__func__, rc);
 			return rc;
 		}
-
+#endif
 		rc = msm_setup_v4l2_event_queue(&pcam_inst->eventHandle,
 							pcam->pvdev);
 		if (rc < 0) {
@@ -1590,6 +1599,10 @@ static int msm_close(struct file *f)
 		pr_err("%s NULL pointer of camera device!\n", __func__);
 		return -EINVAL;
 	}
+	if (0 == g_server_dev.use_count) {
+		D("%s: use count = %d, returning 0", __func__, g_server_dev.use_count);
+		return 0;
+	}
 
 
 	mutex_lock(&pcam->vid_lock);
diff --git a/drivers/media/video/msm/msm_io_vfe31.c b/drivers/media/video/msm/msm_io_vfe31.c
index 1cd731c..60dc694 100644
--- a/drivers/media/video/msm/msm_io_vfe31.c
+++ b/drivers/media/video/msm/msm_io_vfe31.c
@@ -560,6 +560,7 @@ int msm_camio_enable(struct platform_device *pdev)
 	uint32_t val;
 	struct msm_camera_sensor_info *sinfo = pdev->dev.platform_data;
 	msm_camio_clk_enable(CAMIO_VFE_PBDG_CLK);
+	pr_err("%s: %d", __func__, sinfo->csi_if);
 	if (!sinfo->csi_if)
 		msm_camio_clk_enable(CAMIO_VFE_CAMIF_CLK);
 	else {
@@ -752,6 +753,7 @@ int msm_camio_sensor_clk_on(struct platform_device *pdev)
 	msm_camera_vreg_enable(pdev);
 	msm_camio_clk_enable(CAMIO_CAM_MCLK_CLK);
 	msm_camio_clk_enable(CAMIO_CAMIF_PAD_PBDG_CLK);
+	pr_err("%s: %d", __func__, sinfo->csi_if);
 	if (!sinfo->csi_if) {
 		camifpadio = request_mem_region(camio_ext.camifpadphy,
 			camio_ext.camifpadsz, pdev->name);
diff --git a/drivers/media/video/msm/msm_isp.c b/drivers/media/video/msm/msm_isp.c
index e4d4f27..c7fa14e 100644
--- a/drivers/media/video/msm/msm_isp.c
+++ b/drivers/media/video/msm/msm_isp.c
@@ -29,6 +29,8 @@
 
 #include "msm.h"
 
+//#define CONFIG_MSM_CAMERA_DEBUG
+
 #ifdef CONFIG_MSM_CAMERA_DEBUG
 #define D(fmt, args...) pr_debug("msm_isp: " fmt, ##args)
 #else
@@ -302,20 +304,24 @@ static int msm_isp_open(struct v4l2_subdev *sd,
 		pr_err("%s: vfe_init failed at %d\n",
 					__func__, rc);
 	}
-	D("%s: init vpe subdev", __func__);
+	D("%s: init vpe subdev %p", __func__, sd_vpe);
+#if 0
 	rc = msm_vpe_subdev_init(sd_vpe, sync, sync->pdev);
 	if (rc < 0) {
 		pr_err("%s: vpe_init failed at %d\n",
 					__func__, rc);
 	}
-	return rc;
+#endif
+ 	return rc;
 }
 
 static void msm_isp_release(struct msm_sync *psync)
 {
 	D("%s\n", __func__);
 	msm_vfe_subdev_release(psync->pdev);
-	msm_vpe_subdev_release(psync->pdev);
+#if 0
+ 	msm_vpe_subdev_release(psync->pdev);
+#endif
 }
 
 static int msm_config_vfe(struct v4l2_subdev *sd,
diff --git a/drivers/media/video/msm/msm_mctl.c b/drivers/media/video/msm/msm_mctl.c
index a3cf004..6ad6d79 100644
--- a/drivers/media/video/msm/msm_mctl.c
+++ b/drivers/media/video/msm/msm_mctl.c
@@ -32,6 +32,8 @@
 #include "msm_csiphy.h"
 #include "msm_ispif.h"
 
+//#define CONFIG_MSM_CAMERA_DEBUG
+
 #ifdef CONFIG_MSM_CAMERA_DEBUG
 #define D(fmt, args...) pr_debug("msm_mctl: " fmt, ##args)
 #else
@@ -197,11 +199,12 @@ static int msm_mctl_notify(struct msm_cam_media_controller *p_mctl,
 		break;
 	case NOTIFY_ISPIF_STREAM:
 		/* call ISPIF stream on/off */
-		rc = v4l2_subdev_call(p_mctl->ispif_sdev, video,
-				s_stream, (int)arg);
-		if (rc < 0)
-			return rc;
-
+		if (p_mctl->ispif_sdev) {
+			rc = v4l2_subdev_call(p_mctl->ispif_sdev, video,
+					s_stream, (int)arg);
+			if (rc < 0)
+				return rc;
+		}
 		break;
 	case NOTIFY_ISP_MSG_EVT:
 	case NOTIFY_VFE_MSG_OUT:
@@ -223,12 +226,16 @@ static int msm_mctl_notify(struct msm_cam_media_controller *p_mctl,
 			s_crystal_freq, *(uint32_t *)arg, 0);
 		break;
 	case NOTIFY_CSIPHY_CFG:
-		rc = v4l2_subdev_call(p_mctl->csiphy_sdev,
-			core, ioctl, VIDIOC_MSM_CSIPHY_CFG, arg);
+		if (p_mctl->csiphy_sdev) {
+			rc = v4l2_subdev_call(p_mctl->csiphy_sdev,
+				core, ioctl, VIDIOC_MSM_CSIPHY_CFG, arg);
+		}
 		break;
 	case NOTIFY_CSID_CFG:
-		rc = v4l2_subdev_call(p_mctl->csid_sdev,
-			core, ioctl, VIDIOC_MSM_CSID_CFG, arg);
+		if (p_mctl->csid_sdev) {
+			rc = v4l2_subdev_call(p_mctl->csid_sdev,
+				core, ioctl, VIDIOC_MSM_CSID_CFG, arg);
+		}
 		break;
 	default:
 		break;
@@ -342,70 +349,81 @@ static int msm_mctl_register_subdevs(struct msm_cam_media_controller *p_mctl,
 	struct device *dev;
 	int rc = -ENODEV;
 
-	/* register csiphy subdev */
+	/* register csiphy subdev, if driver is found */
 	driver = driver_find(MSM_CSIPHY_DRV_NAME, &platform_bus_type);
-	if (!driver)
-		goto out;
-
-	dev = driver_find_device(driver, NULL, (void *)core_index,
-				msm_mctl_subdev_match_core);
-	if (!dev)
-		goto out_put_driver;
+	if (driver) {
+		dev = driver_find_device(driver, NULL, (void *)core_index,
+					msm_mctl_subdev_match_core);
+		if (!dev) {
+			pr_err("%s: driver_find_device failed: %s\n",
+					__func__, MSM_CSIPHY_DRV_NAME);
+			goto out_put_driver;
+		}
 
-	p_mctl->csiphy_sdev = dev_get_drvdata(dev);
-	put_driver(driver);
+		p_mctl->csiphy_sdev = dev_get_drvdata(dev);
+		put_driver(driver);
+	}
 
-	/* register csid subdev */
+	/* register csid subdev, if driver is found */
 	driver = driver_find(MSM_CSID_DRV_NAME, &platform_bus_type);
-	if (!driver)
-		goto out;
-
-	dev = driver_find_device(driver, NULL, (void *)core_index,
-				msm_mctl_subdev_match_core);
-	if (!dev)
-		goto out_put_driver;
+	if (driver) {
+		dev = driver_find_device(driver, NULL, (void *)core_index,
+					msm_mctl_subdev_match_core);
+		if (!dev) {
+			pr_err("%s: driver_find failed: %s\n",
+					__func__, MSM_CSID_DRV_NAME);
+			goto out_put_driver;
+		}
 
-	p_mctl->csid_sdev = dev_get_drvdata(dev);
-	put_driver(driver);
+		p_mctl->csid_sdev = dev_get_drvdata(dev);
+		put_driver(driver);
+	}
 
-	/* register ispif subdev */
+	/* register ispif subdev, if driver is found */
 	driver = driver_find(MSM_ISPIF_DRV_NAME, &platform_bus_type);
-	if (!driver)
-		goto out;
-
-	dev = driver_find_device(driver, NULL, 0,
-				msm_mctl_subdev_match_core);
-	if (!dev)
-		goto out_put_driver;
+	if (driver) {
+		dev = driver_find_device(driver, NULL, 0,
+					msm_mctl_subdev_match_core);
+		if (!dev) {
+			pr_info("%s: %s failed", __func__, MSM_ISPIF_DRV_NAME);
+			goto out_put_driver;
+		}
 
-	p_mctl->ispif_sdev = dev_get_drvdata(dev);
-	put_driver(driver);
+		p_mctl->ispif_sdev = dev_get_drvdata(dev);
+		put_driver(driver);
+	}
 
 	/* register vfe subdev */
 	driver = driver_find(MSM_VFE_DRV_NAME, &platform_bus_type);
-	if (!driver)
+	if (!driver) {
+		pr_info("%s: %s failed", __func__, MSM_VFE_DRV_NAME);
 		goto out;
+	}
 
 	dev = driver_find_device(driver, NULL, 0,
 				msm_mctl_subdev_match_core);
-	if (!dev)
+	if (!dev) {
+		pr_info("%s: %s find_device failed", __func__, MSM_VFE_DRV_NAME);
 		goto out_put_driver;
+	}
 
 	p_mctl->isp_sdev->sd = dev_get_drvdata(dev);
 	put_driver(driver);
 
-	/* register vfe subdev */
+	/* register vpe subdev */
 	driver = driver_find(MSM_VPE_DRV_NAME, &platform_bus_type);
-	if (!driver)
-		goto out;
-
-	dev = driver_find_device(driver, NULL, 0,
-				msm_mctl_subdev_match_core);
-	if (!dev)
-		goto out_put_driver;
+	if (driver) {
+		dev = driver_find_device(driver, NULL, 0,
+					msm_mctl_subdev_match_core);
+		if (!dev) {
+			pr_info("%s: %s find_device failed", __func__, MSM_VPE_DRV_NAME);
+			goto out_put_driver;
+		}
+	
+		p_mctl->isp_sdev->sd_vpe = dev_get_drvdata(dev);
+		put_driver(driver);
+	}
 
-	p_mctl->isp_sdev->sd_vpe = dev_get_drvdata(dev);
-	put_driver(driver);
 
 	rc = 0;
 	return rc;
@@ -423,7 +441,7 @@ static int msm_mctl_open(struct msm_cam_media_controller *p_mctl,
 	struct msm_camera_sensor_info *sinfo;
 	struct msm_camera_device_platform_data *camdev;
 	uint8_t csid_core;
-	D("%s\n", __func__);
+	pr_err("%s\n", __func__);
 	if (!p_mctl) {
 		pr_err("%s: param is NULL", __func__);
 		return -EINVAL;
@@ -458,19 +476,45 @@ static int msm_mctl_open(struct msm_cam_media_controller *p_mctl,
 			goto msm_open_done;
 		}
 
-		rc = v4l2_subdev_call(p_mctl->csiphy_sdev, core, ioctl,
-			VIDIOC_MSM_CSIPHY_INIT, NULL);
-		if (rc < 0) {
-			pr_err("%s: csiphy initialization failed %d\n",
-				__func__, rc);
-			goto msm_open_done;
+		pr_err("%s: CSIPHY %p", __func__, p_mctl->csiphy_sdev);
+		if (p_mctl->csiphy_sdev) {
+			rc = v4l2_subdev_call(p_mctl->csiphy_sdev, core, ioctl,
+				VIDIOC_MSM_CSIPHY_INIT, NULL);
+			if (rc < 0) {
+				pr_err("%s: csiphy initialization failed %d\n",
+					__func__, rc);
+				goto msm_open_done;
+			}
 		}
 
-		rc = v4l2_subdev_call(p_mctl->csid_sdev, core, ioctl,
-			VIDIOC_MSM_CSID_INIT, &csid_version);
+		pr_err("%s: CSISDEV %p", __func__, p_mctl->csid_sdev);
+		if (p_mctl->csid_sdev) {
+			rc = v4l2_subdev_call(p_mctl->csid_sdev, core, ioctl,
+				VIDIOC_MSM_CSID_INIT, &csid_version);
+			if (rc < 0) {
+				pr_err("%s: csid initialization failed %d\n",
+					__func__, rc);
+				goto msm_open_done;
+			}
+		}
+
+		pr_err("%s: ISPIF %p", __func__, p_mctl->ispif_sdev);
+		if (p_mctl->ispif_sdev) {
+			rc = v4l2_subdev_call(p_mctl->ispif_sdev, core, ioctl,
+				VIDIOC_MSM_ISPIF_INIT, &csid_version);
+			if (rc < 0) {
+				pr_err("%s: ispif initialization failed %d\n",
+					__func__, rc);
+				goto msm_open_done;
+			}
+		}
+
+		/* then sensor - move sub dev later*/
+		if (sync->sctrl.s_init)
+			rc = sync->sctrl.s_init(sync->sdata);
+
 		if (rc < 0) {
-			pr_err("%s: csid initialization failed %d\n",
-				__func__, rc);
+			pr_err("%s: isp init failed: %d\n", __func__, rc);
 			goto msm_open_done;
 		}
 
@@ -484,29 +528,13 @@ static int msm_mctl_open(struct msm_cam_media_controller *p_mctl,
 			goto msm_open_done;
 		}
 
-		rc = v4l2_subdev_call(p_mctl->ispif_sdev, core, ioctl,
-			VIDIOC_MSM_ISPIF_INIT, &csid_version);
-		if (rc < 0) {
-			pr_err("%s: ispif initialization failed %d\n",
-				__func__, rc);
-			goto msm_open_done;
-		}
-
-		/* then sensor - move sub dev later*/
-		if (sync->sctrl.s_init)
-			rc = sync->sctrl.s_init(sync->sdata);
-
-		if (rc < 0) {
-			pr_err("%s: isp init failed: %d\n", __func__, rc);
-			goto msm_open_done;
-		}
-
+#if 0
 		pm_qos_add_request(&p_mctl->pm_qos_req_list,
 					PM_QOS_CPU_DMA_LATENCY,
 					PM_QOS_DEFAULT_VALUE);
 		pm_qos_update_request(&p_mctl->pm_qos_req_list,
 					MSM_V4L2_SWFI_LATENCY);
-
+#endif
 		sync->apps_id = apps_id;
 		sync->opencnt++;
 	}
@@ -521,17 +549,23 @@ static int msm_mctl_release(struct msm_cam_media_controller *p_mctl)
 	int rc = 0;
 	struct msm_sync *sync = &(p_mctl->sync);
 
-	v4l2_subdev_call(p_mctl->ispif_sdev, core, ioctl,
-		VIDIOC_MSM_ISPIF_RELEASE, NULL);
+	if (p_mctl->ispif_sdev) {
+		v4l2_subdev_call(p_mctl->ispif_sdev, core, ioctl,
+			VIDIOC_MSM_ISPIF_RELEASE, NULL);
+	}
 
 	if (p_mctl->isp_sdev && p_mctl->isp_sdev->isp_release)
 		p_mctl->isp_sdev->isp_release(&p_mctl->sync);
 
-	v4l2_subdev_call(p_mctl->csid_sdev, core, ioctl,
-		VIDIOC_MSM_CSID_RELEASE, NULL);
+	if (p_mctl->csid_sdev) {
+		v4l2_subdev_call(p_mctl->csid_sdev, core, ioctl,
+			VIDIOC_MSM_CSID_RELEASE, NULL);
+	}
 
-	v4l2_subdev_call(p_mctl->csiphy_sdev, core, ioctl,
-		VIDIOC_MSM_CSIPHY_RELEASE, NULL);
+	if (p_mctl->csiphy_sdev) {
+		v4l2_subdev_call(p_mctl->csiphy_sdev, core, ioctl,
+			VIDIOC_MSM_CSIPHY_RELEASE, NULL);
+	}
 
 	if (p_mctl->sync.actctrl.a_power_down)
 		p_mctl->sync.actctrl.a_power_down();
@@ -543,11 +577,11 @@ static int msm_mctl_release(struct msm_cam_media_controller *p_mctl)
 	if (rc < 0)
 		pr_err("%s: msm_camio_sensor_clk_off failed:%d\n",
 			 __func__, rc);
-
+#if 0
 	pm_qos_update_request(&p_mctl->pm_qos_req_list,
 				PM_QOS_DEFAULT_VALUE);
 	pm_qos_remove_request(&p_mctl->pm_qos_req_list);
-
+#endif
 	return rc;
 }
 
diff --git a/drivers/media/video/msm/msm_vfe31_v4l2.c b/drivers/media/video/msm/msm_vfe31_v4l2.c
new file mode 100755
index 0000000..ff88569
--- /dev/null
+++ b/drivers/media/video/msm/msm_vfe31_v4l2.c
@@ -0,0 +1,3556 @@
+/* Copyright (c) 2010-2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/uaccess.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/regulator/consumer.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <mach/irqs.h>
+#include <mach/camera.h>
+#include <asm/atomic.h>
+
+#include "msm.h"
+#include "msm_vfe31_v4l2.h"
+
+//#undef CDBG
+//#define CDBG pr_err
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include <media/msm_isp.h>
+
+
+atomic_t irq_cnt;
+
+#define CHECKED_COPY_FROM_USER(in) {					\
+	if (copy_from_user((in), (void __user *)cmd->value,		\
+			cmd->length)) {					\
+		rc = -EFAULT;						\
+		break;							\
+	}								\
+}
+
+static struct vfe31_ctrl_type *vfe31_ctrl;
+static void *vfe_syncdata;
+static uint32_t vfe_clk_rate;
+
+#define VFE31_AXI_OFFSET 0x0050
+#define vfe31_get_ch_ping_addr(chn) \
+	(msm_io_r(vfe31_ctrl->vfebase + 0x0050 + 0x18 * (chn)))
+#define vfe31_get_ch_pong_addr(chn) \
+	(msm_io_r(vfe31_ctrl->vfebase + 0x0050 + 0x18 * (chn) + 4))
+#define vfe31_get_ch_addr(ping_pong, chn) \
+	(((ping_pong) & (1 << (chn))) == 0 ? \
+	vfe31_get_ch_pong_addr(chn) : vfe31_get_ch_ping_addr(chn))
+
+#define vfe31_put_ch_ping_addr(chn, addr) \
+	(msm_io_w((addr), vfe31_ctrl->vfebase + 0x0050 + 0x18 * (chn)))
+#define vfe31_put_ch_pong_addr(chn, addr) \
+	(msm_io_w((addr), vfe31_ctrl->vfebase + 0x0050 + 0x18 * (chn) + 4))
+#define vfe31_put_ch_addr(ping_pong, chn, addr) \
+	(((ping_pong) & (1 << (chn))) == 0 ?   \
+	vfe31_put_ch_pong_addr((chn), (addr)) : \
+	vfe31_put_ch_ping_addr((chn), (addr)))
+
+struct vfe31_isr_queue_cmd {
+	struct list_head list;
+	uint32_t                           vfeInterruptStatus0;
+	uint32_t                           vfeInterruptStatus1;
+	uint32_t                           vfePingPongStatus;
+	struct vfe_frame_asf_info          vfeAsfFrameInfo;
+	struct vfe_frame_bpc_info          vfeBpcFrameInfo;
+	struct vfe_msg_camif_status        vfeCamifStatusLocal;
+};
+
+//TODO: Why is V32 reference in arch/arm/mach-msm/include/mach/camera.h?
+#define VFE_MSG_V31_START VFE_MSG_V32_START
+#define VFE_MSG_V31_CAPTURE VFE_MSG_V32_CAPTURE
+#define VFE_MSG_V31_START_RECORDING VFE_MSG_V32_START_RECORDING
+
+
+static struct vfe31_cmd_type vfe31_cmd[] = {
+/* 0*/	{VFE_CMD_DUMMY_0},
+		{VFE_CMD_SET_CLK},
+		{VFE_CMD_RESET},
+		{VFE_CMD_START},
+		{VFE_CMD_TEST_GEN_START},
+/* 5*/	{VFE_CMD_OPERATION_CFG, V31_OPERATION_CFG_LEN},
+		{VFE_CMD_AXI_OUT_CFG, V31_AXI_OUT_LEN, V31_AXI_OUT_OFF, 0xFF},
+		{VFE_CMD_CAMIF_CFG, V31_CAMIF_LEN, V31_CAMIF_OFF, 0xFF},
+		{VFE_CMD_AXI_INPUT_CFG},
+		{VFE_CMD_BLACK_LEVEL_CFG, V31_BLACK_LEVEL_LEN,
+		V31_BLACK_LEVEL_OFF,
+		0xFF},
+/*10*/  {VFE_CMD_MESH_ROLL_OFF_CFG, V31_MESH_ROLL_OFF_CFG_LEN,
+		V31_MESH_ROLL_OFF_CFG_OFF, 0xFF},
+		{VFE_CMD_DEMUX_CFG, V31_DEMUX_LEN, V31_DEMUX_OFF, 0xFF},
+		{VFE_CMD_FOV_CFG, V31_FOV_LEN, V31_FOV_OFF, 0xFF},
+		{VFE_CMD_MAIN_SCALER_CFG, V31_MAIN_SCALER_LEN,
+		V31_MAIN_SCALER_OFF, 0xFF},
+		{VFE_CMD_WB_CFG, V31_WB_LEN, V31_WB_OFF, 0xFF},
+/*15*/	{VFE_CMD_COLOR_COR_CFG, V31_COLOR_COR_LEN, V31_COLOR_COR_OFF, 0xFF},
+		{VFE_CMD_RGB_G_CFG, V31_RGB_G_LEN, V31_RGB_G_OFF, 0xFF},
+		{VFE_CMD_LA_CFG, V31_LA_LEN, V31_LA_OFF, 0xFF },
+		{VFE_CMD_CHROMA_EN_CFG, V31_CHROMA_EN_LEN, V31_CHROMA_EN_OFF,
+		0xFF},
+		{VFE_CMD_CHROMA_SUP_CFG, V31_CHROMA_SUP_LEN, V31_CHROMA_SUP_OFF,
+		0xFF},
+/*20*/	{VFE_CMD_MCE_CFG, V31_MCE_LEN, V31_MCE_OFF, 0xFF},
+		{VFE_CMD_SK_ENHAN_CFG, V31_SCE_LEN, V31_SCE_OFF, 0xFF},
+		{VFE_CMD_ASF_CFG, V31_ASF_LEN, V31_ASF_OFF, 0xFF},
+		{VFE_CMD_S2Y_CFG, V31_S2Y_LEN, V31_S2Y_OFF, 0xFF},
+		{VFE_CMD_S2CbCr_CFG, V31_S2CbCr_LEN, V31_S2CbCr_OFF, 0xFF},
+/*25*/	{VFE_CMD_CHROMA_SUBS_CFG, V31_CHROMA_SUBS_LEN, V31_CHROMA_SUBS_OFF,
+		0xFF},
+		{VFE_CMD_OUT_CLAMP_CFG, V31_OUT_CLAMP_LEN, V31_OUT_CLAMP_OFF,
+		0xFF},
+		{VFE_CMD_FRAME_SKIP_CFG, V31_FRAME_SKIP_LEN, V31_FRAME_SKIP_OFF,
+		0xFF},
+		{VFE_CMD_DUMMY_1},
+		{VFE_CMD_DUMMY_2},
+/*30*/	{VFE_CMD_DUMMY_3},
+		{VFE_CMD_UPDATE},
+		{VFE_CMD_BL_LVL_UPDATE, V31_BLACK_LEVEL_LEN,
+		V31_BLACK_LEVEL_OFF, 0xFF},
+		{VFE_CMD_DEMUX_UPDATE, V31_DEMUX_LEN, V31_DEMUX_OFF, 0xFF},
+		{VFE_CMD_FOV_UPDATE, V31_FOV_LEN, V31_FOV_OFF, 0xFF},
+/*35*/	{VFE_CMD_MAIN_SCALER_UPDATE, V31_MAIN_SCALER_LEN, V31_MAIN_SCALER_OFF,
+		0xFF},
+		{VFE_CMD_WB_UPDATE, V31_WB_LEN, V31_WB_OFF, 0xFF},
+		{VFE_CMD_COLOR_COR_UPDATE, V31_COLOR_COR_LEN, V31_COLOR_COR_OFF,
+		0xFF},
+		{VFE_CMD_RGB_G_UPDATE, V31_RGB_G_LEN, V31_CHROMA_EN_OFF, 0xFF},
+		{VFE_CMD_LA_UPDATE, V31_LA_LEN, V31_LA_OFF, 0xFF },
+/*40*/	{VFE_CMD_CHROMA_EN_UPDATE, V31_CHROMA_EN_LEN, V31_CHROMA_EN_OFF,
+		0xFF},
+		{VFE_CMD_CHROMA_SUP_UPDATE, V31_CHROMA_SUP_LEN,
+		V31_CHROMA_SUP_OFF, 0xFF},
+		{VFE_CMD_MCE_UPDATE, V31_MCE_LEN, V31_MCE_OFF, 0xFF},
+		{VFE_CMD_SK_ENHAN_UPDATE, V31_SCE_LEN, V31_SCE_OFF, 0xFF},
+		{VFE_CMD_S2CbCr_UPDATE, V31_S2CbCr_LEN, V31_S2CbCr_OFF, 0xFF},
+/*45*/	{VFE_CMD_S2Y_UPDATE, V31_S2Y_LEN, V31_S2Y_OFF, 0xFF},
+		{VFE_CMD_ASF_UPDATE, V31_ASF_UPDATE_LEN, V31_ASF_OFF, 0xFF},
+		{VFE_CMD_FRAME_SKIP_UPDATE},
+		{VFE_CMD_CAMIF_FRAME_UPDATE},
+		{VFE_CMD_STATS_AF_UPDATE, V31_STATS_AF_LEN, V31_STATS_AF_OFF},
+/*50*/	{VFE_CMD_STATS_AE_UPDATE, V31_STATS_AE_LEN, V31_STATS_AE_OFF},
+		{VFE_CMD_STATS_AWB_UPDATE, V31_STATS_AWB_LEN,
+		V31_STATS_AWB_OFF},
+		{VFE_CMD_STATS_RS_UPDATE, V31_STATS_RS_LEN, V31_STATS_RS_OFF},
+		{VFE_CMD_STATS_CS_UPDATE, V31_STATS_CS_LEN, V31_STATS_CS_OFF},
+		{VFE_CMD_STATS_SKIN_UPDATE},
+/*55*/	{VFE_CMD_STATS_IHIST_UPDATE, V31_STATS_IHIST_LEN, V31_STATS_IHIST_OFF},
+		{VFE_CMD_DUMMY_4},
+		{VFE_CMD_EPOCH1_ACK},
+		{VFE_CMD_EPOCH2_ACK},
+		{VFE_CMD_START_RECORDING},
+/*60*/	{VFE_CMD_STOP_RECORDING},
+		{VFE_CMD_DUMMY_5},
+		{VFE_CMD_DUMMY_6},
+		{VFE_CMD_CAPTURE, V31_CAPTURE_LEN, 0xFF},
+		{VFE_CMD_DUMMY_7},
+/*65*/	{VFE_CMD_STOP},
+		{VFE_CMD_GET_HW_VERSION, V31_GET_HW_VERSION_LEN,
+		V31_GET_HW_VERSION_OFF},
+		{VFE_CMD_GET_FRAME_SKIP_COUNTS},
+		{VFE_CMD_OUTPUT1_BUFFER_ENQ},
+		{VFE_CMD_OUTPUT2_BUFFER_ENQ},
+/*70*/	{VFE_CMD_OUTPUT3_BUFFER_ENQ},
+		{VFE_CMD_JPEG_OUT_BUF_ENQ},
+		{VFE_CMD_RAW_OUT_BUF_ENQ},
+		{VFE_CMD_RAW_IN_BUF_ENQ},
+		{VFE_CMD_STATS_AF_ENQ},
+/*75*/	{VFE_CMD_STATS_AE_ENQ},
+		{VFE_CMD_STATS_AWB_ENQ},
+		{VFE_CMD_STATS_RS_ENQ},
+		{VFE_CMD_STATS_CS_ENQ},
+		{VFE_CMD_STATS_SKIN_ENQ},
+/*80*/	{VFE_CMD_STATS_IHIST_ENQ},
+		{VFE_CMD_DUMMY_8},
+		{VFE_CMD_JPEG_ENC_CFG},
+		{VFE_CMD_DUMMY_9},
+		{VFE_CMD_STATS_AF_START, V31_STATS_AF_LEN, V31_STATS_AF_OFF},
+/*85*/	{VFE_CMD_STATS_AF_STOP},
+		{VFE_CMD_STATS_AE_START, V31_STATS_AE_LEN, V31_STATS_AE_OFF},
+		{VFE_CMD_STATS_AE_STOP},
+		{VFE_CMD_STATS_AWB_START, V31_STATS_AWB_LEN, V31_STATS_AWB_OFF},
+		{VFE_CMD_STATS_AWB_STOP},
+/*90*/	{VFE_CMD_STATS_RS_START, V31_STATS_RS_LEN, V31_STATS_RS_OFF},
+		{VFE_CMD_STATS_RS_STOP},
+		{VFE_CMD_STATS_CS_START, V31_STATS_CS_LEN, V31_STATS_CS_OFF},
+		{VFE_CMD_STATS_CS_STOP},
+		{VFE_CMD_STATS_SKIN_START},
+/*95*/	{VFE_CMD_STATS_SKIN_STOP},
+		{VFE_CMD_STATS_IHIST_START,
+		V31_STATS_IHIST_LEN, V31_STATS_IHIST_OFF},
+		{VFE_CMD_STATS_IHIST_STOP},
+		{VFE_CMD_DUMMY_10},
+		{VFE_CMD_SYNC_TIMER_SETTING, V31_SYNC_TIMER_LEN,
+			V31_SYNC_TIMER_OFF},
+/*100*/	{VFE_CMD_ASYNC_TIMER_SETTING, V31_ASYNC_TIMER_LEN, V31_ASYNC_TIMER_OFF},
+		{VFE_CMD_LIVESHOT},
+		{VFE_CMD_LA_SETUP},
+		{VFE_CMD_LINEARIZATION_CFG},
+		{VFE_CMD_DEMOSAICV3},
+/*105*/	{VFE_CMD_DEMOSAICV3_ABCC_CFG},
+      {VFE_CMD_DEMOSAICV3_DBCC_CFG},
+		{VFE_CMD_DEMOSAICV3_DBPC_CFG, V31_DEMOSAICV3_DBPC_CFG_OFF,
+			V31_DEMOSAICV3_DBPC_LEN},
+		{VFE_CMD_DEMOSAICV3_ABF_CFG, V31_DEMOSAICV3_ABF_LEN,
+			V31_DEMOSAICV3_ABF_OFF},
+		{VFE_CMD_DEMOSAICV3_ABCC_UPDATE},
+/*110*/	{VFE_CMD_DEMOSAICV3_DBCC_UPDATE},
+		{VFE_CMD_DEMOSAICV3_DBPC_UPDATE, V31_DEMOSAICV3_DBPC_CFG_OFF,
+			V31_DEMOSAICV3_DBPC_LEN},
+		{VFE_CMD_XBAR_CFG},
+		{VFE_CMD_MODULE_CFG, V31_MODULE_CFG_LEN, V31_MODULE_CFG_OFF},
+		{VFE_CMD_ZSL},
+/*115*/	{VFE_CMD_LINEARIZATION_UPDATE},
+		{VFE_CMD_DEMOSAICV3_ABF_UPDATE, V31_DEMOSAICV3_ABF_LEN,
+			V31_DEMOSAICV3_ABF_OFF},
+		{VFE_CMD_CLF_CFG},
+		{VFE_CMD_CLF_LUMA_UPDATE},
+		{VFE_CMD_CLF_CHROMA_UPDATE},
+/*120*/ {VFE_CMD_PCA_ROLL_OFF_CFG},
+		{VFE_CMD_PCA_ROLL_OFF_UPDATE},
+		{VFE_CMD_GET_REG_DUMP},
+		{VFE_CMD_GET_LINEARIZATON_TABLE},
+		{VFE_CMD_GET_MESH_ROLLOFF_TABLE},
+/*125*/ {VFE_CMD_GET_PCA_ROLLOFF_TABLE},
+		{VFE_CMD_GET_RGB_G_TABLE},
+		{VFE_CMD_GET_LA_TABLE},
+		{VFE_CMD_DEMOSAICV3_UPDATE},
+};
+
+uint32_t vfe31_AXI_WM_CFG[] = {
+	0x0000004C,
+	0x00000064,
+	0x0000007C,
+	0x00000094,
+	0x000000AC,
+	0x000000C4,
+	0x000000DC,
+};
+
+static const char *vfe31_general_cmd[] = {
+	"DUMMY_0",  /* 0 */
+	"SET_CLK",
+	"RESET",
+	"START",
+	"TEST_GEN_START",
+	"OPERATION_CFG",  /* 5 */
+	"AXI_OUT_CFG",
+	"CAMIF_CFG",
+	"AXI_INPUT_CFG",
+	"BLACK_LEVEL_CFG",
+	"ROLL_OFF_CFG",  /* 10 */
+	"DEMUX_CFG",
+	"FOV_CFG",
+	"MAIN_SCALER_CFG",
+	"WB_CFG",
+	"COLOR_COR_CFG", /* 15 */
+	"RGB_G_CFG",
+	"LA_CFG",
+	"CHROMA_EN_CFG",
+	"CHROMA_SUP_CFG",
+	"MCE_CFG", /* 20 */
+	"SK_ENHAN_CFG",
+	"ASF_CFG",
+	"S2Y_CFG",
+	"S2CbCr_CFG",
+	"CHROMA_SUBS_CFG",  /* 25 */
+	"OUT_CLAMP_CFG",
+	"FRAME_SKIP_CFG",
+	"DUMMY_1",
+	"DUMMY_2",
+	"DUMMY_3",  /* 30 */
+	"UPDATE",
+	"BL_LVL_UPDATE",
+	"DEMUX_UPDATE",
+	"FOV_UPDATE",
+	"MAIN_SCALER_UPDATE",  /* 35 */
+	"WB_UPDATE",
+	"COLOR_COR_UPDATE",
+	"RGB_G_UPDATE",
+	"LA_UPDATE",
+	"CHROMA_EN_UPDATE",  /* 40 */
+	"CHROMA_SUP_UPDATE",
+	"MCE_UPDATE",
+	"SK_ENHAN_UPDATE",
+	"S2CbCr_UPDATE",
+	"S2Y_UPDATE",  /* 45 */
+	"ASF_UPDATE",
+	"FRAME_SKIP_UPDATE",
+	"CAMIF_FRAME_UPDATE",
+	"STATS_AF_UPDATE",
+	"STATS_AE_UPDATE",  /* 50 */
+	"STATS_AWB_UPDATE",
+	"STATS_RS_UPDATE",
+	"STATS_CS_UPDATE",
+	"STATS_SKIN_UPDATE",
+	"STATS_IHIST_UPDATE",  /* 55 */
+	"DUMMY_4",
+	"EPOCH1_ACK",
+	"EPOCH2_ACK",
+	"START_RECORDING",
+	"STOP_RECORDING",  /* 60 */
+	"DUMMY_5",
+	"DUMMY_6",
+	"CAPTURE",
+	"DUMMY_7",
+	"STOP",  /* 65 */
+	"GET_HW_VERSION",
+	"GET_FRAME_SKIP_COUNTS",
+	"OUTPUT1_BUFFER_ENQ",
+	"OUTPUT2_BUFFER_ENQ",
+	"OUTPUT3_BUFFER_ENQ",  /* 70 */
+	"JPEG_OUT_BUF_ENQ",
+	"RAW_OUT_BUF_ENQ",
+	"RAW_IN_BUF_ENQ",
+	"STATS_AF_ENQ",
+	"STATS_AE_ENQ",  /* 75 */
+	"STATS_AWB_ENQ",
+	"STATS_RS_ENQ",
+	"STATS_CS_ENQ",
+	"STATS_SKIN_ENQ",
+	"STATS_IHIST_ENQ",  /* 80 */
+	"DUMMY_8",
+	"JPEG_ENC_CFG",
+	"DUMMY_9",
+	"STATS_AF_START",
+	"STATS_AF_STOP",  /* 85 */
+	"STATS_AE_START",
+	"STATS_AE_STOP",
+	"STATS_AWB_START",
+	"STATS_AWB_STOP",
+	"STATS_RS_START",  /* 90 */
+	"STATS_RS_STOP",
+	"STATS_CS_START",
+	"STATS_CS_STOP",
+	"STATS_SKIN_START",
+	"STATS_SKIN_STOP",  /* 95 */
+	"STATS_IHIST_START",
+	"STATS_IHIST_STOP",
+	"DUMMY_10",
+	"SYNC_TIMER_SETTING",
+	"ASYNC_TIMER_SETTING",  /* 100 */
+	"LIVESHOT",
+	"LA_SETUP",
+	"LINEARIZATION_CFG",
+	"DEMOSAICV3",
+	"DEMOSAICV3_ABCC_CFG", /* 105 */
+	"DEMOSAICV3_DBCC_CFG",
+	"DEMOSAICV3_DBPC_CFG",
+	"DEMOSAICV3_ABF_CFG",
+	"DEMOSAICV3_ABCC_UPDATE",
+	"DEMOSAICV3_DBCC_UPDATE", /* 110 */
+	"DEMOSAICV3_DBPC_UPDATE",
+	"XBAR_CFG",
+	"EZTUNE_CFG",
+	"V31_ZSL",
+	"LINEARIZATION_UPDATE", /*115*/
+	"DEMOSAICV3_ABF_UPDATE",
+	"CLF_CFG",
+	"CLF_LUMA_UPDATE",
+	"CLF_CHROMA_UPDATE",
+	"PCA_ROLL_OFF_CFG", /*120*/
+	"PCA_ROLL_OFF_UPDATE",
+	"GET_REG_DUMP",
+	"GET_LINEARIZATON_TABLE",
+	"GET_MESH_ROLLOFF_TABLE",
+	"GET_PCA_ROLLOFF_TABLE", /*125*/
+	"GET_RGB_G_TABLE",
+	"GET_LA_TABLE",
+	"DEMOSAICV3_UPDATE",
+};
+
+static void vfe31_subdev_notify(int id, int path)
+{
+	struct msm_vfe_resp *rp;
+	unsigned long flags = 0;
+	spin_lock_irqsave(&vfe31_ctrl->sd_notify_lock, flags);
+	rp = msm_isp_sync_alloc(sizeof(struct msm_vfe_resp), GFP_ATOMIC);
+	if (!rp) {
+		CDBG("rp: cannot allocate buffer\n");
+		return;
+	}
+	CDBG("vfe31_subdev_notify : msgId = %d\n", id);
+	rp->evt_msg.type   = MSM_CAMERA_MSG;
+	rp->evt_msg.msg_id = path;
+	rp->type	   = id;
+	v4l2_subdev_notify(&vfe31_ctrl->subdev, NOTIFY_VFE_BUF_EVT, rp);
+	spin_unlock_irqrestore(&vfe31_ctrl->sd_notify_lock, flags);
+}
+
+static void vfe_send_outmsg(struct v4l2_subdev *sd, uint8_t msgid,
+	uint32_t ch0_paddr, uint32_t ch1_paddr, uint32_t ch2_paddr)
+{
+	struct isp_msg_output msg;
+
+	msg.output_id = msgid;
+	msg.buf.ch_paddr[0]	= ch0_paddr;
+	msg.buf.ch_paddr[1]	= ch1_paddr;
+	msg.buf.ch_paddr[2]	= ch2_paddr;
+	msg.frameCounter = vfe31_ctrl->vfeFrameId;
+
+	v4l2_subdev_notify(&vfe31_ctrl->subdev,
+			NOTIFY_VFE_MSG_OUT,
+			&msg);
+	return;
+}
+
+static struct vfe31_output_ch *vfe31_get_ch(int path)
+{
+	struct vfe31_output_ch *ch = NULL;
+
+	switch (vfe31_ctrl->operation_mode) {
+	case VFE_MODE_OF_OPERATION_CONTINUOUS:
+		if (path == VFE_MSG_OUTPUT_P)
+			ch = &vfe31_ctrl->outpath.out0;
+		break;
+	case VFE_MODE_OF_OPERATION_SNAPSHOT:
+		if (path == VFE_MSG_OUTPUT_T)
+			ch = &vfe31_ctrl->outpath.out0;
+		else if (path == VFE_MSG_OUTPUT_S)
+			ch = &vfe31_ctrl->outpath.out1;
+		break;
+	case VFE_MODE_OF_OPERATION_VIDEO:
+		if (path == VFE_MSG_OUTPUT_P)
+			ch = &vfe31_ctrl->outpath.out0;
+		else if (path == VFE_MSG_OUTPUT_V)
+			ch = &vfe31_ctrl->outpath.out2;
+		break;
+	case VFE_MODE_OF_OPERATION_RAW_SNAPSHOT:
+		if (path == VFE_MSG_OUTPUT_S)
+			ch = &vfe31_ctrl->outpath.out0;
+		break;
+	case VFE_MODE_OF_OPERATION_ZSL:
+		if (path == VFE_MSG_OUTPUT_P)
+			ch = &vfe31_ctrl->outpath.out0;
+		else if (path == VFE_MSG_OUTPUT_T)
+			ch = &vfe31_ctrl->outpath.out1;
+		else if (path == VFE_MSG_OUTPUT_S)
+			ch = &vfe31_ctrl->outpath.out2;
+		break;
+	default:
+		pr_err("%s: Unsupported operation mode %d\n", __func__,
+					vfe31_ctrl->operation_mode);
+	}
+
+	BUG_ON(ch == NULL);
+	return ch;
+}
+
+static struct msm_free_buf *vfe31_check_free_buffer(int id, int path)
+{
+	struct vfe31_output_ch *outch = NULL;
+	struct msm_free_buf *b = NULL;
+	vfe31_subdev_notify(id, path);
+	outch = vfe31_get_ch(path);
+	if (outch->free_buf.ch_paddr[0])
+		b = &outch->free_buf;
+	return b;
+}
+
+static int vfe31_configure_pingpong_buffers(int id, int path)
+{
+	struct vfe31_output_ch *outch = NULL;
+	int rc = 0;
+	vfe31_subdev_notify(id, path);
+	outch = vfe31_get_ch(path);
+	if (outch->ping.ch_paddr[0] && outch->pong.ch_paddr[0]) {
+		/* Configure Preview Ping Pong */
+		pr_info("%s Configure ping/pong address for %d",
+						__func__, path);
+		vfe31_put_ch_ping_addr(outch->ch0,
+			outch->ping.ch_paddr[0]);
+		vfe31_put_ch_pong_addr(outch->ch0,
+			outch->pong.ch_paddr[0]);
+
+		if (vfe31_ctrl->operation_mode !=
+			VFE_MODE_OF_OPERATION_RAW_SNAPSHOT) {
+			vfe31_put_ch_ping_addr(outch->ch1,
+				outch->ping.ch_paddr[1]);
+			vfe31_put_ch_pong_addr(outch->ch1,
+				outch->pong.ch_paddr[1]);
+		}
+
+		if (outch->ping.num_planes > 2)
+			vfe31_put_ch_ping_addr(outch->ch2,
+				outch->ping.ch_paddr[2]);
+		if (outch->pong.num_planes > 2)
+			vfe31_put_ch_pong_addr(outch->ch2,
+				outch->pong.ch_paddr[2]);
+
+		/* avoid stale info */
+		memset(&outch->ping, 0, sizeof(struct msm_free_buf));
+		memset(&outch->pong, 0, sizeof(struct msm_free_buf));
+	} else {
+		pr_err("%s ping/pong addr is null!!", __func__);
+		rc = -EINVAL;
+	}
+	return rc;
+}
+
+static void vfe31_stop(void)
+{
+	unsigned long flags;
+
+	atomic_set(&vfe31_ctrl->vstate, 0);
+
+	/* for reset hw modules, and send msg when reset_irq comes.*/
+	spin_lock_irqsave(&vfe31_ctrl->stop_flag_lock, flags);
+	vfe31_ctrl->stop_ack_pending = TRUE;
+	spin_unlock_irqrestore(&vfe31_ctrl->stop_flag_lock, flags);
+
+	/* disable all interrupts.  */
+	msm_io_w(VFE_DISABLE_ALL_IRQS,
+		vfe31_ctrl->vfebase + VFE_IRQ_MASK_0);
+	msm_io_w(VFE_DISABLE_ALL_IRQS,
+			vfe31_ctrl->vfebase + VFE_IRQ_MASK_1);
+
+	/* clear all pending interrupts*/
+	msm_io_w(VFE_CLEAR_ALL_IRQS,
+		vfe31_ctrl->vfebase + VFE_IRQ_CLEAR_0);
+	msm_io_w(VFE_CLEAR_ALL_IRQS,
+		vfe31_ctrl->vfebase + VFE_IRQ_CLEAR_1);
+	/* Ensure the write order while writing
+	to the command register using the barrier */
+	msm_io_w_mb(1,
+		vfe31_ctrl->vfebase + VFE_IRQ_CMD);
+
+	/* now enable only halt_irq & reset_irq */
+	msm_io_w(0xf0000000,          /* this is for async timer. */
+		vfe31_ctrl->vfebase + VFE_IRQ_MASK_0);
+	msm_io_w(VFE_IMASK_AXI_HALT,
+		vfe31_ctrl->vfebase + VFE_IRQ_MASK_1);
+
+	/* then apply axi halt command. */
+	msm_io_w_mb(AXI_HALT,
+		vfe31_ctrl->vfebase + VFE_AXI_CMD);
+
+}
+
+static inline void vfe31_reset_free_buf_queue(
+	struct vfe31_output_ch *outch)
+{
+	unsigned long flags = 0;
+	struct vfe31_free_buf *free_buf = NULL;
+	spin_lock_irqsave(&outch->free_buf_lock, flags);
+	while (!list_empty(&outch->free_buf_head)) {
+		free_buf = list_first_entry(&outch->free_buf_head,
+			struct vfe31_free_buf, node);
+		if (free_buf) {
+			list_del_init(&free_buf->node);
+			kfree(free_buf);
+		}
+	}
+	spin_unlock_irqrestore(&outch->free_buf_lock, flags);
+}
+
+static int vfe31_config_axi(int mode, uint32_t *ao)
+{
+	int32_t *ch_info;
+
+	/* Update the corresponding write masters for each output*/
+	ch_info = ao + V31_AXI_CFG_LEN;
+	vfe31_ctrl->outpath.out0.ch0 = 0x0000FFFF & *ch_info;
+	vfe31_ctrl->outpath.out0.ch1 = 0x0000FFFF & (*ch_info++ >> 16);
+	vfe31_ctrl->outpath.out0.ch2 = 0x0000FFFF & *ch_info++;
+	vfe31_ctrl->outpath.out1.ch0 = 0x0000FFFF & *ch_info;
+	vfe31_ctrl->outpath.out1.ch1 = 0x0000FFFF & (*ch_info++ >> 16);
+	vfe31_ctrl->outpath.out1.ch2 = 0x0000FFFF & *ch_info++;
+	vfe31_ctrl->outpath.out2.ch0 = 0x0000FFFF & *ch_info;
+	vfe31_ctrl->outpath.out2.ch1 = 0x0000FFFF & (*ch_info++ >> 16);
+	vfe31_ctrl->outpath.out2.ch2 = 0x0000FFFF & *ch_info++;
+
+	switch (mode) {
+
+	case OUTPUT_2:
+		vfe31_ctrl->outpath.output_mode |= VFE31_OUTPUT_MODE_PT;
+		break;
+
+	case OUTPUT_1_AND_2:
+		/* use wm0& 4 for thumbnail, wm1&5 for main image.*/
+		vfe31_ctrl->outpath.output_mode |=
+			VFE31_OUTPUT_MODE_S;  /* main image.*/
+		vfe31_ctrl->outpath.output_mode |=
+			VFE31_OUTPUT_MODE_PT;  /* thumbnail. */
+		break;
+
+	case OUTPUT_1_2_AND_3:
+		CDBG("%s: OUTPUT_1_2_AND_3", __func__);
+		/* use wm0& 4 for postview, wm1&5 for preview.*/
+		/* use wm2& 6 for main img */
+		vfe31_ctrl->outpath.output_mode |=
+			VFE31_OUTPUT_MODE_S;  /* main image.*/
+		vfe31_ctrl->outpath.output_mode |=
+			VFE31_OUTPUT_MODE_P;  /* preview. */
+		vfe31_ctrl->outpath.output_mode |=
+			VFE31_OUTPUT_MODE_T;  /* thumbnail. */
+		break;
+
+	case OUTPUT_1_AND_3:
+		/* use wm0& 4 for preview, wm1&5 for video.*/
+		vfe31_ctrl->outpath.output_mode |=
+			VFE31_OUTPUT_MODE_V;  /* video*/
+		vfe31_ctrl->outpath.output_mode |=
+			VFE31_OUTPUT_MODE_PT;  /* preview */
+		break;
+	case CAMIF_TO_AXI_VIA_OUTPUT_2:
+		/* use wm0 only */
+		CDBG("config axi for raw snapshot.\n");
+		vfe31_ctrl->outpath.out1.ch0 = 0; /* raw */
+		vfe31_ctrl->outpath.output_mode |= VFE31_OUTPUT_MODE_S;
+		break;
+	default:
+		break;
+	}
+	msm_io_memcpy(vfe31_ctrl->vfebase +
+		vfe31_cmd[VFE_CMD_AXI_OUT_CFG].offset, ao,
+		vfe31_cmd[VFE_CMD_AXI_OUT_CFG].length - V31_AXI_CH_INF_LEN);
+	return 0;
+}
+
+static void vfe31_reset_internal_variables(void)
+{
+	unsigned long flags;
+	vfe31_ctrl->vfeImaskCompositePacked = 0;
+	/* state control variables */
+	vfe31_ctrl->start_ack_pending = FALSE;
+	atomic_set(&irq_cnt, 0);
+
+	spin_lock_irqsave(&vfe31_ctrl->xbar_lock, flags);
+	vfe31_ctrl->xbar_update_pending = 0;
+	spin_unlock_irqrestore(&vfe31_ctrl->xbar_lock, flags);
+
+	spin_lock_irqsave(&vfe31_ctrl->stop_flag_lock, flags);
+	vfe31_ctrl->stop_ack_pending  = FALSE;
+	spin_unlock_irqrestore(&vfe31_ctrl->stop_flag_lock, flags);
+	
+	atomic_set(&vfe31_ctrl->vstate, 0);
+
+	vfe31_ctrl->aec_ack_pending = FALSE;
+	vfe31_ctrl->af_ack_pending = FALSE;
+	vfe31_ctrl->awb_ack_pending = FALSE;
+	vfe31_ctrl->ihist_ack_pending = FALSE;
+	vfe31_ctrl->rs_ack_pending = FALSE;
+	vfe31_ctrl->cs_ack_pending = FALSE;
+
+	vfe31_ctrl->reset_ack_pending  = FALSE;
+
+	spin_lock_irqsave(&vfe31_ctrl->update_ack_lock, flags);
+	vfe31_ctrl->update_ack_pending = FALSE;
+	spin_unlock_irqrestore(&vfe31_ctrl->update_ack_lock, flags);
+
+	vfe31_ctrl->recording_state = VFE_REC_STATE_IDLE;
+
+	/* 0 for continuous mode, 1 for snapshot mode */
+	vfe31_ctrl->operation_mode = VFE_MODE_OF_OPERATION_CONTINUOUS;
+	vfe31_ctrl->outpath.output_mode = 0;
+	vfe31_ctrl->vfe_capture_count = 0;
+
+	/* this is unsigned 32 bit integer. */
+	vfe31_ctrl->vfeFrameId = 0;
+
+	vfe31_ctrl->output1Pattern = 0xffffffff;
+	vfe31_ctrl->output1Period  = 31;
+	vfe31_ctrl->output2Pattern = 0xffffffff;
+	vfe31_ctrl->output2Period  = 31;
+	vfe31_ctrl->vfeFrameSkipCount   = 0;
+	vfe31_ctrl->vfeFrameSkipPeriod  = 31;
+
+	/* Stats control variables. */
+	memset(&(vfe31_ctrl->afStatsControl), 0,
+		sizeof(struct vfe_stats_control));
+
+	memset(&(vfe31_ctrl->awbStatsControl), 0,
+		sizeof(struct vfe_stats_control));
+
+	memset(&(vfe31_ctrl->aecStatsControl), 0,
+		sizeof(struct vfe_stats_control));
+
+	memset(&(vfe31_ctrl->ihistStatsControl), 0,
+		sizeof(struct vfe_stats_control));
+
+	memset(&(vfe31_ctrl->rsStatsControl), 0,
+		sizeof(struct vfe_stats_control));
+
+	memset(&(vfe31_ctrl->csStatsControl), 0,
+		sizeof(struct vfe_stats_control));
+}
+
+static void vfe31_reset(void)
+{
+	vfe31_reset_internal_variables();
+	/* disable all interrupts.  vfeImaskLocal is also reset to 0
+	* to begin with. */
+	msm_io_w(VFE_DISABLE_ALL_IRQS,
+		vfe31_ctrl->vfebase + VFE_IRQ_MASK_0);
+
+	msm_io_w(VFE_DISABLE_ALL_IRQS,
+		vfe31_ctrl->vfebase + VFE_IRQ_MASK_1);
+
+	/* clear all pending interrupts*/
+	msm_io_w(VFE_CLEAR_ALL_IRQS, vfe31_ctrl->vfebase + VFE_IRQ_CLEAR_0);
+	msm_io_w(VFE_CLEAR_ALL_IRQS, vfe31_ctrl->vfebase + VFE_IRQ_CLEAR_1);
+
+	/* Ensure the write order while writing
+	to the command register using the barrier */
+	msm_io_w_mb(1, vfe31_ctrl->vfebase + VFE_IRQ_CMD);
+
+	/* enable reset_ack interrupt.  */
+	msm_io_w(VFE_IMASK_RESET,
+		vfe31_ctrl->vfebase + VFE_IRQ_MASK_1);
+
+	/* Write to VFE_GLOBAL_RESET_CMD to reset the vfe hardware. Once reset
+	 * is done, hardware interrupt will be generated.  VFE ist processes
+	 * the interrupt to complete the function call.  Note that the reset
+	 * function is synchronous. */
+
+	/* Ensure the write order while writing
+	to the command register using the barrier */
+	msm_io_w_mb(VFE_RESET_UPON_RESET_CMD,
+		vfe31_ctrl->vfebase + VFE_GLOBAL_RESET);
+
+}
+
+static int vfe31_operation_config(uint32_t *cmd)
+{
+	uint32_t *p = cmd;
+
+	vfe31_ctrl->operation_mode = *p;
+	//vpe_ctrl->pad_2k_bool = (vfe31_ctrl->operation_mode & 1) ? FALSE : TRUE; //old
+
+	vfe31_ctrl->stats_comp = *(++p);
+
+	msm_io_w(*(++p), vfe31_ctrl->vfebase + VFE_CFG_OFF);
+	msm_io_w(*(++p), vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+	msm_io_w(*(++p), vfe31_ctrl->vfebase + VFE_REALIGN_BUF);
+	msm_io_w(*(++p), vfe31_ctrl->vfebase + VFE_CHROMA_UP);
+	msm_io_w(*(++p), vfe31_ctrl->vfebase + VFE_STATS_CFG);
+	wmb();
+	return 0;
+}
+static uint32_t vfe_stats_awb_buf_init(struct vfe_cmd_stats_buf *in)
+{
+	uint32_t *ptr = in->statsBuf;
+	uint32_t addr;
+
+	addr = ptr[0];
+	msm_io_w(addr, vfe31_ctrl->vfebase + VFE_BUS_STATS_AWB_WR_PING_ADDR);
+	addr = ptr[1];
+	msm_io_w(addr, vfe31_ctrl->vfebase + VFE_BUS_STATS_AWB_WR_PONG_ADDR);
+	vfe31_ctrl->awbStatsControl.nextFrameAddrBuf = in->statsBuf[2];
+	return 0;
+}
+
+
+static uint32_t vfe_stats_aec_buf_init(struct vfe_cmd_stats_buf *in)
+{
+	uint32_t *ptr = in->statsBuf;
+	uint32_t addr;
+
+	addr = ptr[0];
+	msm_io_w(addr, vfe31_ctrl->vfebase + VFE_BUS_STATS_AEC_WR_PING_ADDR);
+	addr = ptr[1];
+	msm_io_w(addr, vfe31_ctrl->vfebase + VFE_BUS_STATS_AEC_WR_PONG_ADDR);
+
+	vfe31_ctrl->aecStatsControl.nextFrameAddrBuf = in->statsBuf[2];
+	return 0;
+}
+
+static uint32_t vfe_stats_af_buf_init(struct vfe_cmd_stats_buf *in)
+{
+	uint32_t *ptr = in->statsBuf;
+	uint32_t addr;
+
+	addr = ptr[0];
+	msm_io_w(addr, vfe31_ctrl->vfebase + VFE_BUS_STATS_AF_WR_PING_ADDR);
+	addr = ptr[1];
+	msm_io_w(addr, vfe31_ctrl->vfebase + VFE_BUS_STATS_AF_WR_PONG_ADDR);
+
+	vfe31_ctrl->afStatsControl.nextFrameAddrBuf = in->statsBuf[2];
+	return 0;
+}
+
+static uint32_t vfe_stats_ihist_buf_init(struct vfe_cmd_stats_buf *in)
+{
+	uint32_t *ptr = in->statsBuf;
+	uint32_t addr;
+
+	addr = ptr[0];
+	msm_io_w(addr, vfe31_ctrl->vfebase + VFE_BUS_STATS_HIST_WR_PING_ADDR);
+	addr = ptr[1];
+	msm_io_w(addr, vfe31_ctrl->vfebase + VFE_BUS_STATS_HIST_WR_PONG_ADDR);
+
+	vfe31_ctrl->ihistStatsControl.nextFrameAddrBuf = in->statsBuf[2];
+	return 0;
+}
+
+static uint32_t vfe_stats_rs_buf_init(struct vfe_cmd_stats_buf *in)
+{
+	uint32_t *ptr = in->statsBuf;
+	uint32_t addr;
+
+	addr = ptr[0];
+	msm_io_w(addr, vfe31_ctrl->vfebase + VFE_BUS_STATS_RS_WR_PING_ADDR);
+	addr = ptr[1];
+	msm_io_w(addr, vfe31_ctrl->vfebase + VFE_BUS_STATS_RS_WR_PONG_ADDR);
+
+	vfe31_ctrl->rsStatsControl.nextFrameAddrBuf = in->statsBuf[2];
+	return 0;
+}
+static uint32_t vfe_stats_cs_buf_init(struct vfe_cmd_stats_buf *in)
+{
+	uint32_t *ptr = in->statsBuf;
+	uint32_t addr;
+
+	addr = ptr[0];
+	msm_io_w(addr, vfe31_ctrl->vfebase + VFE_BUS_STATS_CS_WR_PING_ADDR);
+	addr = ptr[1];
+	msm_io_w(addr, vfe31_ctrl->vfebase + VFE_BUS_STATS_CS_WR_PONG_ADDR);
+
+	vfe31_ctrl->csStatsControl.nextFrameAddrBuf = in->statsBuf[2];
+	return 0;
+}
+
+void msm_io_dump2(void __iomem *addr, int size)
+{
+	char line_str[128], *p_str;
+	int i;
+	u32 *p = (u32 *) addr;
+	u32 data;
+	CDBG("%s: %p %d\n", __func__, addr, size);
+	line_str[0] = '\0';
+	p_str = line_str;
+	for (i = 0; i < size/4; i++) {
+		if (i % 4 == 0) {
+			sprintf(p_str, "%08x: ", (u32) p);
+			p_str += 10;
+		}
+		data = readl_relaxed(p++);
+		sprintf(p_str, "%08x ", data);
+		p_str += 9;
+		if ((i + 1) % 4 == 0) {
+			CDBG("%s\n", line_str);
+			line_str[0] = '\0';
+			p_str = line_str;
+		}
+	}
+	if (line_str[0] != '\0')
+		CDBG("%s\n", line_str);
+}
+
+static void vfe31_start_common(void)
+{
+	vfe31_ctrl->start_ack_pending = TRUE;
+	CDBG("VFE opertaion mode = 0x%x, output mode = 0x%x\n",
+		vfe31_ctrl->operation_mode, vfe31_ctrl->outpath.output_mode);
+	if ((VFE_MODE_OF_OPERATION_RAW_SNAPSHOT == vfe31_ctrl->operation_mode)
+		|| (VFE_MODE_OF_OPERATION_SNAPSHOT == vfe31_ctrl->operation_mode)) {
+		msm_io_w(0x00EFE025, vfe31_ctrl->vfebase + VFE_IRQ_MASK_0);
+		msm_io_w(VFE_IMASK_RESET, vfe31_ctrl->vfebase + VFE_IRQ_MASK_1);
+	} else {
+		msm_io_w(0x00EFE021, vfe31_ctrl->vfebase + VFE_IRQ_MASK_0);
+		msm_io_w(VFE_IMASK_RESET, vfe31_ctrl->vfebase + VFE_IRQ_MASK_1);
+	}
+
+	msm_io_dump2(vfe31_ctrl->vfebase, vfe31_ctrl->register_total * 4);
+
+	/* Ensure the write order while writing
+	to the command register using the barrier */
+	msm_io_w_mb(1, vfe31_ctrl->vfebase + VFE_REG_UPDATE_CMD);
+	msm_io_w_mb(1, vfe31_ctrl->vfebase + VFE_CAMIF_COMMAND);
+	wmb();
+
+	atomic_set(&vfe31_ctrl->vstate, 1);
+}
+
+static int vfe31_start_recording(void)
+{
+	msm_camio_set_perf_lvl(S_VIDEO);
+	vfe31_ctrl->recording_state = VFE_REC_STATE_START_REQUESTED;
+	msm_io_w_mb(1, vfe31_ctrl->vfebase + VFE_REG_UPDATE_CMD);
+	return 0;
+}
+
+static int vfe31_stop_recording(void)
+{
+	vfe31_ctrl->recording_state = VFE_REC_STATE_STOP_REQUESTED;
+	msm_io_w_mb(1, vfe31_ctrl->vfebase + VFE_REG_UPDATE_CMD);
+	msm_camio_set_perf_lvl(S_PREVIEW);
+	return 0;
+}
+
+static void vfe31_liveshot(void)
+{
+	struct msm_sync* p_sync = (struct msm_sync *)vfe_syncdata;
+	if (p_sync)
+		p_sync->liveshot_enabled = true;
+}
+
+static int vfe31_zsl(void)
+{
+	uint32_t irq_comp_mask = 0;
+	/* capture command is valid for both idle and active state. */
+	irq_comp_mask	=
+		msm_io_r(vfe31_ctrl->vfebase + VFE_IRQ_COMP_MASK);
+
+	CDBG("%s:op mode %d O/P Mode %d\n", __func__,
+		vfe31_ctrl->operation_mode, vfe31_ctrl->outpath.output_mode);
+	if ((vfe31_ctrl->operation_mode == VFE_MODE_OF_OPERATION_ZSL)) {
+		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_P) {
+			irq_comp_mask |=
+				((0x1 << (vfe31_ctrl->outpath.out0.ch0)) |
+				(0x1 << (vfe31_ctrl->outpath.out0.ch1)));
+		} else if (vfe31_ctrl->outpath.output_mode &
+				VFE31_OUTPUT_MODE_P_ALL_CHNLS) {
+			pr_debug("%s Enabling all channels ", __func__);
+			irq_comp_mask |= (0x1 << vfe31_ctrl->outpath.out0.ch0 |
+				0x1 << vfe31_ctrl->outpath.out0.ch1 |
+				0x1 << vfe31_ctrl->outpath.out0.ch2);
+		}
+		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_T) {
+			irq_comp_mask |=
+				((0x1 << (vfe31_ctrl->outpath.out1.ch0 + 8)) |
+				(0x1 << (vfe31_ctrl->outpath.out1.ch1 + 8)));
+		}
+		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_S) {
+			irq_comp_mask |=
+			((0x1 << (vfe31_ctrl->outpath.out2.ch0 + 8)) |
+			(0x1 << (vfe31_ctrl->outpath.out2.ch1 + 8)));
+		}
+		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_P) {
+			msm_io_w(1, vfe31_ctrl->vfebase +
+				vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out0.ch0]);
+			msm_io_w(1, vfe31_ctrl->vfebase +
+				vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out0.ch1]);
+		} else if (vfe31_ctrl->outpath.output_mode &
+					VFE31_OUTPUT_MODE_P_ALL_CHNLS) {
+			msm_io_w(1, vfe31_ctrl->vfebase +
+				vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out0.ch0]);
+			msm_io_w(1, vfe31_ctrl->vfebase +
+				vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out0.ch1]);
+			msm_io_w(1, vfe31_ctrl->vfebase +
+				vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out0.ch2]);
+		}
+		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_T) {
+			msm_io_w(1, vfe31_ctrl->vfebase +
+				vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out1.ch0]);
+			msm_io_w(1, vfe31_ctrl->vfebase +
+				vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out1.ch1]);
+		}
+		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_S) {
+			msm_io_w(1, vfe31_ctrl->vfebase +
+				vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out2.ch0]);
+			msm_io_w(1, vfe31_ctrl->vfebase +
+				vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out2.ch1]);
+		}
+	}
+	msm_io_w(irq_comp_mask, vfe31_ctrl->vfebase + VFE_IRQ_COMP_MASK);
+	vfe31_start_common();
+	msm_camio_set_perf_lvl(S_ZSL);
+
+	msm_io_w(1, vfe31_ctrl->vfebase + 0x18C);
+	msm_io_w(1, vfe31_ctrl->vfebase + 0x188);
+	return 0;
+}
+
+static int vfe31_capture(uint32_t num_frames_capture)
+{
+	uint32_t irq_comp_mask = 0;
+
+	/* capture command is valid for both idle and active state. */
+	vfe31_ctrl->vfe_capture_count = num_frames_capture;
+
+	vfe31_ctrl->outpath.out1.capture_cnt = num_frames_capture;
+	if (vfe31_ctrl->operation_mode == VFE_MODE_OF_OPERATION_SNAPSHOT) {
+		vfe31_ctrl->outpath.out0.capture_cnt =
+		num_frames_capture;
+	}
+	irq_comp_mask	=
+		msm_io_r(vfe31_ctrl->vfebase + VFE_IRQ_COMP_MASK);
+
+	if ((vfe31_ctrl->operation_mode ==
+		 VFE_MODE_OF_OPERATION_SNAPSHOT) ||
+		(vfe31_ctrl->operation_mode ==
+		 VFE_MODE_OF_OPERATION_ZSL)){
+		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_PT) {
+			irq_comp_mask |=
+				((0x1 << (vfe31_ctrl->outpath.out0.ch0 + 8)) |
+				(0x1 << (vfe31_ctrl->outpath.out0.ch1 + 8)));
+		}
+		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_S) {
+			irq_comp_mask |=
+			((0x1 << (vfe31_ctrl->outpath.out1.ch0 + 8)) |
+			(0x1 << (vfe31_ctrl->outpath.out1.ch1 + 8)));
+		}
+		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_PT) {
+			msm_io_w(1, vfe31_ctrl->vfebase +
+				vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out0.ch0]);
+			msm_io_w(1, vfe31_ctrl->vfebase +
+				vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out0.ch1]);
+		}
+		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_S) {
+			msm_io_w(1, vfe31_ctrl->vfebase +
+				vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out1.ch0]);
+			msm_io_w(1, vfe31_ctrl->vfebase +
+				vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out1.ch1]);
+		}
+	} else {  /* this is raw snapshot mode. */
+		CDBG("config the comp imask for raw snapshot mode. %d\n", vfe31_ctrl->outpath.output_mode);
+		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_S) {
+			irq_comp_mask |=
+			(0x1 << (vfe31_ctrl->outpath.out1.ch0 + 8));
+			msm_io_w_mb(1, vfe31_ctrl->vfebase +
+				vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out1.ch0]);
+		}
+	}
+	msm_io_w(irq_comp_mask, vfe31_ctrl->vfebase + VFE_IRQ_COMP_MASK);
+
+	msm_camio_set_perf_lvl(S_PREVIEW);
+
+	usleep(1000);
+	vfe31_start_common();
+	return 0;
+}
+
+static int vfe31_start(void)
+{
+	uint32_t irq_comp_mask = 0;
+	/* start command now is only good for continuous mode. */
+	if ((vfe31_ctrl->operation_mode != VFE_MODE_OF_OPERATION_CONTINUOUS) &&
+		(vfe31_ctrl->operation_mode != VFE_MODE_OF_OPERATION_VIDEO))
+		return 0;
+	irq_comp_mask	=
+		msm_io_r(vfe31_ctrl->vfebase + VFE_IRQ_COMP_MASK);
+
+	if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_PT) {
+		irq_comp_mask |= (0x1 << vfe31_ctrl->outpath.out0.ch0 |
+			0x1 << vfe31_ctrl->outpath.out0.ch1);
+	}
+
+	if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_V) {
+		irq_comp_mask |= (0x1 << (vfe31_ctrl->outpath.out2.ch0 + 16)|
+			0x1 << (vfe31_ctrl->outpath.out2.ch1 + 16));
+	}
+
+	msm_io_w(irq_comp_mask, vfe31_ctrl->vfebase + VFE_IRQ_COMP_MASK);
+
+
+	if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_PT) {
+		msm_io_w(1, vfe31_ctrl->vfebase +
+			vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out0.ch0]);
+		msm_io_w(1, vfe31_ctrl->vfebase +
+			vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out0.ch1]);
+	}
+	msm_camio_set_perf_lvl(S_PREVIEW);
+
+	usleep(1000);
+	vfe31_start_common();
+	return 0;
+}
+
+static void vfe31_update(void)
+{
+	unsigned long flags;
+	CDBG("vfe31_update\n");
+
+	if (vfe31_ctrl->update_gamma) {
+		if (!msm_io_r(vfe31_ctrl->vfebase + V31_GAMMA_CFG_OFF))
+			msm_io_w(7, vfe31_ctrl->vfebase+V31_GAMMA_CFG_OFF);
+		else
+			msm_io_w(0, vfe31_ctrl->vfebase+V31_GAMMA_CFG_OFF);
+		vfe31_ctrl->update_gamma = false;
+	}
+	if (vfe31_ctrl->update_luma) {
+		if (!msm_io_r(vfe31_ctrl->vfebase + V31_LUMA_CFG_OFF))
+			msm_io_w(1, vfe31_ctrl->vfebase + V31_LUMA_CFG_OFF);
+		else
+			msm_io_w(0, vfe31_ctrl->vfebase + V31_LUMA_CFG_OFF);
+		vfe31_ctrl->update_luma = false;
+	}
+	spin_lock_irqsave(&vfe31_ctrl->update_ack_lock, flags);
+	vfe31_ctrl->update_ack_pending = TRUE;
+	spin_unlock_irqrestore(&vfe31_ctrl->update_ack_lock, flags);
+	/* Ensure the write order while writing
+	to the command register using the barrier */
+	msm_io_w_mb(1, vfe31_ctrl->vfebase + VFE_REG_UPDATE_CMD);
+	return;
+}
+
+static void vfe31_sync_timer_stop(void)
+{
+	uint32_t value = 0;
+	vfe31_ctrl->sync_timer_state = 0;
+	if (vfe31_ctrl->sync_timer_number == 0)
+		value = 0x10000;
+	else if (vfe31_ctrl->sync_timer_number == 1)
+		value = 0x20000;
+	else if (vfe31_ctrl->sync_timer_number == 2)
+		value = 0x40000;
+
+	/* Timer Stop */
+	msm_io_w_mb(value, vfe31_ctrl->vfebase + V31_SYNC_TIMER_OFF);
+}
+
+static void vfe31_sync_timer_start(const uint32_t *tbl)
+{
+	/* set bit 8 for auto increment. */
+	uint32_t value = 1;
+	uint32_t val;
+
+	vfe31_ctrl->sync_timer_state = *tbl++;
+	vfe31_ctrl->sync_timer_repeat_count = *tbl++;
+	vfe31_ctrl->sync_timer_number = *tbl++;
+	CDBG("%s timer_state %d, repeat_cnt %d timer number %d\n",
+		 __func__, vfe31_ctrl->sync_timer_state,
+		 vfe31_ctrl->sync_timer_repeat_count,
+		 vfe31_ctrl->sync_timer_number);
+
+	if (vfe31_ctrl->sync_timer_state) { /* Start Timer */
+		value = value << vfe31_ctrl->sync_timer_number;
+	} else { /* Stop Timer */
+		CDBG("Failed to Start timer\n");
+		return;
+	}
+
+	/* Timer Start */
+	msm_io_w(value, vfe31_ctrl->vfebase + V31_SYNC_TIMER_OFF);
+	/* Sync Timer Line Start */
+	value = *tbl++;
+	msm_io_w(value, vfe31_ctrl->vfebase + V31_SYNC_TIMER_OFF +
+		4 + ((vfe31_ctrl->sync_timer_number) * 12));
+	/* Sync Timer Pixel Start */
+	value = *tbl++;
+	msm_io_w(value, vfe31_ctrl->vfebase + V31_SYNC_TIMER_OFF +
+			 8 + ((vfe31_ctrl->sync_timer_number) * 12));
+	/* Sync Timer Pixel Duration */
+	value = *tbl++;
+	val = vfe_clk_rate / 10000;
+	val = 10000000 / val;
+	val = value * 10000 / val;
+	CDBG("%s: Pixel Clk Cycles!!! %d\n", __func__, val);
+	msm_io_w(val, vfe31_ctrl->vfebase + V31_SYNC_TIMER_OFF +
+		12 + ((vfe31_ctrl->sync_timer_number) * 12));
+	/* Timer0 Active High/LOW */
+	value = *tbl++;
+	msm_io_w(value, vfe31_ctrl->vfebase + V31_SYNC_TIMER_POLARITY_OFF);
+	/* Selects sync timer 0 output to drive onto timer1 port */
+	value = 0;
+	msm_io_w(value, vfe31_ctrl->vfebase + V31_TIMER_SELECT_OFF);
+}
+
+static void vfe31_program_dmi_cfg(enum VFE31_DMI_RAM_SEL bankSel)
+{
+	/* set bit 8 for auto increment. */
+	uint32_t value = VFE_DMI_CFG_DEFAULT;
+	value += (uint32_t)bankSel;
+
+	msm_io_w_mb(value, vfe31_ctrl->vfebase + VFE_DMI_CFG);
+	/* by default, always starts with offset 0.*/
+	msm_io_w(0, vfe31_ctrl->vfebase + VFE_DMI_ADDR);
+	wmb();
+}
+static void vfe31_write_gamma_cfg(enum VFE31_DMI_RAM_SEL channel_sel,
+						const uint32_t *tbl)
+{
+	int i;
+	uint32_t value, value1, value2;
+	vfe31_program_dmi_cfg(channel_sel);
+	/* for loop for extracting init table. */
+	for (i = 0 ; i < (VFE31_GAMMA_NUM_ENTRIES/2) ; i++) {
+		value = *tbl++;
+		value1 = value & 0x0000FFFF;
+		value2 = (value & 0xFFFF0000)>>16;
+		msm_io_w((value1), vfe31_ctrl->vfebase + VFE_DMI_DATA_LO);
+		msm_io_w((value2), vfe31_ctrl->vfebase + VFE_DMI_DATA_LO);
+	}
+	vfe31_program_dmi_cfg(NO_MEM_SELECTED);
+}
+
+static void vfe31_read_gamma_cfg(enum VFE31_DMI_RAM_SEL channel_sel,
+	uint32_t *tbl)
+{
+	int i;
+	vfe31_program_dmi_cfg(channel_sel);
+	CDBG("%s: Gamma table channel: %d\n", __func__, channel_sel);
+	for (i = 0 ; i < VFE31_GAMMA_NUM_ENTRIES ; i++) {
+		*tbl = msm_io_r(vfe31_ctrl->vfebase + VFE_DMI_DATA_LO);
+		CDBG("%s: %08x\n", __func__, *tbl);
+		tbl++;
+	}
+	vfe31_program_dmi_cfg(NO_MEM_SELECTED);
+}
+
+static void vfe31_write_la_cfg(enum VFE31_DMI_RAM_SEL channel_sel,
+						const uint32_t *tbl)
+{
+	uint32_t i;
+	uint32_t value, value1, value2;
+
+	vfe31_program_dmi_cfg(channel_sel);
+	/* for loop for extracting init table. */
+	for (i = 0 ; i < (VFE31_LA_TABLE_LENGTH/2) ; i++) {
+		value = *tbl++;
+		value1 = value & 0x0000FFFF;
+		value2 = (value & 0xFFFF0000)>>16;
+		msm_io_w((value1), vfe31_ctrl->vfebase + VFE_DMI_DATA_LO);
+		msm_io_w((value2), vfe31_ctrl->vfebase + VFE_DMI_DATA_LO);
+	}
+	vfe31_program_dmi_cfg(NO_MEM_SELECTED);
+}
+
+static int vfe31_proc_general(struct msm_isp_cmd *cmd)
+{
+	int i , rc = 0;
+	uint32_t old_val = 0 , new_val = 0;
+	uint32_t *cmdp = NULL;
+	uint32_t *cmdp_local = NULL;
+	uint32_t snapshot_cnt = 0;
+	uint32_t temp1 = 0, temp2 = 0;
+
+	CDBG("vfe31_proc_general: cmdID = %s, length = %d\n",
+		vfe31_general_cmd[cmd->id], cmd->length);
+	switch (cmd->id) {
+	case VFE_CMD_RESET:
+		pr_info("vfe31_proc_general: cmdID = %s\n",
+			vfe31_general_cmd[cmd->id]);
+		vfe31_reset();
+		break;
+	case VFE_CMD_START:
+		pr_info("vfe31_proc_general: cmdID = %s\n",
+			vfe31_general_cmd[cmd->id]);
+		rc = vfe31_configure_pingpong_buffers(VFE_MSG_V31_START,
+							VFE_MSG_OUTPUT_P);
+		if (rc < 0) {
+			pr_err("%s error configuring pingpong buffers"
+				" for preview", __func__);
+			rc = -EINVAL;
+			goto proc_general_done;
+		}
+		rc = vfe31_start();
+		break;
+	case VFE_CMD_UPDATE:
+		vfe31_update();
+		break;
+	case VFE_CMD_CAPTURE:
+		pr_info("vfe31_proc_general: cmdID = %s\n",
+			vfe31_general_cmd[cmd->id]);
+		if (copy_from_user(&snapshot_cnt, (void __user *)(cmd->value),
+				sizeof(uint32_t))) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		rc = vfe31_configure_pingpong_buffers(VFE_MSG_V31_CAPTURE,
+							VFE_MSG_OUTPUT_S);
+		if (rc < 0) {
+			pr_err("%s error configuring pingpong buffers"
+				   " for snapshot", __func__);
+			rc = -EINVAL;
+			goto proc_general_done;
+		}
+		if (vfe31_ctrl->operation_mode !=
+				VFE_MODE_OF_OPERATION_RAW_SNAPSHOT) {
+			rc = vfe31_configure_pingpong_buffers(
+				VFE_MSG_V31_CAPTURE, VFE_MSG_OUTPUT_T);
+			if (rc < 0) {
+				pr_err("%s error configuring pingpong buffers"
+					   " for thumbnail", __func__);
+				rc = -EINVAL;
+				goto proc_general_done;
+			}
+		}
+		rc = vfe31_capture(snapshot_cnt);
+		break;
+	case VFE_CMD_START_RECORDING:
+		pr_info("vfe31_proc_general: cmdID = %s\n",
+			vfe31_general_cmd[cmd->id]);
+		rc = vfe31_configure_pingpong_buffers(
+			VFE_MSG_V31_START_RECORDING, VFE_MSG_OUTPUT_V);
+		if (rc < 0) {
+			pr_err("%s error configuring pingpong buffers"
+				" for video", __func__);
+			rc = -EINVAL;
+			goto proc_general_done;
+		}
+		rc = vfe31_start_recording();
+		break;
+	case VFE_CMD_STOP_RECORDING:
+		pr_info("vfe31_proc_general: cmdID = %s\n",
+			vfe31_general_cmd[cmd->id]);
+		rc = vfe31_stop_recording();
+		break;
+	case VFE_CMD_OPERATION_CFG: {
+		if (cmd->length != V31_OPERATION_CFG_LEN) {
+			rc = -EINVAL;
+			goto proc_general_done;
+		}
+		cmdp = kmalloc(V31_OPERATION_CFG_LEN, GFP_ATOMIC);
+		if (copy_from_user(cmdp,
+			(void __user *)(cmd->value),
+			V31_OPERATION_CFG_LEN)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		rc = vfe31_operation_config(cmdp);
+		}
+		break;
+
+	case VFE_CMD_STATS_AE_START: {
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp,
+			(void __user *)(cmd->value),
+			cmd->length)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		old_val = msm_io_r(vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		old_val |= AE_BG_ENABLE_MASK;
+		msm_io_w(old_val,
+			vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
+		cmdp, (vfe31_cmd[cmd->id].length));
+		}
+		break;
+	case VFE_CMD_STATS_AF_START: {
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp,
+			(void __user *)(cmd->value),
+			cmd->length)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		old_val = msm_io_r(vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		old_val |= AF_BF_ENABLE_MASK;
+		msm_io_w(old_val,
+			vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
+		cmdp, (vfe31_cmd[cmd->id].length));
+		}
+		break;
+	case VFE_CMD_STATS_AWB_START: {
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp,
+			(void __user *)(cmd->value),
+			cmd->length)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		old_val = msm_io_r(vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		old_val |= AWB_ENABLE_MASK;
+		msm_io_w(old_val,
+			vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
+				cmdp, (vfe31_cmd[cmd->id].length));
+		}
+		break;
+
+	case VFE_CMD_STATS_IHIST_START: {
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp,
+			(void __user *)(cmd->value),
+			cmd->length)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		old_val = msm_io_r(vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		old_val |= IHIST_ENABLE_MASK;
+		msm_io_w(old_val,
+			vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
+				cmdp, (vfe31_cmd[cmd->id].length));
+		}
+		break;
+
+
+	case VFE_CMD_STATS_RS_START: {
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp,
+			(void __user *)(cmd->value),
+			cmd->length)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
+				cmdp, (vfe31_cmd[cmd->id].length));
+		}
+		break;
+
+	case VFE_CMD_STATS_CS_START: {
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp,
+			(void __user *)(cmd->value),
+			cmd->length)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
+				cmdp, (vfe31_cmd[cmd->id].length));
+		}
+		break;
+
+	case VFE_CMD_MCE_UPDATE:
+	case VFE_CMD_MCE_CFG:{
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		/* Incrementing with 4 so as to point to the 2nd Register as
+		the 2nd register has the mce_enable bit */
+		old_val = msm_io_r(vfe31_ctrl->vfebase +
+			V31_CHROMA_SUP_OFF + 4);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp,
+			(void __user *)(cmd->value),
+			cmd->length)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		cmdp_local = cmdp;
+		new_val = *cmdp_local;
+		old_val &= MCE_EN_MASK;
+		new_val = new_val | old_val;
+		msm_io_memcpy(vfe31_ctrl->vfebase + V31_CHROMA_SUP_OFF + 4,
+			&new_val, 4);
+		cmdp_local += 1;
+
+		old_val = msm_io_r(vfe31_ctrl->vfebase +
+			V31_CHROMA_SUP_OFF + 8);
+		new_val = *cmdp_local;
+		old_val &= MCE_Q_K_MASK;
+		new_val = new_val | old_val;
+		msm_io_memcpy(vfe31_ctrl->vfebase + V31_CHROMA_SUP_OFF + 8,
+		&new_val, 4);
+		cmdp_local += 1;
+		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
+		cmdp_local, (vfe31_cmd[cmd->id].length));
+		}
+		break;
+
+	case VFE_CMD_MESH_ROLL_OFF_CFG: {
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp,
+			(void __user *)(cmd->value) , cmd->length)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		cmdp_local = cmdp;
+		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
+		cmdp_local, 16);
+		cmdp_local += 4;
+		vfe31_program_dmi_cfg(ROLLOFF_RAM);
+		/* for loop for extrcting init table. */
+		for (i = 0; i < (V31_MESH_ROLL_OFF_INIT_TABLE_SIZE * 2); i++) {
+			msm_io_w(*cmdp_local ,
+			vfe31_ctrl->vfebase + VFE_DMI_DATA_LO);
+			cmdp_local++;
+		}
+		CDBG("done writing init table\n");
+		/* by default, always starts with offset 0. */
+		msm_io_w(V31_MESH_ROLL_OFF_DELTA_TABLE_OFFSET,
+		vfe31_ctrl->vfebase + VFE_DMI_ADDR);
+		/* for loop for extracting delta table. */
+		for (i = 0; i < (V31_MESH_ROLL_OFF_DELTA_TABLE_SIZE * 2); i++) {
+			msm_io_w(*cmdp_local,
+			vfe31_ctrl->vfebase + VFE_DMI_DATA_LO);
+			cmdp_local++;
+		}
+		vfe31_program_dmi_cfg(NO_MEM_SELECTED);
+		}
+		break;
+
+	case VFE_CMD_GET_MESH_ROLLOFF_TABLE:
+		temp1 = sizeof(uint32_t) * ((V31_MESH_ROLL_OFF_INIT_TABLE_SIZE *
+			2) + (V31_MESH_ROLL_OFF_DELTA_TABLE_SIZE * 2));
+		if (cmd->length != temp1) {
+			rc = -EINVAL;
+			goto proc_general_done;
+		}
+		cmdp = kzalloc(temp1, GFP_KERNEL);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		cmdp_local = cmdp;
+		vfe31_program_dmi_cfg(ROLLOFF_RAM);
+		CDBG("%s: Mesh Rolloff init Table\n", __func__);
+		for (i = 0; i < (V31_MESH_ROLL_OFF_INIT_TABLE_SIZE * 2); i++) {
+			*cmdp_local =
+				msm_io_r(vfe31_ctrl->vfebase + VFE_DMI_DATA_LO);
+			CDBG("%s: %08x\n", __func__, *cmdp_local);
+			cmdp_local++;
+		}
+		msm_io_w(V31_MESH_ROLL_OFF_DELTA_TABLE_OFFSET,
+			vfe31_ctrl->vfebase + VFE_DMI_ADDR);
+		CDBG("%s: Mesh Rolloff Delta Table\n", __func__);
+		for (i = 0; i < (V31_MESH_ROLL_OFF_DELTA_TABLE_SIZE * 2); i++) {
+			*cmdp_local =
+				msm_io_r(vfe31_ctrl->vfebase + VFE_DMI_DATA_LO);
+			CDBG("%s: %08x\n", __func__, *cmdp_local);
+			cmdp_local++;
+		}
+		CDBG("done reading delta table\n");
+		vfe31_program_dmi_cfg(NO_MEM_SELECTED);
+		if (copy_to_user((void __user *)(cmd->value), cmdp,
+			temp1)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		break;
+	case VFE_CMD_LA_CFG:
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp,
+			(void __user *)(cmd->value),
+			cmd->length)) {
+
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		cmdp_local = cmdp;
+		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
+			cmdp_local, (vfe31_cmd[cmd->id].length));
+
+		cmdp_local += 1;
+		vfe31_write_la_cfg(LUMA_ADAPT_LUT_RAM_BANK0, cmdp_local);
+		break;
+
+	case VFE_CMD_LA_UPDATE: {
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp,
+			(void __user *)(cmd->value),
+			cmd->length)) {
+
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+
+		cmdp_local = cmdp + 1;
+		old_val = msm_io_r(vfe31_ctrl->vfebase + V31_LA_OFF);
+		if (old_val != 0x0)
+			vfe31_write_la_cfg(LUMA_ADAPT_LUT_RAM_BANK0,
+				cmdp_local);
+		else
+			vfe31_write_la_cfg(LUMA_ADAPT_LUT_RAM_BANK1,
+				cmdp_local);
+		}
+		vfe31_ctrl->update_la = true;
+		break;
+
+	case VFE_CMD_GET_LA_TABLE:
+		temp1 = sizeof(uint32_t) * VFE31_LA_TABLE_LENGTH / 2;
+		if (cmd->length != temp1) {
+			rc = -EINVAL;
+			goto proc_general_done;
+		}
+		cmdp = kzalloc(temp1, GFP_KERNEL);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		cmdp_local = cmdp;
+		if (msm_io_r(vfe31_ctrl->vfebase + V31_LA_OFF))
+			vfe31_program_dmi_cfg(LUMA_ADAPT_LUT_RAM_BANK1);
+		else
+			vfe31_program_dmi_cfg(LUMA_ADAPT_LUT_RAM_BANK0);
+		for (i = 0 ; i < (VFE31_LA_TABLE_LENGTH / 2) ; i++) {
+			*cmdp_local =
+				msm_io_r(vfe31_ctrl->vfebase + VFE_DMI_DATA_LO);
+			*cmdp_local |= (msm_io_r(vfe31_ctrl->vfebase +
+				VFE_DMI_DATA_LO)) << 16;
+			cmdp_local++;
+		}
+		vfe31_program_dmi_cfg(NO_MEM_SELECTED);
+		if (copy_to_user((void __user *)(cmd->value), cmdp,
+			temp1)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		break;
+	case VFE_CMD_SK_ENHAN_CFG:
+	case VFE_CMD_SK_ENHAN_UPDATE:{
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp,
+			(void __user *)(cmd->value),
+			cmd->length)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		msm_io_memcpy(vfe31_ctrl->vfebase + V31_SCE_OFF,
+				cmdp, V31_SCE_LEN);
+		}
+		break;
+
+	case VFE_CMD_LIVESHOT:
+		vfe31_liveshot();
+		break;
+		
+	case VFE_CMD_DEMOSAICV3:
+	case VFE_CMD_DEMOSAICV3_UPDATE:
+		if (cmd->length != V31_DEMOSAICV3_LEN) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp,
+			(void __user *)(cmd->value),
+			cmd->length)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		cmdp_local = cmdp;
+		new_val = *cmdp_local;
+
+		old_val = msm_io_r(vfe31_ctrl->vfebase + V31_DEMOSAICV3_OFF);
+		old_val &= DEMOSAIC_MASK;
+		new_val = new_val | old_val;
+		*cmdp_local = new_val;
+
+		msm_io_memcpy(vfe31_ctrl->vfebase + V31_DEMOSAICV3_OFF,
+			cmdp_local, V31_DEMOSAICV3_LEN);
+		break;
+
+	case VFE_CMD_DEMOSAICV3_ABCC_CFG:
+		rc = -EFAULT;
+		break;
+
+	case VFE_CMD_DEMOSAICV3_ABF_UPDATE:/* 116 ABF update  */
+	case VFE_CMD_DEMOSAICV3_ABF_CFG: { /* 108 ABF config  */
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp,
+			(void __user *)(cmd->value),
+			cmd->length)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		cmdp_local = cmdp;
+		new_val = *cmdp_local;
+
+		old_val = msm_io_r(vfe31_ctrl->vfebase + V31_DEMOSAICV3_OFF);
+		old_val &= ABF_MASK;
+		new_val = new_val | old_val;
+		*cmdp_local = new_val;
+
+		msm_io_memcpy(vfe31_ctrl->vfebase + V31_DEMOSAICV3_OFF,
+		    cmdp_local, 4);
+
+		cmdp_local += 1;
+		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
+			cmdp_local, (vfe31_cmd[cmd->id].length));
+		}
+		break;
+
+	case VFE_CMD_DEMOSAICV3_DBCC_CFG:
+	case VFE_CMD_DEMOSAICV3_DBCC_UPDATE:
+		return -EINVAL;
+
+	case VFE_CMD_DEMOSAICV3_DBPC_CFG:
+	case VFE_CMD_DEMOSAICV3_DBPC_UPDATE: {
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp,
+			(void __user *)(cmd->value),
+			cmd->length)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		cmdp_local = cmdp;
+		new_val = *cmdp_local;
+
+		old_val = msm_io_r(vfe31_ctrl->vfebase + V31_DEMOSAICV3_OFF);
+		old_val &= BPC_MASK;
+
+		new_val = new_val | old_val;
+		*cmdp_local = new_val;
+		msm_io_memcpy(vfe31_ctrl->vfebase + V31_DEMOSAICV3_OFF,
+					cmdp_local, 4);
+		cmdp_local += 1;
+		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
+			cmdp_local, (vfe31_cmd[cmd->id].length));
+		}
+		break;
+
+	case VFE_CMD_RGB_G_CFG: {
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp,
+			(void __user *)(cmd->value),
+			cmd->length)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		msm_io_memcpy(vfe31_ctrl->vfebase + V31_RGB_G_OFF,
+			cmdp, 4);
+		cmdp += 1;
+
+		vfe31_write_gamma_cfg(RGBLUT_RAM_CH0_BANK0, cmdp);
+		vfe31_write_gamma_cfg(RGBLUT_RAM_CH1_BANK0, cmdp);
+		vfe31_write_gamma_cfg(RGBLUT_RAM_CH2_BANK0, cmdp);
+		}
+	    cmdp -= 1;
+		break;
+
+	case VFE_CMD_RGB_G_UPDATE: {
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp, (void __user *)(cmd->value),
+			cmd->length)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+
+		old_val = msm_io_r(vfe31_ctrl->vfebase + V31_RGB_G_OFF);
+		cmdp += 1;
+		if (old_val != 0x0) {
+			vfe31_write_gamma_cfg(RGBLUT_RAM_CH0_BANK0, cmdp);
+			vfe31_write_gamma_cfg(RGBLUT_RAM_CH1_BANK0, cmdp);
+			vfe31_write_gamma_cfg(RGBLUT_RAM_CH2_BANK0, cmdp);
+		} else {
+			vfe31_write_gamma_cfg(RGBLUT_RAM_CH0_BANK1, cmdp);
+			vfe31_write_gamma_cfg(RGBLUT_RAM_CH1_BANK1, cmdp);
+			vfe31_write_gamma_cfg(RGBLUT_RAM_CH2_BANK1, cmdp);
+		}
+		}
+		vfe31_ctrl->update_gamma = TRUE;
+		cmdp -= 1;
+		break;
+
+	case VFE_CMD_GET_RGB_G_TABLE:
+		temp1 = sizeof(uint32_t) * VFE31_GAMMA_NUM_ENTRIES * 3;
+		if (cmd->length != temp1) {
+			rc = -EINVAL;
+			goto proc_general_done;
+		}
+		cmdp = kzalloc(temp1, GFP_KERNEL);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		cmdp_local = cmdp;
+
+		old_val = msm_io_r(vfe31_ctrl->vfebase + V31_RGB_G_OFF);
+		temp2 = old_val ? RGBLUT_RAM_CH0_BANK1 :
+			RGBLUT_RAM_CH0_BANK0;
+		for (i = 0; i < 3; i++) {
+			vfe31_read_gamma_cfg(temp2,
+				cmdp_local + (VFE31_GAMMA_NUM_ENTRIES * i));
+			temp2 += 2;
+		}
+		if (copy_to_user((void __user *)(cmd->value), cmdp,
+			temp1)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		break;
+
+	case VFE_CMD_STATS_AWB_STOP: {
+		old_val = msm_io_r(vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		old_val &= ~AWB_ENABLE_MASK;
+		msm_io_w(old_val,
+			vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		}
+		break;
+	case VFE_CMD_STATS_AE_STOP: {
+		old_val = msm_io_r(vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		old_val &= ~AE_BG_ENABLE_MASK;
+		msm_io_w(old_val,
+			vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		}
+		break;
+	case VFE_CMD_STATS_AF_STOP: {
+		old_val = msm_io_r(vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		old_val &= ~AF_BF_ENABLE_MASK;
+		msm_io_w(old_val,
+			vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		}
+		break;
+
+	case VFE_CMD_STATS_IHIST_STOP: {
+		old_val = msm_io_r(vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		old_val &= ~IHIST_ENABLE_MASK;
+		msm_io_w(old_val,
+			vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		}
+		break;
+
+	case VFE_CMD_STATS_RS_STOP: {
+		old_val = msm_io_r(vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		old_val &= ~RS_ENABLE_MASK;
+		msm_io_w(old_val,
+			vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		}
+		break;
+
+	case VFE_CMD_STATS_CS_STOP: {
+		old_val = msm_io_r(vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		old_val &= ~CS_ENABLE_MASK;
+		msm_io_w(old_val,
+			vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		}
+		break;
+	case VFE_CMD_STOP:
+		pr_info("vfe31_proc_general: cmdID = %s\n",
+			vfe31_general_cmd[cmd->id]);
+		vfe31_stop();
+		break;
+
+	case VFE_CMD_SYNC_TIMER_SETTING:
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp, (void __user *)(cmd->value),
+			cmd->length)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		vfe31_sync_timer_start(cmdp);
+		break;
+
+	case VFE_CMD_MODULE_CFG: {
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp,
+			(void __user *)(cmd->value),
+			cmd->length)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		*cmdp &= ~STATS_ENABLE_MASK;
+		old_val = msm_io_r(vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		old_val &= STATS_ENABLE_MASK;
+		*cmdp |= old_val;
+
+		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
+			cmdp, (vfe31_cmd[cmd->id].length));
+		}
+		break;
+
+	case VFE_CMD_ZSL:
+		rc = vfe31_configure_pingpong_buffers(VFE_MSG_V31_START,
+							VFE_MSG_OUTPUT_P);
+		if (rc < 0)
+			goto proc_general_done;
+		rc = vfe31_configure_pingpong_buffers(VFE_MSG_V31_START,
+							VFE_MSG_OUTPUT_T);
+		if (rc < 0)
+			goto proc_general_done;
+		rc = vfe31_configure_pingpong_buffers(VFE_MSG_V31_START,
+							VFE_MSG_OUTPUT_S);
+		if (rc < 0)
+			goto proc_general_done;
+
+		rc = vfe31_zsl();
+		break;
+
+	case VFE_CMD_ASF_CFG:
+	case VFE_CMD_ASF_UPDATE:
+		cmdp = kmalloc(cmd->length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		if (copy_from_user(cmdp, (void __user *)(cmd->value),
+			cmd->length)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
+			cmdp, (vfe31_cmd[cmd->id].length));
+		cmdp_local = cmdp + V31_ASF_LEN/4;
+		//TODO: ASF_SPECIAL_EFX_CFG not supported?
+		/*msm_io_memcpy(vfe31_ctrl->vfebase + V31_ASF_SPECIAL_EFX_CFG_OFF,
+			cmdp_local, V31_ASF_SPECIAL_EFX_CFG_LEN);*/
+		break;
+
+	case VFE_CMD_GET_HW_VERSION:
+		if (cmd->length != V31_GET_HW_VERSION_LEN) {
+			rc = -EINVAL;
+			goto proc_general_done;
+		}
+		cmdp = kmalloc(V31_GET_HW_VERSION_LEN, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		*cmdp = msm_io_r(vfe31_ctrl->vfebase+V31_GET_HW_VERSION_OFF);
+		if (copy_to_user((void __user *)(cmd->value), cmdp,
+			V31_GET_HW_VERSION_LEN)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		break;
+	case VFE_CMD_GET_REG_DUMP:
+		temp1 = sizeof(uint32_t) * vfe31_ctrl->register_total;
+		if (cmd->length != temp1) {
+			rc = -EINVAL;
+			goto proc_general_done;
+		}
+		cmdp = kmalloc(temp1, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+		msm_io_dump(vfe31_ctrl->vfebase, vfe31_ctrl->register_total*4);
+		CDBG("%s: %p %p %d\n", __func__, (void *)cmdp,
+			vfe31_ctrl->vfebase, temp1);
+		memcpy_fromio((void *)cmdp, vfe31_ctrl->vfebase, temp1);
+		if (copy_to_user((void __user *)(cmd->value), cmdp, temp1)) {
+			rc = -EFAULT;
+			goto proc_general_done;
+		}
+		break;
+	default:
+		if (cmd->length != vfe31_cmd[cmd->id].length)
+			return -EINVAL;
+
+		cmdp = kmalloc(vfe31_cmd[cmd->id].length, GFP_ATOMIC);
+		if (!cmdp) {
+			rc = -ENOMEM;
+			goto proc_general_done;
+		}
+
+		CHECKED_COPY_FROM_USER(cmdp);
+		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
+			cmdp, (vfe31_cmd[cmd->id].length));
+		break;
+
+	}
+
+proc_general_done:
+	kfree(cmdp);
+
+	return rc;
+}
+
+static void vfe31_stats_af_ack(struct vfe_cmd_stats_ack *pAck)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&vfe31_ctrl->af_ack_lock, flags);
+	vfe31_ctrl->afStatsControl.nextFrameAddrBuf = pAck->nextStatsBuf;
+	vfe31_ctrl->afStatsControl.ackPending = FALSE;
+	spin_unlock_irqrestore(&vfe31_ctrl->af_ack_lock, flags);
+}
+
+static void vfe31_stats_awb_ack(struct vfe_cmd_stats_ack *pAck)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&vfe31_ctrl->awb_ack_lock, flags);
+	vfe31_ctrl->awbStatsControl.nextFrameAddrBuf = pAck->nextStatsBuf;
+	vfe31_ctrl->awbStatsControl.ackPending = FALSE;
+	spin_unlock_irqrestore(&vfe31_ctrl->awb_ack_lock, flags);
+}
+
+static void vfe31_stats_aec_ack(struct vfe_cmd_stats_ack *pAck)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&vfe31_ctrl->aec_ack_lock, flags);
+	vfe31_ctrl->aecStatsControl.nextFrameAddrBuf = pAck->nextStatsBuf;
+	vfe31_ctrl->aecStatsControl.ackPending = FALSE;
+	spin_unlock_irqrestore(&vfe31_ctrl->aec_ack_lock, flags);
+}
+
+static void vfe31_stats_ihist_ack(struct vfe_cmd_stats_ack *pAck)
+{
+	vfe31_ctrl->ihistStatsControl.nextFrameAddrBuf = pAck->nextStatsBuf;
+	vfe31_ctrl->ihist_ack_pending = FALSE;
+}
+
+static void vfe31_stats_rs_ack(struct vfe_cmd_stats_ack *pAck)
+{
+	vfe31_ctrl->rsStatsControl.nextFrameAddrBuf = pAck->nextStatsBuf;
+	vfe31_ctrl->rs_ack_pending = FALSE;
+}
+
+static void vfe31_stats_cs_ack(struct vfe_cmd_stats_ack *pAck)
+{
+	vfe31_ctrl->csStatsControl.nextFrameAddrBuf = pAck->nextStatsBuf;
+	vfe31_ctrl->cs_ack_pending = FALSE;
+}
+
+static void vfe31_send_isp_msg(
+	struct vfe31_ctrl_type *vctrl,
+	uint32_t isp_msg_id)
+{
+	struct isp_msg_event isp_msg_evt;
+
+	isp_msg_evt.msg_id = isp_msg_id;
+	isp_msg_evt.sof_count = vfe31_ctrl->vfeFrameId;
+	v4l2_subdev_notify(&vctrl->subdev,
+			NOTIFY_ISP_MSG_EVT,
+			(void *)&isp_msg_evt);
+}
+
+static void vfe31_process_reg_update_irq(void)
+{
+	uint32_t  old_val;
+	unsigned long flags;
+
+	if ((vfe31_ctrl->operation_mode ==
+		VFE_MODE_OF_OPERATION_SNAPSHOT)) {
+		pr_err("%s: snap", __func__);
+	}
+	if (vfe31_ctrl->recording_state == VFE_REC_STATE_START_REQUESTED) {
+		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_V) {
+			msm_io_w(1, vfe31_ctrl->vfebase +
+				vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out2.ch0]);
+			msm_io_w(1, vfe31_ctrl->vfebase +
+				vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out2.ch1]);
+		}
+		vfe31_ctrl->recording_state = VFE_REC_STATE_STARTED;
+		msm_io_w_mb(1, vfe31_ctrl->vfebase + VFE_REG_UPDATE_CMD);
+		CDBG("start video triggered .\n");
+	} else if (vfe31_ctrl->recording_state ==
+			VFE_REC_STATE_STOP_REQUESTED) {
+		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_V) {
+			msm_io_w_mb(0, vfe31_ctrl->vfebase +
+				vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out2.ch0]);
+			msm_io_w_mb(0, vfe31_ctrl->vfebase +
+				vfe31_AXI_WM_CFG[vfe31_ctrl->outpath.out2.ch1]);
+		}
+
+		/*disable rs& cs when stop recording. */
+		old_val = msm_io_r(vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+		old_val &= (~RS_CS_ENABLE_MASK);
+		msm_io_w(old_val, vfe31_ctrl->vfebase + VFE_MODULE_CFG);
+
+		CDBG("stop video triggered .\n");
+	}
+	if (vfe31_ctrl->start_ack_pending == TRUE) {
+		vfe31_send_isp_msg(vfe31_ctrl, MSG_ID_START_ACK);
+		vfe31_ctrl->start_ack_pending = FALSE;
+	} else {
+		if (vfe31_ctrl->recording_state ==
+			VFE_REC_STATE_STOP_REQUESTED) {
+			vfe31_ctrl->recording_state = VFE_REC_STATE_STOPPED;
+			/* request a reg update and send STOP_REC_ACK
+			 * when we process the next reg update irq.
+			 */
+			msm_io_w_mb(1,
+			vfe31_ctrl->vfebase + VFE_REG_UPDATE_CMD);
+		} else if (vfe31_ctrl->recording_state ==
+			VFE_REC_STATE_STOPPED) {
+			vfe31_send_isp_msg(vfe31_ctrl, MSG_ID_STOP_REC_ACK);
+			vfe31_ctrl->recording_state = VFE_REC_STATE_IDLE;
+		}
+		spin_lock_irqsave(&vfe31_ctrl->update_ack_lock, flags);
+		if (vfe31_ctrl->update_ack_pending == TRUE) {
+			vfe31_ctrl->update_ack_pending = FALSE;
+			spin_unlock_irqrestore(
+				&vfe31_ctrl->update_ack_lock, flags);
+			vfe31_send_isp_msg(vfe31_ctrl, MSG_ID_UPDATE_ACK);
+		} else {
+			spin_unlock_irqrestore(
+				&vfe31_ctrl->update_ack_lock, flags);
+		}
+	}
+
+	if (vfe31_ctrl->operation_mode ==
+		VFE_MODE_OF_OPERATION_SNAPSHOT) {  /* in snapshot mode */
+		/* later we need to add check for live snapshot mode. */
+		vfe31_ctrl->vfe_capture_count--;
+		/* if last frame to be captured: */
+		if (vfe31_ctrl->vfe_capture_count == 0) {
+			/* stop the bus output:  write master enable = 0*/
+			if (vfe31_ctrl->outpath.output_mode &
+					VFE31_OUTPUT_MODE_PT) {
+				msm_io_w(0, vfe31_ctrl->vfebase +
+					vfe31_AXI_WM_CFG[vfe31_ctrl->
+						outpath.out0.ch0]);
+				msm_io_w(0, vfe31_ctrl->vfebase +
+					vfe31_AXI_WM_CFG[vfe31_ctrl->
+						outpath.out0.ch1]);
+			}
+			if (vfe31_ctrl->outpath.output_mode &
+					VFE31_OUTPUT_MODE_S) {
+				msm_io_w(0, vfe31_ctrl->vfebase +
+					vfe31_AXI_WM_CFG[vfe31_ctrl->
+							outpath.out1.ch0]);
+				msm_io_w(0, vfe31_ctrl->vfebase +
+					vfe31_AXI_WM_CFG[vfe31_ctrl->
+							outpath.out1.ch1]);
+			}
+			msm_io_w_mb(CAMIF_COMMAND_STOP_AT_FRAME_BOUNDARY,
+				vfe31_ctrl->vfebase + VFE_CAMIF_COMMAND);
+
+			/* then do reg_update. */
+			msm_io_w(1, vfe31_ctrl->vfebase + VFE_REG_UPDATE_CMD);
+		}
+	} /* if snapshot mode. */
+}
+
+static void vfe31_set_default_reg_values(void)
+{
+	msm_io_w(0x800080, vfe31_ctrl->vfebase + VFE_DEMUX_GAIN_0);
+	msm_io_w(0x800080, vfe31_ctrl->vfebase + VFE_DEMUX_GAIN_1);
+	msm_io_w(0xFFFFF, vfe31_ctrl->vfebase + VFE_CGC_OVERRIDE);
+
+	/* default frame drop period and pattern */
+	msm_io_w(0x1f, vfe31_ctrl->vfebase + VFE_FRAMEDROP_ENC_Y_CFG);
+	msm_io_w(0x1f, vfe31_ctrl->vfebase + VFE_FRAMEDROP_ENC_CBCR_CFG);
+	msm_io_w(0xFFFFFFFF, vfe31_ctrl->vfebase + VFE_FRAMEDROP_ENC_Y_PATTERN);
+	msm_io_w(0xFFFFFFFF,
+		vfe31_ctrl->vfebase + VFE_FRAMEDROP_ENC_CBCR_PATTERN);
+	msm_io_w(0x1f, vfe31_ctrl->vfebase + VFE_FRAMEDROP_VIEW_Y);
+	msm_io_w(0x1f, vfe31_ctrl->vfebase + VFE_FRAMEDROP_VIEW_CBCR);
+	msm_io_w(0xFFFFFFFF,
+		vfe31_ctrl->vfebase + VFE_FRAMEDROP_VIEW_Y_PATTERN);
+	msm_io_w(0xFFFFFFFF,
+		vfe31_ctrl->vfebase + VFE_FRAMEDROP_VIEW_CBCR_PATTERN);
+	msm_io_w(0, vfe31_ctrl->vfebase + VFE_CLAMP_MIN);
+	msm_io_w(0xFFFFFF, vfe31_ctrl->vfebase + VFE_CLAMP_MAX);
+
+	/* stats UB config */
+	msm_io_w(0x3980007, vfe31_ctrl->vfebase + VFE_BUS_STATS_AEC_UB_CFG);
+	msm_io_w(0x3A00007, vfe31_ctrl->vfebase + VFE_BUS_STATS_AF_UB_CFG);
+	msm_io_w(0x3A8000F, vfe31_ctrl->vfebase + VFE_BUS_STATS_AWB_UB_CFG);
+	msm_io_w(0x3B80007, vfe31_ctrl->vfebase + VFE_BUS_STATS_RS_UB_CFG);
+	msm_io_w(0x3C0001F, vfe31_ctrl->vfebase + VFE_BUS_STATS_CS_UB_CFG);
+	msm_io_w(0x3E0001F, vfe31_ctrl->vfebase + VFE_BUS_STATS_HIST_UB_CFG);
+}
+
+static void vfe31_process_reset_irq(void)
+{
+	unsigned long flags;
+
+	atomic_set(&vfe31_ctrl->vstate, 0);
+	vfe31_ctrl->while_stopping_mask = VFE_IMASK_WHILE_STOPPING_1;
+
+	pr_err("%s: stop_ack %d", __func__, vfe31_ctrl->stop_ack_pending);
+	spin_lock_irqsave(&vfe31_ctrl->stop_flag_lock, flags);
+	if (vfe31_ctrl->stop_ack_pending) {
+		vfe31_ctrl->stop_ack_pending = FALSE;
+		spin_unlock_irqrestore(&vfe31_ctrl->stop_flag_lock, flags);
+		vfe31_send_isp_msg(vfe31_ctrl, MSG_ID_STOP_ACK);
+	} else {
+		spin_unlock_irqrestore(&vfe31_ctrl->stop_flag_lock, flags);
+		/* this is from reset command. */
+		vfe31_set_default_reg_values();
+
+		/* reload all write masters. (frame & line)*/
+		msm_io_w(0x7FFF, vfe31_ctrl->vfebase + VFE_BUS_CMD);
+		vfe31_send_isp_msg(vfe31_ctrl, MSG_ID_RESET_ACK);
+	}
+}
+
+
+static void vfe31_process_axi_halt_irq(void)
+{
+	/* Ensure the write order while writing
+	to the command register using the barrier */
+	msm_io_w_mb(AXI_HALT_CLEAR,
+		vfe31_ctrl->vfebase + VFE_AXI_CMD);
+	vfe31_ctrl->while_stopping_mask = VFE_IMASK_RESET;
+
+	/* disable all interrupts.  */
+	msm_io_w(VFE_DISABLE_ALL_IRQS,
+		vfe31_ctrl->vfebase + VFE_IRQ_MASK_0);
+	msm_io_w(VFE_DISABLE_ALL_IRQS,
+		vfe31_ctrl->vfebase + VFE_IRQ_MASK_1);
+
+	/* clear all pending interrupts*/
+	msm_io_w(VFE_CLEAR_ALL_IRQS,
+		vfe31_ctrl->vfebase + VFE_IRQ_CLEAR_0);
+	msm_io_w(VFE_CLEAR_ALL_IRQS,
+		vfe31_ctrl->vfebase + VFE_IRQ_CLEAR_1);
+	/* Ensure the write order while writing
+	to the command register using the barrier */
+	msm_io_w_mb(1,
+		vfe31_ctrl->vfebase + VFE_IRQ_CMD);
+
+	/* now enable only halt_irq & reset_irq */
+	msm_io_w(0xf0000000,          /* this is for async timer. */
+		vfe31_ctrl->vfebase + VFE_IRQ_MASK_0);
+	msm_io_w(VFE_IMASK_RESET,
+		vfe31_ctrl->vfebase + VFE_IRQ_MASK_1);
+
+	/* Ensure the write order while writing
+	to the command register using the barrier */
+	CDBG("%s: about to reset vfe...\n", __func__);
+	msm_io_w_mb(VFE_RESET_UPON_STOP_CMD,
+		vfe31_ctrl->vfebase + VFE_GLOBAL_RESET);
+
+}
+
+static void vfe31_process_camif_sof_irq(void)
+{
+	/* in raw snapshot mode */
+	if ((vfe31_ctrl->operation_mode ==
+		VFE_MODE_OF_OPERATION_RAW_SNAPSHOT)) {
+		if (vfe31_ctrl->start_ack_pending) {
+			vfe31_send_isp_msg(vfe31_ctrl, MSG_ID_START_ACK);
+			vfe31_ctrl->start_ack_pending = FALSE;
+		}
+		pr_err("%s: count %d", __func__, vfe31_ctrl->vfe_capture_count);
+		vfe31_ctrl->vfe_capture_count--;
+		/* if last frame to be captured: */
+		if (vfe31_ctrl->vfe_capture_count == 0) {
+			/* Ensure the write order while writing
+			 to the command register using the barrier */
+			msm_io_w_mb(CAMIF_COMMAND_STOP_AT_FRAME_BOUNDARY,
+				vfe31_ctrl->vfebase + VFE_CAMIF_COMMAND);
+		}
+	} /* if raw snapshot mode. */
+
+	vfe31_send_isp_msg(vfe31_ctrl, MSG_ID_SOF_ACK);
+	vfe31_ctrl->vfeFrameId++;
+	CDBG("camif_sof_irq, frameId = %d\n", vfe31_ctrl->vfeFrameId);
+
+	if (vfe31_ctrl->sync_timer_state) {
+		if (vfe31_ctrl->sync_timer_repeat_count == 0)
+			vfe31_sync_timer_stop();
+		else
+			vfe31_ctrl->sync_timer_repeat_count--;
+	}
+}
+
+static void vfe31_process_error_irq(uint32_t errStatus)
+{
+	uint32_t camifStatus, read_val;
+	uint32_t *temp;
+
+	if (errStatus & VFE31_IMASK_CAMIF_ERROR) {
+		pr_err("vfe31_irq: camif errors\n");
+		temp = (uint32_t *)(vfe31_ctrl->vfebase + VFE_CAMIF_STATUS);
+		camifStatus = msm_io_r(temp);
+		pr_err("camifStatus  = 0x%x\n", camifStatus);
+		vfe31_send_isp_msg(vfe31_ctrl, MSG_ID_CAMIF_ERROR);
+	}
+
+	if (errStatus & VFE31_IMASK_STATS_CS_OVWR)
+		pr_err("vfe31_irq: stats cs overwrite\n");
+
+	if (errStatus & VFE31_IMASK_STATS_IHIST_OVWR)
+		pr_err("vfe31_irq: stats ihist overwrite\n");
+
+	if (errStatus & VFE31_IMASK_REALIGN_BUF_Y_OVFL)
+		pr_err("vfe31_irq: realign bug Y overflow\n");
+
+	if (errStatus & VFE31_IMASK_REALIGN_BUF_CB_OVFL)
+		pr_err("vfe31_irq: realign bug CB overflow\n");
+
+	if (errStatus & VFE31_IMASK_REALIGN_BUF_CR_OVFL)
+		pr_err("vfe31_irq: realign bug CR overflow\n");
+
+	if (errStatus & VFE31_IMASK_VIOLATION)
+		pr_err("vfe31_irq: violation interrupt\n");
+
+	if (errStatus & VFE31_IMASK_IMG_MAST_0_BUS_OVFL)
+		pr_err("vfe31_irq: image master 0 bus overflow\n");
+
+	if (errStatus & VFE31_IMASK_IMG_MAST_1_BUS_OVFL)
+		pr_err("vfe31_irq: image master 1 bus overflow\n");
+
+	if (errStatus & VFE31_IMASK_IMG_MAST_2_BUS_OVFL)
+		pr_err("vfe31_irq: image master 2 bus overflow\n");
+
+	if (errStatus & VFE31_IMASK_IMG_MAST_3_BUS_OVFL)
+		pr_err("vfe31_irq: image master 3 bus overflow\n");
+
+	if (errStatus & VFE31_IMASK_IMG_MAST_4_BUS_OVFL)
+		pr_err("vfe31_irq: image master 4 bus overflow\n");
+
+	if (errStatus & VFE31_IMASK_IMG_MAST_5_BUS_OVFL)
+		pr_err("vfe31_irq: image master 5 bus overflow\n");
+
+	if (errStatus & VFE31_IMASK_IMG_MAST_6_BUS_OVFL)
+		pr_err("vfe31_irq: image master 6 bus overflow\n");
+
+	if (errStatus & VFE31_IMASK_STATS_AE_BUS_OVFL)
+		pr_err("vfe31_irq: ae stats bus overflow\n");
+
+	if (errStatus & VFE31_IMASK_STATS_AF_BUS_OVFL)
+		pr_err("vfe31_irq: af stats bus overflow\n");
+
+	if (errStatus & VFE31_IMASK_STATS_AWB_BUS_OVFL)
+		pr_err("vfe31_irq: awb stats bus overflow\n");
+
+	if (errStatus & VFE31_IMASK_STATS_RS_BUS_OVFL)
+		pr_err("vfe31_irq: rs stats bus overflow\n");
+
+	if (errStatus & VFE31_IMASK_STATS_CS_BUS_OVFL)
+		pr_err("vfe31_irq: cs stats bus overflow\n");
+
+	if (errStatus & VFE31_IMASK_STATS_IHIST_BUS_OVFL)
+		pr_err("vfe31_irq: ihist stats bus overflow\n");
+
+	if (errStatus & VFE31_IMASK_STATS_SKIN_BUS_OVFL)
+		pr_err("vfe31_irq: skin stats bus overflow\n");
+
+	if (errStatus & VFE31_IMASK_AXI_ERROR) {
+		pr_err("vfe31_irq: axi error\n");
+		/* read status too when overflow happens.*/
+		read_val = msm_io_r(vfe31_ctrl->vfebase +
+			VFE_BUS_PING_PONG_STATUS);
+		pr_debug("VFE_BUS_PING_PONG_STATUS = 0x%x\n", read_val);
+		read_val = msm_io_r(vfe31_ctrl->vfebase +
+			VFE_BUS_OPERATION_STATUS);
+		pr_debug("VFE_BUS_OPERATION_STATUS = 0x%x\n", read_val);
+		read_val = msm_io_r(vfe31_ctrl->vfebase +
+			VFE_BUS_IMAGE_MASTER_0_WR_PM_STATS_0);
+		pr_debug("VFE_BUS_IMAGE_MASTER_0_WR_PM_STATS_0 = 0x%x\n",
+			read_val);
+		read_val = msm_io_r(vfe31_ctrl->vfebase +
+			VFE_BUS_IMAGE_MASTER_0_WR_PM_STATS_1);
+		pr_debug("VFE_BUS_IMAGE_MASTER_0_WR_PM_STATS_1 = 0x%x\n",
+			read_val);
+		read_val = msm_io_r(vfe31_ctrl->vfebase +
+			VFE_AXI_STATUS);
+		pr_debug("VFE_AXI_STATUS = 0x%x\n", read_val);
+	}
+}
+
+static void vfe31_process_output_path_irq_0(void)
+{
+	uint32_t ping_pong;
+	uint32_t ch0_paddr, ch1_paddr, ch2_paddr;
+	uint8_t out_bool = 0;
+	struct msm_free_buf *free_buf = NULL;
+	if (vfe31_ctrl->operation_mode ==
+			VFE_MODE_OF_OPERATION_SNAPSHOT)
+		free_buf = vfe31_check_free_buffer(VFE_MSG_OUTPUT_IRQ,
+							VFE_MSG_OUTPUT_T);
+	else
+		free_buf = vfe31_check_free_buffer(VFE_MSG_OUTPUT_IRQ,
+							VFE_MSG_OUTPUT_P);
+	/* we render frames in the following conditions:
+	1. Continuous mode and the free buffer is avaialable.
+	2. In snapshot shot mode, free buffer is not always available.
+	when pending snapshot count is <=1,  then no need to use
+	free buffer.
+	*/
+	out_bool =
+		((vfe31_ctrl->operation_mode ==
+		VFE_MODE_OF_OPERATION_SNAPSHOT ||
+		vfe31_ctrl->operation_mode ==
+		VFE_MODE_OF_OPERATION_RAW_SNAPSHOT) &&
+		(vfe31_ctrl->vfe_capture_count <= 1)) ||
+		free_buf;
+	if (out_bool) {
+		ping_pong = msm_io_r(vfe31_ctrl->vfebase +
+			VFE_BUS_PING_PONG_STATUS);
+
+		/* Channel 0*/
+		ch0_paddr = vfe31_get_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out0.ch0);
+		/* Channel 1*/
+		ch1_paddr = vfe31_get_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out0.ch1);
+		/* Channel 2*/
+		ch2_paddr = vfe31_get_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out0.ch2);
+
+		CDBG("output path 0, ch0 = 0x%x, ch1 = 0x%x, ch2 = 0x%x\n",
+			ch0_paddr, ch1_paddr, ch2_paddr);
+		if (free_buf) {
+			/* Y channel */
+			vfe31_put_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out0.ch0,
+			free_buf->ch_paddr[0]);
+			/* Chroma channel */
+			vfe31_put_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out0.ch1,
+			free_buf->ch_paddr[1]);
+			if (free_buf->num_planes > 2)
+				vfe31_put_ch_addr(ping_pong,
+					vfe31_ctrl->outpath.out0.ch2,
+					free_buf->ch_paddr[2]);
+		}
+		if (vfe31_ctrl->operation_mode ==
+			VFE_MODE_OF_OPERATION_SNAPSHOT) {
+			/* will add message for multi-shot. */
+			vfe31_ctrl->outpath.out0.capture_cnt--;
+			vfe_send_outmsg(&vfe31_ctrl->subdev,
+				MSG_ID_OUTPUT_T, ch0_paddr,
+				ch1_paddr, ch2_paddr);
+		} else {
+			/* always send message for continous mode. */
+			/* if continuous mode, for display. (preview) */
+			vfe_send_outmsg(&vfe31_ctrl->subdev,
+				MSG_ID_OUTPUT_P, ch0_paddr,
+				ch1_paddr, ch2_paddr);
+		}
+	} else {
+		vfe31_ctrl->outpath.out0.frame_drop_cnt++;
+		CDBG("path_irq_0 - no free buffer!\n");
+	}
+}
+
+static void vfe31_process_zsl_frame(void)
+{
+	uint32_t ping_pong;
+	uint32_t ch0_paddr, ch1_paddr, ch2_paddr;
+	struct msm_free_buf *free_buf = NULL;
+
+	ping_pong = msm_io_r(vfe31_ctrl->vfebase +
+			VFE_BUS_PING_PONG_STATUS);
+
+	/* Thumbnail */
+	free_buf = vfe31_check_free_buffer(VFE_MSG_OUTPUT_IRQ,
+						VFE_MSG_OUTPUT_T);
+	if (free_buf) {
+		ch0_paddr = vfe31_get_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out1.ch0);
+		ch1_paddr = vfe31_get_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out1.ch1);
+		ch2_paddr = vfe31_get_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out1.ch2);
+
+		vfe31_put_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out1.ch0,
+			free_buf->ch_paddr[0]);
+		vfe31_put_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out1.ch1,
+			free_buf->ch_paddr[1]);
+		if (free_buf->num_planes > 2)
+			vfe31_put_ch_addr(ping_pong,
+				vfe31_ctrl->outpath.out1.ch2,
+				free_buf->ch_paddr[2]);
+		vfe_send_outmsg(&vfe31_ctrl->subdev,
+			MSG_ID_OUTPUT_T, ch0_paddr,
+			ch1_paddr, ch2_paddr);
+	}
+
+	/* Mainimg */
+	free_buf = vfe31_check_free_buffer(VFE_MSG_OUTPUT_IRQ,
+						VFE_MSG_OUTPUT_S);
+	if (free_buf) {
+		ch0_paddr = vfe31_get_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out2.ch0);
+		ch1_paddr = vfe31_get_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out2.ch1);
+		ch2_paddr = vfe31_get_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out2.ch2);
+		if (free_buf->num_planes > 2)
+			vfe31_put_ch_addr(ping_pong,
+				vfe31_ctrl->outpath.out2.ch2,
+				free_buf->ch_paddr[2]);
+
+		vfe31_put_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out2.ch0,
+			free_buf->ch_paddr[0]);
+		vfe31_put_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out2.ch1,
+			free_buf->ch_paddr[1]);
+		vfe_send_outmsg(&vfe31_ctrl->subdev,
+			MSG_ID_OUTPUT_S, ch0_paddr,
+			ch1_paddr, ch2_paddr);
+	}
+}
+
+static void vfe31_process_output_path_irq_1(void)
+{
+	uint32_t ping_pong;
+	uint32_t ch0_paddr, ch1_paddr, ch2_paddr;
+	/* this must be snapshot main image output. */
+	uint8_t out_bool = 0;
+	struct msm_free_buf *free_buf = NULL;
+
+	if (vfe31_ctrl->operation_mode == VFE_MODE_OF_OPERATION_ZSL) {
+		vfe31_process_zsl_frame();
+		return;
+	}
+
+	free_buf = vfe31_check_free_buffer(VFE_MSG_OUTPUT_IRQ,
+						VFE_MSG_OUTPUT_S);
+
+	/* we render frames in the following conditions:
+	1. Continuous mode and the free buffer is avaialable.
+	2. In snapshot shot mode, free buffer is not always available.
+	-- when pending snapshot count is <=1,  then no need to use
+	free buffer.
+	*/
+	out_bool =
+		((vfe31_ctrl->operation_mode ==
+			VFE_MODE_OF_OPERATION_SNAPSHOT ||
+			vfe31_ctrl->operation_mode ==
+			VFE_MODE_OF_OPERATION_RAW_SNAPSHOT) &&
+		 (vfe31_ctrl->vfe_capture_count <= 1)) || free_buf;
+	if (out_bool) {
+		ping_pong = msm_io_r(vfe31_ctrl->vfebase +
+			VFE_BUS_PING_PONG_STATUS);
+
+		/* Y channel */
+		ch0_paddr = vfe31_get_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out1.ch0);
+		/* Chroma channel */
+		ch1_paddr = vfe31_get_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out1.ch1);
+		ch2_paddr = vfe31_get_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out1.ch2);
+
+		CDBG("snapshot main, ch0 = 0x%x, ch1 = 0x%x, ch2 = 0x%x\n",
+			ch0_paddr, ch1_paddr, ch2_paddr);
+		if (free_buf) {
+			/* Y channel */
+			vfe31_put_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out1.ch0,
+			free_buf->ch_paddr[0]);
+			/* Chroma channel */
+			vfe31_put_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out1.ch1,
+			free_buf->ch_paddr[1]);
+			if (free_buf->num_planes > 2)
+				vfe31_put_ch_addr(ping_pong,
+					vfe31_ctrl->outpath.out1.ch2,
+					free_buf->ch_paddr[2]);
+		}
+
+		if (vfe31_ctrl->operation_mode ==
+			VFE_MODE_OF_OPERATION_SNAPSHOT ||
+			vfe31_ctrl->operation_mode ==
+			VFE_MODE_OF_OPERATION_RAW_SNAPSHOT) {
+			vfe31_ctrl->outpath.out1.capture_cnt--;
+			vfe_send_outmsg(&vfe31_ctrl->subdev,
+				MSG_ID_OUTPUT_S, ch0_paddr,
+				ch1_paddr, ch2_paddr);
+		}
+
+		/* in snapshot mode if done then send
+		snapshot done message */
+		if (vfe31_ctrl->operation_mode ==
+			VFE_MODE_OF_OPERATION_SNAPSHOT ||
+			vfe31_ctrl->operation_mode ==
+			VFE_MODE_OF_OPERATION_RAW_SNAPSHOT) {
+			if ((vfe31_ctrl->outpath.out0.capture_cnt == 0)
+					&& (vfe31_ctrl->outpath.out1.
+					capture_cnt == 0)) {
+				msm_io_w_mb(
+					CAMIF_COMMAND_STOP_IMMEDIATELY,
+					vfe31_ctrl->vfebase +
+					VFE_CAMIF_COMMAND);
+				vfe31_send_isp_msg(vfe31_ctrl, MSG_ID_SNAPSHOT_DONE);
+			}
+		}
+	} else {
+		vfe31_ctrl->outpath.out1.frame_drop_cnt++;
+		CDBG("path_irq_1 - no free buffer!\n");
+	}
+}
+
+static void vfe31_process_output_path_irq_2(void)
+{
+	uint32_t ping_pong;
+	uint32_t ch0_paddr, ch1_paddr, ch2_paddr;
+	struct msm_free_buf *free_buf = NULL;
+
+	if (vfe31_ctrl->recording_state == VFE_REC_STATE_STOP_REQUESTED) {
+		vfe31_ctrl->outpath.out2.frame_drop_cnt++;
+		CDBG("%s: path_irq_2 - recording stop requested ", __func__);
+		return;
+	}
+
+	free_buf = vfe31_check_free_buffer(VFE_MSG_OUTPUT_IRQ,
+						VFE_MSG_OUTPUT_V);
+	/* we render frames in the following conditions:
+	1. Continuous mode and the free buffer is avaialable.
+	2. In snapshot shot mode, free buffer is not always available.
+	-- when pending snapshot count is <=1,  then no need to use
+	free buffer.
+	*/
+
+	CDBG("%s: op mode = %d, capture_cnt = %d\n", __func__,
+		 vfe31_ctrl->operation_mode, vfe31_ctrl->vfe_capture_count);
+
+	if (free_buf) {
+		ping_pong = msm_io_r(vfe31_ctrl->vfebase +
+			VFE_BUS_PING_PONG_STATUS);
+
+		/* Y channel */
+		ch0_paddr = vfe31_get_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out2.ch0);
+		/* Chroma channel */
+		ch1_paddr = vfe31_get_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out2.ch1);
+		ch2_paddr = vfe31_get_ch_addr(ping_pong,
+			vfe31_ctrl->outpath.out2.ch2);
+
+		CDBG("video output, ch0 = 0x%x,	ch1 = 0x%x, ch2 = 0x%x\n",
+			ch0_paddr, ch1_paddr, ch2_paddr);
+
+		/* Y channel */
+		vfe31_put_ch_addr(ping_pong,
+		vfe31_ctrl->outpath.out2.ch0,
+		free_buf->ch_paddr[0]);
+		/* Chroma channel */
+		vfe31_put_ch_addr(ping_pong,
+		vfe31_ctrl->outpath.out2.ch1,
+		free_buf->ch_paddr[1]);
+		if (free_buf->num_planes > 2)
+			vfe31_put_ch_addr(ping_pong,
+				vfe31_ctrl->outpath.out2.ch2,
+				free_buf->ch_paddr[2]);
+
+		vfe_send_outmsg(&vfe31_ctrl->subdev,
+			MSG_ID_OUTPUT_V, ch0_paddr,
+			ch1_paddr, ch2_paddr);
+
+	} else {
+		vfe31_ctrl->outpath.out2.frame_drop_cnt++;
+		CDBG("path_irq_2 - no free buffer!\n");
+	}
+}
+
+static uint32_t  vfe31_process_stats_irq_common(uint32_t statsNum,
+						uint32_t newAddr) {
+
+	uint32_t pingpongStatus;
+	uint32_t returnAddr;
+	uint32_t pingpongAddr;
+
+	/* must be 0=ping, 1=pong */
+	pingpongStatus =
+		((msm_io_r(vfe31_ctrl->vfebase +
+		VFE_BUS_PING_PONG_STATUS))
+	& ((uint32_t)(1<<(statsNum + 7)))) >> (statsNum + 7);
+	/* stats bits starts at 7 */
+	CDBG("statsNum %d, pingpongStatus %d\n", statsNum, pingpongStatus);
+	pingpongAddr =
+		((uint32_t)(vfe31_ctrl->vfebase +
+				VFE_BUS_STATS_PING_PONG_BASE)) +
+				(3*statsNum)*4 + (1-pingpongStatus)*4;
+	returnAddr = msm_io_r((uint32_t *)pingpongAddr);
+	msm_io_w(newAddr, (uint32_t *)pingpongAddr);
+	return returnAddr;
+}
+
+static void vfe_send_stats_msg(uint32_t bufAddress, uint32_t statsNum)
+{
+	unsigned long flags;
+	/* fill message with right content. */
+	/* @todo This is causing issues, need further investigate */
+	/* spin_lock_irqsave(&ctrl->state_lock, flags); */
+	struct isp_msg_stats msgStats;
+	msgStats.frameCounter = vfe31_ctrl->vfeFrameId;
+	msgStats.buffer = bufAddress;
+
+	switch (statsNum) {
+	case statsAeNum:{
+		msgStats.id = MSG_ID_STATS_AEC;
+		spin_lock_irqsave(&vfe31_ctrl->aec_ack_lock, flags);
+		vfe31_ctrl->aecStatsControl.ackPending = TRUE;
+		spin_unlock_irqrestore(&vfe31_ctrl->aec_ack_lock, flags);
+		}
+		break;
+	case statsAfNum:{
+		msgStats.id = MSG_ID_STATS_AF;
+		spin_lock_irqsave(&vfe31_ctrl->af_ack_lock, flags);
+		vfe31_ctrl->afStatsControl.ackPending = TRUE;
+		spin_unlock_irqrestore(&vfe31_ctrl->af_ack_lock, flags);
+		}
+		break;
+	case statsAwbNum: {
+		msgStats.id = MSG_ID_STATS_AWB;
+		spin_lock_irqsave(&vfe31_ctrl->awb_ack_lock, flags);
+		vfe31_ctrl->awbStatsControl.ackPending = TRUE;
+		spin_unlock_irqrestore(&vfe31_ctrl->awb_ack_lock, flags);
+		}
+		break;
+
+	case statsIhistNum: {
+		msgStats.id = MSG_ID_STATS_IHIST;
+		vfe31_ctrl->ihistStatsControl.ackPending = TRUE;
+		}
+		break;
+	case statsRsNum: {
+		msgStats.id = MSG_ID_STATS_RS;
+		vfe31_ctrl->rsStatsControl.ackPending = TRUE;
+		}
+		break;
+	case statsCsNum: {
+		msgStats.id = MSG_ID_STATS_CS;
+		vfe31_ctrl->csStatsControl.ackPending = TRUE;
+		}
+		break;
+
+	default:
+		goto stats_done;
+	}
+
+	v4l2_subdev_notify(&vfe31_ctrl->subdev,
+				NOTIFY_VFE_MSG_STATS,
+				&msgStats);
+stats_done:
+	/* spin_unlock_irqrestore(&ctrl->state_lock, flags); */
+	return;
+}
+
+
+static void vfe31_process_stats_ae_irq(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&vfe31_ctrl->aec_ack_lock, flags);
+	if (!(vfe31_ctrl->aecStatsControl.ackPending)) {
+		spin_unlock_irqrestore(&vfe31_ctrl->aec_ack_lock, flags);
+		vfe31_ctrl->aecStatsControl.bufToRender =
+			vfe31_process_stats_irq_common(statsAeNum,
+			vfe31_ctrl->aecStatsControl.nextFrameAddrBuf);
+
+		vfe_send_stats_msg(vfe31_ctrl->aecStatsControl.bufToRender,
+						statsAeNum);
+	} else{
+		spin_unlock_irqrestore(&vfe31_ctrl->aec_ack_lock, flags);
+		vfe31_ctrl->aecStatsControl.droppedStatsFrameCount++;
+	}
+}
+
+static void vfe31_process_stats_awb_irq(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&vfe31_ctrl->awb_ack_lock, flags);
+	if (!(vfe31_ctrl->awbStatsControl.ackPending)) {
+		spin_unlock_irqrestore(&vfe31_ctrl->awb_ack_lock, flags);
+		vfe31_ctrl->awbStatsControl.bufToRender =
+			vfe31_process_stats_irq_common(statsAwbNum,
+			vfe31_ctrl->awbStatsControl.nextFrameAddrBuf);
+
+		vfe_send_stats_msg(vfe31_ctrl->awbStatsControl.bufToRender,
+						statsAwbNum);
+	} else{
+		spin_unlock_irqrestore(&vfe31_ctrl->awb_ack_lock, flags);
+		vfe31_ctrl->awbStatsControl.droppedStatsFrameCount++;
+	}
+}
+
+static void vfe31_process_stats_af_irq(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&vfe31_ctrl->af_ack_lock, flags);
+	if (!(vfe31_ctrl->afStatsControl.ackPending)) {
+		spin_unlock_irqrestore(&vfe31_ctrl->af_ack_lock, flags);
+		vfe31_ctrl->afStatsControl.bufToRender =
+			vfe31_process_stats_irq_common(statsAfNum,
+			vfe31_ctrl->afStatsControl.nextFrameAddrBuf);
+
+		vfe_send_stats_msg(vfe31_ctrl->afStatsControl.bufToRender,
+						statsAfNum);
+	} else{
+		spin_unlock_irqrestore(&vfe31_ctrl->af_ack_lock, flags);
+		vfe31_ctrl->afStatsControl.droppedStatsFrameCount++;
+	}
+}
+
+static void vfe31_process_stats_ihist_irq(void)
+{
+	if (!(vfe31_ctrl->ihistStatsControl.ackPending)) {
+		vfe31_ctrl->ihistStatsControl.bufToRender =
+			vfe31_process_stats_irq_common(statsIhistNum,
+			vfe31_ctrl->ihistStatsControl.nextFrameAddrBuf);
+
+		vfe_send_stats_msg(vfe31_ctrl->ihistStatsControl.bufToRender,
+						statsIhistNum);
+	} else
+		vfe31_ctrl->ihistStatsControl.droppedStatsFrameCount++;
+}
+
+static void vfe31_process_stats_rs_irq(void)
+{
+	if (!(vfe31_ctrl->rsStatsControl.ackPending)) {
+		vfe31_ctrl->rsStatsControl.bufToRender =
+			vfe31_process_stats_irq_common(statsRsNum,
+			vfe31_ctrl->rsStatsControl.nextFrameAddrBuf);
+
+		vfe_send_stats_msg(vfe31_ctrl->rsStatsControl.bufToRender,
+						statsRsNum);
+	} else
+		vfe31_ctrl->rsStatsControl.droppedStatsFrameCount++;
+}
+
+static void vfe31_process_stats_cs_irq(void)
+{
+	if (!(vfe31_ctrl->csStatsControl.ackPending)) {
+		vfe31_ctrl->csStatsControl.bufToRender =
+			vfe31_process_stats_irq_common(statsCsNum,
+			vfe31_ctrl->csStatsControl.nextFrameAddrBuf);
+
+		vfe_send_stats_msg(vfe31_ctrl->csStatsControl.bufToRender,
+						statsCsNum);
+	} else
+		vfe31_ctrl->csStatsControl.droppedStatsFrameCount++;
+}
+
+static void vfe31_do_tasklet(unsigned long data)
+{
+	unsigned long flags;
+
+	struct vfe31_isr_queue_cmd *qcmd = NULL;
+
+	CDBG("=== vfe31_do_tasklet start === \n");
+
+	while (atomic_read(&irq_cnt)) {
+		spin_lock_irqsave(&vfe31_ctrl->tasklet_lock, flags);
+		qcmd = list_first_entry(&vfe31_ctrl->tasklet_q,
+			struct vfe31_isr_queue_cmd, list);
+		atomic_sub(1, &irq_cnt);
+
+		if (!qcmd) {
+			spin_unlock_irqrestore(&vfe31_ctrl->tasklet_lock,
+				flags);
+			return;
+		}
+
+		list_del(&qcmd->list);
+		spin_unlock_irqrestore(&vfe31_ctrl->tasklet_lock,
+			flags);
+
+		/* interrupt to be processed,  *qcmd has the payload.  */
+		if (qcmd->vfeInterruptStatus0 &
+			VFE_IRQ_STATUS0_REG_UPDATE_MASK) {
+			CDBG("irq regUpdateIrq\n");
+			vfe31_process_reg_update_irq();
+		}
+		if (qcmd->vfeInterruptStatus1 &
+			VFE_IMASK_RESET) {
+			CDBG("irq resetAckIrq\n");
+			vfe31_process_reset_irq();
+		}
+
+		if (qcmd->vfeInterruptStatus1 &
+			VFE_IMASK_AXI_HALT) {
+			CDBG("irq axi halt irq\n");
+			vfe31_process_axi_halt_irq();
+		}
+
+		if (atomic_read(&vfe31_ctrl->vstate)) {
+			if (qcmd->vfeInterruptStatus1 &
+					VFE31_IMASK_ERROR_ONLY_1) {
+				pr_err("irq	errorIrq\n");
+				vfe31_process_error_irq(
+					qcmd->vfeInterruptStatus1 &
+					VFE31_IMASK_ERROR_ONLY_1);
+			}
+
+			/* irqs below are only valid when in active state. */
+			/* next, check output path related interrupts. */
+			if (qcmd->vfeInterruptStatus0 &
+				VFE_IRQ_STATUS0_IMAGE_COMPOSIT_DONE0_MASK) {
+				CDBG("Image composite done 0 irq occured.\n");
+				vfe31_process_output_path_irq_0();
+			}
+
+			if (qcmd->vfeInterruptStatus0 &
+				VFE_IRQ_STATUS0_IMAGE_COMPOSIT_DONE1_MASK) {
+				CDBG("Image composite done 1 irq occured.\n");
+				vfe31_process_output_path_irq_1();
+			}
+
+			if (qcmd->vfeInterruptStatus0 &
+				VFE_IRQ_STATUS0_IMAGE_COMPOSIT_DONE2_MASK) {
+				CDBG("Image composite done 2 irq occured.\n");
+				vfe31_process_output_path_irq_2();
+			}
+
+			/* then process stats irq. */
+			if (vfe31_ctrl->stats_comp) {
+				/* process stats comb interrupt. */
+				if (qcmd->vfeInterruptStatus0 &
+					VFE_IRQ_STATUS0_STATS_COMPOSIT_MASK) {
+					CDBG("Stats composite irq occured.\n");
+				}
+			} else {
+				/* process individual stats interrupt. */
+				if (qcmd->vfeInterruptStatus0 &
+						VFE_IRQ_STATUS0_STATS_AEC) {
+					CDBG("Stats AEC irq occured.\n");
+					vfe31_process_stats_ae_irq();
+				}
+				if (qcmd->vfeInterruptStatus0 &
+						VFE_IRQ_STATUS0_STATS_AWB) {
+					CDBG("Stats AWB irq occured.\n");
+					vfe31_process_stats_awb_irq();
+				}
+				if (qcmd->vfeInterruptStatus0 &
+						VFE_IRQ_STATUS0_STATS_AF) {
+					CDBG("Stats AF irq occured.\n");
+					vfe31_process_stats_af_irq();
+				}
+				if (qcmd->vfeInterruptStatus0 &
+						VFE_IRQ_STATUS0_STATS_IHIST) {
+					CDBG("Stats IHIST irq occured.\n");
+					vfe31_process_stats_ihist_irq();
+				}
+				if (qcmd->vfeInterruptStatus0 &
+						VFE_IRQ_STATUS0_STATS_RS) {
+					CDBG("Stats RS irq occured.\n");
+					vfe31_process_stats_rs_irq();
+				}
+				if (qcmd->vfeInterruptStatus0 &
+						VFE_IRQ_STATUS0_STATS_CS) {
+					CDBG("Stats CS irq occured.\n");
+					vfe31_process_stats_cs_irq();
+				}
+				if (qcmd->vfeInterruptStatus0 &
+						VFE_IRQ_STATUS0_SYNC_TIMER0) {
+					CDBG("SYNC_TIMER 0 irq occured.\n");
+					vfe31_send_isp_msg(vfe31_ctrl, MSG_ID_SYNC_TIMER0_DONE);
+				}
+				if (qcmd->vfeInterruptStatus0 &
+						VFE_IRQ_STATUS0_SYNC_TIMER1) {
+					CDBG("SYNC_TIMER 1 irq occured.\n");
+					vfe31_send_isp_msg(vfe31_ctrl, MSG_ID_SYNC_TIMER1_DONE);
+				}
+				if (qcmd->vfeInterruptStatus0 &
+						VFE_IRQ_STATUS0_SYNC_TIMER2) {
+					CDBG("SYNC_TIMER 2 irq occured.\n");
+					vfe31_send_isp_msg(vfe31_ctrl, MSG_ID_SYNC_TIMER2_DONE);
+				}
+			}
+		}
+		if (qcmd->vfeInterruptStatus0 &
+				VFE_IRQ_STATUS0_CAMIF_SOF_MASK) {
+			CDBG("irq	camifSofIrq\n");
+			vfe31_process_camif_sof_irq();
+		}
+		kfree(qcmd);
+	}
+	CDBG("=== vfe31_do_tasklet end === \n");
+}
+
+DECLARE_TASKLET(vfe31_tasklet, vfe31_do_tasklet, 0);
+
+static inline void vfe31_read_irq_status(struct vfe31_irq_status *out)
+{
+	uint32_t *temp;
+	memset(out, 0, sizeof(struct vfe31_irq_status));
+	temp = (uint32_t *)(vfe31_ctrl->vfebase + VFE_IRQ_STATUS_0);
+	out->vfeIrqStatus0 = msm_io_r(temp);
+
+	temp = (uint32_t *)(vfe31_ctrl->vfebase + VFE_IRQ_STATUS_1);
+	out->vfeIrqStatus1 = msm_io_r(temp);
+
+	if (out->vfeIrqStatus1 & VFE_IMASK_AXI_HALT) {
+		msm_io_w(VFE_IMASK_RESET, vfe31_ctrl->vfebase + VFE_IRQ_MASK_1);
+
+		msm_io_w_mb(AXI_HALT_CLEAR,
+			vfe31_ctrl->vfebase + VFE_AXI_CMD);
+	}
+
+	temp = (uint32_t *)(vfe31_ctrl->vfebase + VFE_CAMIF_STATUS);
+	out->camifStatus = msm_io_r(temp);
+	CDBG("camifStatus  = 0x%x\n", out->camifStatus);
+
+	/* clear the pending interrupt of the same kind.*/
+	msm_io_w(out->vfeIrqStatus0, vfe31_ctrl->vfebase + VFE_IRQ_CLEAR_0);
+	msm_io_w(out->vfeIrqStatus1, vfe31_ctrl->vfebase + VFE_IRQ_CLEAR_1);
+
+	/* Ensure the write order while writing
+	to the command register using the barrier */
+	msm_io_w_mb(1, vfe31_ctrl->vfebase + VFE_IRQ_CMD);
+
+}
+
+static irqreturn_t vfe31_parse_irq(int irq_num, void *data)
+{
+	unsigned long flags;
+	struct vfe31_irq_status irq;
+	struct vfe31_isr_queue_cmd *qcmd;
+
+	CDBG("vfe_parse_irq\n");
+
+	vfe31_read_irq_status(&irq);
+
+	if ((irq.vfeIrqStatus0 == 0) && (irq.vfeIrqStatus1 == 0)) {
+		CDBG("vfe_parse_irq: vfeIrqStatus0 & 1 are both 0!\n");
+		return IRQ_HANDLED;
+	}
+
+	qcmd = kzalloc(sizeof(struct vfe31_isr_queue_cmd),
+		GFP_ATOMIC);
+	if (!qcmd) {
+		pr_err("vfe_parse_irq: qcmd malloc failed!\n");
+		return IRQ_HANDLED;
+	}
+
+	spin_lock_irqsave(&vfe31_ctrl->stop_flag_lock, flags);
+	if (vfe31_ctrl->stop_ack_pending) {
+		irq.vfeIrqStatus0 &= VFE_IMASK_WHILE_STOPPING_0;
+		//irq.vfeIrqStatus1 &= VFE_IMASK_WHILE_STOPPING_1;
+		irq.vfeIrqStatus1 &= vfe31_ctrl->while_stopping_mask;
+	}
+	spin_unlock_irqrestore(&vfe31_ctrl->stop_flag_lock, flags);
+
+	CDBG("vfe_parse_irq: Irq_status0 = 0x%x, Irq_status1 = 0x%x.\n",
+		irq.vfeIrqStatus0, irq.vfeIrqStatus1);
+
+	qcmd->vfeInterruptStatus0 = irq.vfeIrqStatus0;
+	qcmd->vfeInterruptStatus1 = irq.vfeIrqStatus1;
+
+	spin_lock_irqsave(&vfe31_ctrl->tasklet_lock, flags);
+	list_add_tail(&qcmd->list, &vfe31_ctrl->tasklet_q);
+
+	atomic_add(1, &irq_cnt);
+	spin_unlock_irqrestore(&vfe31_ctrl->tasklet_lock, flags);
+	tasklet_schedule(&vfe31_tasklet);
+	return IRQ_HANDLED;
+}
+
+static long msm_vfe_subdev_ioctl(struct v4l2_subdev *sd,
+			unsigned int subdev_cmd, void *arg)
+{
+	struct msm_isp_cmd vfecmd;
+
+	long rc = 0;
+	uint32_t i = 0;
+	struct vfe_cmd_stats_buf *scfg = NULL;
+	struct msm_pmem_region   *regptr = NULL;
+	struct vfe_cmd_stats_ack *sack = NULL;
+	
+	struct msm_camvfe_params *vfe_params = (struct msm_camvfe_params *)arg;
+	struct msm_vfe_cfg_cmd *cmd = vfe_params->vfe_cfg;
+	void *data = vfe_params->data;
+
+	if (cmd->cmd_type != CMD_CONFIG_PING_ADDR &&
+		cmd->cmd_type != CMD_CONFIG_PONG_ADDR &&
+		cmd->cmd_type != CMD_CONFIG_FREE_BUF_ADDR &&
+		cmd->cmd_type != CMD_STATS_AEC_BUF_RELEASE &&
+		cmd->cmd_type != CMD_STATS_AWB_BUF_RELEASE &&
+		cmd->cmd_type != CMD_STATS_IHIST_BUF_RELEASE &&
+		cmd->cmd_type != CMD_STATS_RS_BUF_RELEASE &&
+		cmd->cmd_type != CMD_STATS_CS_BUF_RELEASE &&
+		cmd->cmd_type != CMD_STATS_AF_BUF_RELEASE) {
+		if (copy_from_user(&vfecmd,
+				(void __user *)(cmd->value),
+				sizeof(vfecmd))) {
+			pr_err("%s %d: copy_from_user failed\n", __func__,
+				__LINE__);
+			return -EFAULT;
+		}
+	} else {
+	   /* here eith stats release or frame release. */
+		/*if (cmd->cmd_type != CMD_FRAME_BUF_RELEASE &&
+			cmd->cmd_type != CMD_SNAP_BUF_RELEASE) {*/ //old
+		if (cmd->cmd_type != CMD_CONFIG_PING_ADDR &&
+			cmd->cmd_type != CMD_CONFIG_PONG_ADDR &&
+			cmd->cmd_type != CMD_CONFIG_FREE_BUF_ADDR) {
+			/* then must be stats release. */
+			if (!data)
+				return -EFAULT;
+			sack = kmalloc(sizeof(struct vfe_cmd_stats_ack),
+			GFP_ATOMIC);
+			if (!sack)
+				return -ENOMEM;
+			sack->nextStatsBuf = *(uint32_t *)data;
+		}
+	}
+
+	CDBG("%s: cmdType = %d\n", __func__, cmd->cmd_type);
+
+	if ((cmd->cmd_type == CMD_STATS_AF_ENABLE) ||
+		(cmd->cmd_type == CMD_STATS_AWB_ENABLE) ||
+		(cmd->cmd_type == CMD_STATS_IHIST_ENABLE) ||
+		(cmd->cmd_type == CMD_STATS_RS_ENABLE) ||
+		(cmd->cmd_type == CMD_STATS_CS_ENABLE) ||
+		(cmd->cmd_type == CMD_STATS_AEC_ENABLE)) {
+		struct axidata *axid;
+		axid = data;
+		if (!axid) {
+			rc = -EFAULT;
+			goto vfe31_config_done;
+		}
+
+		scfg =
+			kmalloc(sizeof(struct vfe_cmd_stats_buf),
+				GFP_ATOMIC);
+		if (!scfg) {
+			rc = -ENOMEM;
+			goto vfe31_config_done;
+		}
+		regptr = axid->region;
+		if (axid->bufnum1 > 0) {
+			for (i = 0; i < axid->bufnum1; i++) {
+				scfg->statsBuf[i] =
+					(uint32_t)(regptr->paddr);
+				regptr++;
+			}
+		}
+		/* individual */
+		switch (cmd->cmd_type) {
+		case CMD_STATS_AEC_ENABLE:
+			rc = vfe_stats_aec_buf_init(scfg);
+			break;
+		case CMD_STATS_AF_ENABLE:
+			rc = vfe_stats_af_buf_init(scfg);
+			break;
+		case CMD_STATS_AWB_ENABLE:
+			rc = vfe_stats_awb_buf_init(scfg);
+			break;
+		case CMD_STATS_IHIST_ENABLE:
+			rc = vfe_stats_ihist_buf_init(scfg);
+			break;
+		case CMD_STATS_RS_ENABLE:
+			rc = vfe_stats_rs_buf_init(scfg);
+			break;
+		case CMD_STATS_CS_ENABLE:
+			rc = vfe_stats_cs_buf_init(scfg);
+			break;
+		}
+	}
+
+	switch (cmd->cmd_type) {
+	case CMD_GENERAL:
+		rc = vfe31_proc_general(&vfecmd);
+		break;
+	
+	case CMD_CONFIG_PING_ADDR: {
+		int path = *((int *)cmd->value);
+		struct vfe31_output_ch *outch = vfe31_get_ch(path);
+		outch->ping = *((struct msm_free_buf *)data);
+	}
+		break;
+
+	case CMD_CONFIG_PONG_ADDR: {
+		int path = *((int *)cmd->value);
+		struct vfe31_output_ch *outch = vfe31_get_ch(path);
+		outch->pong = *((struct msm_free_buf *)data);
+	}
+		break;
+
+	case CMD_CONFIG_FREE_BUF_ADDR: {
+		int path = *((int *)cmd->value);
+		struct vfe31_output_ch *outch = vfe31_get_ch(path);
+		outch->free_buf = *((struct msm_free_buf *)data);
+	}
+		break;
+	
+	case CMD_SNAP_BUF_RELEASE:
+		break;
+
+	case CMD_STATS_AEC_BUF_RELEASE:
+		vfe31_stats_aec_ack(sack);
+		break;
+
+	case CMD_STATS_AF_BUF_RELEASE:
+		vfe31_stats_af_ack(sack);
+		break;
+
+	case CMD_STATS_AWB_BUF_RELEASE:
+		vfe31_stats_awb_ack(sack);
+		break;
+
+	case CMD_STATS_IHIST_BUF_RELEASE:
+		vfe31_stats_ihist_ack(sack);
+		break;
+
+	case CMD_STATS_RS_BUF_RELEASE:
+		vfe31_stats_rs_ack(sack);
+		break;
+
+	case CMD_STATS_CS_BUF_RELEASE:
+		vfe31_stats_cs_ack(sack);
+		break;
+
+	case CMD_AXI_CFG_PREVIEW: {
+		uint32_t *axio = NULL;
+		axio = kmalloc(vfe31_cmd[VFE_CMD_AXI_OUT_CFG].length,
+				GFP_ATOMIC);
+		if (!axio) {
+			rc = -ENOMEM;
+			break;
+		}
+
+		if (copy_from_user(axio, (void __user *)(vfecmd.value),
+				vfe31_cmd[VFE_CMD_AXI_OUT_CFG].length)) {
+			kfree(axio);
+			rc = -EFAULT;
+			break;
+		}
+		vfe31_config_axi(OUTPUT_2, axio);
+		kfree(axio);
+		break;
+	}
+
+	case CMD_RAW_PICT_AXI_CFG: {
+		uint32_t *axio = NULL;
+		axio = kmalloc(vfe31_cmd[VFE_CMD_AXI_OUT_CFG].length,
+				GFP_ATOMIC);
+		if (!axio) {
+			rc = -ENOMEM;
+			break;
+		}
+
+		if (copy_from_user(axio, (void __user *)(vfecmd.value),
+				vfe31_cmd[VFE_CMD_AXI_OUT_CFG].length)) {
+			kfree(axio);
+			rc = -EFAULT;
+			break;
+		}
+		vfe31_config_axi(CAMIF_TO_AXI_VIA_OUTPUT_2, axio);
+		kfree(axio);
+		break;
+	}
+
+	case CMD_AXI_CFG_SNAP: {
+		uint32_t *axio = NULL;
+		axio = kmalloc(vfe31_cmd[VFE_CMD_AXI_OUT_CFG].length,
+				GFP_ATOMIC);
+		if (!axio) {
+			rc = -ENOMEM;
+			break;
+		}
+
+		if (copy_from_user(axio, (void __user *)(vfecmd.value),
+				vfe31_cmd[VFE_CMD_AXI_OUT_CFG].length)) {
+			kfree(axio);
+			rc = -EFAULT;
+			break;
+		}
+		vfe31_config_axi(OUTPUT_1_AND_2, axio);
+		kfree(axio);
+	}
+		break;
+
+	case CMD_AXI_CFG_ZSL: {
+		uint32_t *axio = NULL;
+		CDBG("%s, CMD_AXI_CFG_ZSL\n", __func__);
+		axio = kmalloc(vfe31_cmd[VFE_CMD_AXI_OUT_CFG].length,
+				GFP_ATOMIC);
+		if (!axio) {
+			rc = -ENOMEM;
+			break;
+		}
+
+		if (copy_from_user(axio, (void __user *)(vfecmd.value),
+				vfe31_cmd[VFE_CMD_AXI_OUT_CFG].length)) {
+			kfree(axio);
+			rc = -EFAULT;
+			break;
+		}
+		vfe31_config_axi(OUTPUT_1_2_AND_3, axio);
+		kfree(axio);
+	}
+		break;
+
+	case CMD_AXI_CFG_VIDEO: {
+		uint32_t *axio = NULL;
+		axio = kmalloc(vfe31_cmd[VFE_CMD_AXI_OUT_CFG].length,
+				GFP_ATOMIC);
+		if (!axio) {
+			rc = -ENOMEM;
+			break;
+		}
+
+		if (copy_from_user(axio, (void __user *)(vfecmd.value),
+				vfe31_cmd[VFE_CMD_AXI_OUT_CFG].length)) {
+			kfree(axio);
+			rc = -EFAULT;
+			break;
+		}
+		vfe31_config_axi(OUTPUT_1_AND_3, axio);
+		kfree(axio);
+	}
+		break;
+
+	default:
+		break;
+	}
+vfe31_config_done:
+	kfree(scfg);
+	kfree(sack);
+	CDBG("%s done: rc = %d\n", __func__, (int) rc);
+	return rc;
+}
+
+#if 0
+static struct msm_cam_clk_info vfe31_clk_info[] = {
+	{"vfe_clk", 147456000},
+	{"vfe_pclk", -1},
+	{"csi_vfe_clk", -1},
+};
+#endif
+static int msm_vfe_subdev_s_crystal_freq(struct v4l2_subdev *sd,
+						u32 freq, u32 flags)
+{
+	int rc = 0;
+	int round_rate;
+
+	round_rate = clk_round_rate(vfe31_ctrl->vfe_clk[0], freq);
+	if (rc < 0) {
+		pr_err("%s: clk_round_rate failed %d\n",
+					__func__, rc);
+		return rc;
+	}
+
+	vfe_clk_rate = round_rate;
+	rc = clk_set_rate(vfe31_ctrl->vfe_clk[0], round_rate);
+	if (rc < 0)
+		pr_err("%s: clk_set_rate failed %d\n",
+					__func__, rc);
+
+	return rc;
+}
+
+static const struct v4l2_subdev_video_ops msm_vfe_subdev_video_ops = {
+	.s_crystal_freq = msm_vfe_subdev_s_crystal_freq,
+};
+
+static const struct v4l2_subdev_core_ops msm_vfe_subdev_core_ops = {
+	.ioctl = msm_vfe_subdev_ioctl,
+};
+
+static const struct v4l2_subdev_ops msm_vfe_subdev_ops = {
+	.core = &msm_vfe_subdev_core_ops,
+	.video = &msm_vfe_subdev_video_ops,
+};
+
+int msm_vfe_subdev_init(struct v4l2_subdev *sd, void *data,
+	struct platform_device *pdev)
+{
+	int rc = 0;
+	v4l2_set_subdev_hostdata(sd, data);
+	vfe_syncdata = data;
+
+	spin_lock_init(&vfe31_ctrl->stop_flag_lock);
+	spin_lock_init(&vfe31_ctrl->state_lock);
+	spin_lock_init(&vfe31_ctrl->io_lock);
+	spin_lock_init(&vfe31_ctrl->update_ack_lock);
+	spin_lock_init(&vfe31_ctrl->tasklet_lock);
+
+	spin_lock_init(&vfe31_ctrl->aec_ack_lock);
+	spin_lock_init(&vfe31_ctrl->awb_ack_lock);
+	spin_lock_init(&vfe31_ctrl->af_ack_lock);
+	spin_lock_init(&vfe31_ctrl->sd_notify_lock);
+	INIT_LIST_HEAD(&vfe31_ctrl->tasklet_q);
+
+	vfe31_ctrl->update_linear = false;
+	vfe31_ctrl->update_rolloff = false;
+	vfe31_ctrl->update_la = false;
+	vfe31_ctrl->update_gamma = false;
+
+	enable_irq(vfe31_ctrl->vfeirq->start);
+
+	vfe31_ctrl->vfebase = ioremap(vfe31_ctrl->vfemem->start,
+		resource_size(vfe31_ctrl->vfemem));
+	if (!vfe31_ctrl->vfebase) {
+		rc = -ENOMEM;
+		pr_err("%s: vfe ioremap failed\n", __func__);
+		goto vfe_remap_failed;
+	}
+#if 0
+	if (vfe31_ctrl->fs_vfe == NULL) {
+		vfe31_ctrl->fs_vfe =
+			regulator_get(&vfe31_ctrl->pdev->dev, "fs_vfe");
+		if (IS_ERR(vfe31_ctrl->fs_vfe)) {
+			pr_err("%s: Regulator FS_VFE get failed %ld\n",
+				__func__, PTR_ERR(vfe31_ctrl->fs_vfe));
+			vfe31_ctrl->fs_vfe = NULL;
+			goto vfe_fs_failed;
+		} else if (regulator_enable(vfe31_ctrl->fs_vfe)) {
+			pr_err("%s: Regulator FS_VFE enable failed\n",
+							__func__);
+			regulator_put(vfe31_ctrl->fs_vfe);
+			vfe31_ctrl->fs_vfe = NULL;
+			goto vfe_fs_failed;
+		}
+	} 
+#endif 
+    rc = msm_camio_enable(pdev);
+	pr_err("%s: rc %d", __func__, rc);
+	/*
+	rc = msm_cam_clk_enable(&vfe31_ctrl->pdev->dev, vfe31_clk_info,
+			vfe31_ctrl->vfe_clk, ARRAY_SIZE(vfe31_clk_info), 1);
+	if (rc < 0)
+		goto vfe_clk_enable_failed;*/
+
+	msm_camio_set_perf_lvl(S_INIT);
+	msm_camio_set_perf_lvl(S_PREVIEW);
+
+	vfe31_ctrl->register_total = 0x600/4;
+	/*if (msm_io_r(vfe31_ctrl->vfebase + V31_GET_HW_VERSION_OFF) ==
+		VFE31_HW_NUMBER)
+		vfe31_ctrl->register_total = VFE31_REGISTER_TOTAL;
+	else
+		vfe31_ctrl->register_total = VFE33_REGISTER_TOTAL;
+*/
+	return rc;
+
+/*vfe_clk_enable_failed:
+	regulator_disable(vfe31_ctrl->fs_vfe);
+	regulator_put(vfe31_ctrl->fs_vfe);
+	vfe31_ctrl->fs_vfe = NULL;*/
+/*vfe_fs_failed:
+	iounmap(vfe31_ctrl->vfebase);*/
+vfe_remap_failed:
+	disable_irq(vfe31_ctrl->vfeirq->start);
+	return rc;
+}
+
+void msm_vfe_subdev_release(struct platform_device *pdev)
+{
+#if 0
+	msm_cam_clk_enable(&vfe31_ctrl->pdev->dev, vfe31_clk_info,
+			vfe31_ctrl->vfe_clk, ARRAY_SIZE(vfe31_clk_info), 0);
+	if (vfe31_ctrl->fs_vfe) {
+		regulator_disable(vfe31_ctrl->fs_vfe);
+		regulator_put(vfe31_ctrl->fs_vfe);
+		vfe31_ctrl->fs_vfe = NULL;
+	}
+#endif
+    msm_camio_disable(pdev);
+	CDBG("%s, free_irq\n", __func__);
+	disable_irq(vfe31_ctrl->vfeirq->start);
+	tasklet_kill(&vfe31_tasklet);
+	iounmap(vfe31_ctrl->vfebase);
+	if (atomic_read(&irq_cnt))
+		pr_warning("%s, Warning IRQ Count not ZERO\n", __func__);
+
+	msm_camio_set_perf_lvl(S_EXIT);
+	vfe_syncdata = NULL;
+}
+
+
+static int __devinit vfe31_probe(struct platform_device *pdev)
+{
+	int rc = 0;
+	CDBG("%s: device id = %d\n", __func__, pdev->id);
+	vfe31_ctrl = kzalloc(sizeof(struct vfe31_ctrl_type), GFP_KERNEL);
+	if (!vfe31_ctrl) {
+		pr_err("%s: no enough memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	v4l2_subdev_init(&vfe31_ctrl->subdev, &msm_vfe_subdev_ops);
+	snprintf(vfe31_ctrl->subdev.name,
+			 sizeof(vfe31_ctrl->subdev.name), "vfe3.1");
+	v4l2_set_subdevdata(&vfe31_ctrl->subdev, vfe31_ctrl);
+	platform_set_drvdata(pdev, &vfe31_ctrl->subdev);
+
+	vfe31_ctrl->vfemem = platform_get_resource_byname(pdev,
+					IORESOURCE_MEM, "vfe31");
+	if (!vfe31_ctrl->vfemem) {
+		pr_err("%s: no mem resource?\n", __func__);
+		rc = -ENODEV;
+		goto vfe31_no_resource;
+	}
+	vfe31_ctrl->vfeirq = platform_get_resource_byname(pdev,
+					IORESOURCE_IRQ, "vfe31");
+	if (!vfe31_ctrl->vfeirq) {
+		pr_err("%s: no irq resource?\n", __func__);
+		rc = -ENODEV;
+		goto vfe31_no_resource;
+	}
+
+	vfe31_ctrl->vfeio = request_mem_region(vfe31_ctrl->vfemem->start,
+		resource_size(vfe31_ctrl->vfemem), pdev->name);
+	if (!vfe31_ctrl->vfeio) {
+		pr_err("%s: no valid mem region\n", __func__);
+		rc = -EBUSY;
+		goto vfe31_no_resource;
+	}
+
+	pr_err("%s: irq_h_n %d", __func__, vfe31_ctrl->vfeirq->start);
+	rc = request_irq(vfe31_ctrl->vfeirq->start, vfe31_parse_irq,
+		IRQF_TRIGGER_RISING, "vfe", 0);
+	if (rc < 0) {
+		release_mem_region(vfe31_ctrl->vfemem->start,
+			resource_size(vfe31_ctrl->vfemem));
+		pr_err("%s: irq request fail\n", __func__);
+		rc = -EBUSY;
+		goto vfe31_no_resource;
+	}
+
+	disable_irq(vfe31_ctrl->vfeirq->start);
+
+	vfe31_ctrl->pdev = pdev;
+	return 0;
+
+vfe31_no_resource:
+	kfree(vfe31_ctrl);
+	return 0;
+}
+
+static struct platform_driver vfe31_driver = {
+	.probe = vfe31_probe,
+	.driver = {
+		.name = MSM_VFE_DRV_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init msm_vfe31_init_module(void)
+{
+	return platform_driver_register(&vfe31_driver);
+}
+
+static void __exit msm_vfe31_exit_module(void)
+{
+	platform_driver_unregister(&vfe31_driver);
+}
+
+module_init(msm_vfe31_init_module);
+module_exit(msm_vfe31_exit_module);
+MODULE_DESCRIPTION("VFE 3.2 driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/video/msm/msm_vfe31_v4l2.h b/drivers/media/video/msm/msm_vfe31_v4l2.h
new file mode 100644
index 0000000..bf09c29
--- /dev/null
+++ b/drivers/media/video/msm/msm_vfe31_v4l2.h
@@ -0,0 +1,1064 @@
+/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MSM_VFE31_V4L2_H__
+#define __MSM_VFE31_V4L2_H__
+
+#define TRUE  1
+#define FALSE 0
+
+/* at start of camif,  bit 1:0 = 0x01:enable
+ * image data capture at frame boundary. */
+#define CAMIF_COMMAND_START  0x00000005
+
+/* bit 2= 0x1:clear the CAMIF_STATUS register
+ * value. */
+#define CAMIF_COMMAND_CLEAR  0x00000004
+
+/* at stop of vfe pipeline, for now it is assumed
+ * that camif will stop at any time. Bit 1:0 = 0x10:
+ * disable image data capture immediately. */
+#define CAMIF_COMMAND_STOP_IMMEDIATELY  0x00000002
+
+/* at stop of vfe pipeline, for now it is assumed
+ * that camif will stop at any time. Bit 1:0 = 0x00:
+ * disable image data capture at frame boundary */
+#define CAMIF_COMMAND_STOP_AT_FRAME_BOUNDARY  0x00000000
+
+/* to halt axi bridge */
+#define AXI_HALT  0x00000001
+
+/* clear the halt bit. */
+#define AXI_HALT_CLEAR  0x00000000
+
+/* clear axi_halt_irq */
+#define MASK_AXI_HALT_IRQ	0xFF7FFFFF
+
+/* reset the pipeline when stop command is issued.
+ * (without reset the register.) bit 26-31 = 0,
+ * domain reset, bit 0-9 = 1 for module reset, except
+ * register module. */
+#define VFE_RESET_UPON_STOP_CMD  0x000003ef
+
+/* reset the pipeline when reset command.
+ * bit 26-31 = 0, domain reset, bit 0-9 = 1 for module reset. */
+#define VFE_RESET_UPON_RESET_CMD  0x000003ff
+
+/* bit 5 is for axi status idle or busy.
+ * 1 =  halted,  0 = busy */
+#define AXI_STATUS_BUSY_MASK 0x00000020
+
+/* bit 0 & bit 1 = 1, both y and cbcr irqs need to be present
+ * for frame done interrupt */
+#define VFE_COMP_IRQ_BOTH_Y_CBCR 3
+
+/* bit 1 = 1, only cbcr irq triggers frame done interrupt */
+#define VFE_COMP_IRQ_CBCR_ONLY 2
+
+/* bit 0 = 1, only y irq triggers frame done interrupt */
+#define VFE_COMP_IRQ_Y_ONLY 1
+
+/* bit 0 = 1, PM go;   bit1 = 1, PM stop */
+#define VFE_PERFORMANCE_MONITOR_GO   0x00000001
+#define VFE_PERFORMANCE_MONITOR_STOP 0x00000002
+
+/* bit 0 = 1, test gen go;   bit1 = 1, test gen stop */
+#define VFE_TEST_GEN_GO   0x00000001
+#define VFE_TEST_GEN_STOP 0x00000002
+
+/* the chroma is assumed to be interpolated between
+ * the luma samples.  JPEG 4:2:2 */
+#define VFE_CHROMA_UPSAMPLE_INTERPOLATED 0
+
+/* constants for irq registers */
+#define VFE_DISABLE_ALL_IRQS 0
+/* bit =1 is to clear the corresponding bit in VFE_IRQ_STATUS.  */
+#define VFE_CLEAR_ALL_IRQS   0xffffffff
+
+#define VFE_IRQ_STATUS0_CAMIF_SOF_MASK            0x00000001
+#define VFE_IRQ_STATUS0_CAMIF_EOF_MASK            0x00000004
+#define VFE_IRQ_STATUS0_REG_UPDATE_MASK           0x00000020
+#define VFE_IRQ_STATUS0_IMAGE_COMPOSIT_DONE0_MASK 0x00200000
+#define VFE_IRQ_STATUS0_IMAGE_COMPOSIT_DONE1_MASK 0x00400000
+#define VFE_IRQ_STATUS0_IMAGE_COMPOSIT_DONE2_MASK 0x00800000
+#define VFE_IRQ_STATUS1_RESET_AXI_HALT_ACK_MASK   0x00800000
+#define VFE_IRQ_STATUS0_STATS_COMPOSIT_MASK       0x01000000
+
+#define VFE_IRQ_STATUS0_STATS_AEC     0x2000  /* bit 13 */
+#define VFE_IRQ_STATUS0_STATS_AF      0x4000  /* bit 14 */
+#define VFE_IRQ_STATUS0_STATS_AWB     0x8000  /* bit 15 */
+#define VFE_IRQ_STATUS0_STATS_RS      0x10000  /* bit 16 */
+#define VFE_IRQ_STATUS0_STATS_CS      0x20000  /* bit 17 */
+#define VFE_IRQ_STATUS0_STATS_IHIST   0x40000  /* bit 18 */
+
+#define VFE_IRQ_STATUS0_SYNC_TIMER0   0x2000000  /* bit 25 */
+#define VFE_IRQ_STATUS0_SYNC_TIMER1   0x4000000  /* bit 26 */
+#define VFE_IRQ_STATUS0_SYNC_TIMER2   0x8000000  /* bit 27 */
+#define VFE_IRQ_STATUS0_ASYNC_TIMER0  0x10000000  /* bit 28 */
+#define VFE_IRQ_STATUS0_ASYNC_TIMER1  0x20000000  /* bit 29 */
+#define VFE_IRQ_STATUS0_ASYNC_TIMER2  0x40000000  /* bit 30 */
+#define VFE_IRQ_STATUS0_ASYNC_TIMER3  0x80000000  /* bit 31 */
+
+/* imask for while waiting for stop ack,  driver has already
+ * requested stop, waiting for reset irq, and async timer irq.
+ * For irq_status_0, bit 28-31 are for async timer. For
+ * irq_status_1, bit 22 for reset irq, bit 23 for axi_halt_ack
+   irq */
+#define VFE_IMASK_WHILE_STOPPING_0  0xF0000000
+#define VFE_IMASK_WHILE_STOPPING_1  0x00C00000
+#define VFE_IMASK_RESET             0x00400000
+#define VFE_IMASK_AXI_HALT          0x00800000
+
+
+/* no error irq in mask 0 */
+#define VFE_IMASK_ERROR_ONLY_0  0x0
+/* when normal case, don't want to block error status. */
+/* bit 0-21 are error irq bits */
+#define VFE_IMASK_ERROR_ONLY_1  0x003fffff
+
+/* For BPC bit 0,bit 12-17 and bit 26 -20 are set to zero and other's 1 */
+#define BPC_MASK 0xF80C0FFE
+
+/* For BPC bit 1 and 2 are set to zero and other's 1 */
+#define ABF_MASK 0xFFFFFFF9
+
+/* For MCE enable bit 28 set to zero and other's 1 */
+#define MCE_EN_MASK 0xEFFFFFFF
+
+/* For MCE Q_K bit 28 to 31 set to zero and other's 1 */
+#define MCE_Q_K_MASK 0x0FFFFFFF
+
+#define AWB_ENABLE_MASK 0x00000080     /* bit 7 */
+#define AF_BF_ENABLE_MASK 0x00000040      /* bit 6 */
+#define AE_BG_ENABLE_MASK 0x00000020      /* bit 5 */
+#define IHIST_ENABLE_MASK 0x00008000   /* bit 15 */
+#define RS_ENABLE_MASK 0x00000100      /* bit 8  */
+#define CS_ENABLE_MASK 0x00000200      /* bit 9  */
+#define RS_CS_ENABLE_MASK 0x00000300   /* bit 8,9  */
+#define STATS_ENABLE_MASK 0x000483E0   /* bit 18,15,9,8,7,6,5*/
+
+#define VFE_REG_UPDATE_TRIGGER           1
+#define VFE_PM_BUF_MAX_CNT_MASK          0xFF
+#define VFE_DMI_CFG_DEFAULT              0x00000100
+#define LENS_ROLL_OFF_DELTA_TABLE_OFFSET 32
+#define VFE_AE_PINGPONG_STATUS_BIT       0x80
+#define VFE_AF_PINGPONG_STATUS_BIT       0x100
+#define VFE_AWB_PINGPONG_STATUS_BIT      0x200
+
+#define HFR_MODE_OFF 1
+
+enum VFE31_DMI_RAM_SEL {
+	 NO_MEM_SELECTED          = 0,
+	 ROLLOFF_RAM              = 0x1,
+	 RGBLUT_RAM_CH0_BANK0     = 0x2,
+	 RGBLUT_RAM_CH0_BANK1     = 0x3,
+	 RGBLUT_RAM_CH1_BANK0     = 0x4,
+	 RGBLUT_RAM_CH1_BANK1     = 0x5,
+	 RGBLUT_RAM_CH2_BANK0     = 0x6,
+	 RGBLUT_RAM_CH2_BANK1     = 0x7,
+	 STATS_HIST_RAM           = 0x8,
+	 RGBLUT_CHX_BANK0         = 0x9,
+	 RGBLUT_CHX_BANK1         = 0xa,
+	 LUMA_ADAPT_LUT_RAM_BANK0 = 0xb,
+	 LUMA_ADAPT_LUT_RAM_BANK1 = 0xc
+};
+
+enum  VFE_STATE {
+	VFE_STATE_IDLE,
+	VFE_STATE_ACTIVE
+};
+
+enum  vfe_recording_state {
+	VFE_REC_STATE_IDLE,
+	VFE_REC_STATE_START_REQUESTED,
+	VFE_REC_STATE_STARTED,
+	VFE_REC_STATE_STOP_REQUESTED,
+	VFE_REC_STATE_STOPPED,
+};
+
+
+#define V31_CAMIF_OFF             0x000001E4
+#define V31_CAMIF_LEN             32
+
+#define V31_DEMUX_OFF             0x00000284
+#define V31_DEMUX_LEN             20
+
+#define V31_MESH_ROLL_OFF_CFG_OFF             0x00000274
+#define V31_MESH_ROLL_OFF_CFG_LEN             16
+#define V31_MESH_ROLL_OFF_INIT_TABLE_SIZE     13
+#define V31_MESH_ROLL_OFF_DELTA_TABLE_SIZE    208
+#define V31_MESH_ROLL_OFF_DELTA_TABLE_OFFSET  32
+
+/* For DBPC bit 0 is set to zero and other's 1 */
+#define DBPC_MASK 0xFFFFFFFE
+
+/* For DBPC bit 1 is set to zero and other's 1 */
+#define DBCC_MASK 0xFFFFFFFD
+
+/* For DBPC/ABF/DBCC/ABCC bits are set to 1 all others 0 */
+#define DEMOSAIC_MASK 0x8FFFFFFF
+
+//#define V31_DEMOSAIC_0_OFF        0x00000298
+//#define V31_DEMOSAIC_0_LEN        4
+#define V31_DEMOSAICV3_OFF 0x00000298
+#define V31_DEMOSAICV3_LEN 4
+
+/* ABF     */
+#define V31_DEMOSAICV3_ABF_OFF 0x000002A4
+#define V31_DEMOSAICV3_ABF_LEN 180
+/* BPC     */
+#define V31_DEMOSAICV3_DBPC_CFG_OFF  0x0000029C
+#define V31_DEMOSAICV3_DBPC_LEN 8
+
+#define V31_DEMOSAICV3_UP_REG_CNT 5
+
+//TODO: check if these are necessary
+/*#define V32_DEMOSAICV3_DBPC_CFG_OFF0 0x000002a0
+#define V32_DEMOSAICV3_DBPC_CFG_OFF1 0x00000604
+#define V32_DEMOSAICV3_DBPC_CFG_OFF2 0x00000608
+
+#define V32_DEMOSAICV3_DBCC_OFF 0x0000060C
+#define V32_DEMOSAICV3_DBCC_LEN 16*/
+
+
+
+/* gamma VFE_LUT_BANK_SEL*/
+#define V31_GAMMA_CFG_OFF         0x000003BC
+#define V31_LUMA_CFG_OFF          0x000003C0
+
+#define V31_OUT_CLAMP_OFF         0x00000524
+#define V31_OUT_CLAMP_LEN         8
+
+#define V31_MODULE_CFG_OFF 0x00000010
+#define V31_MODULE_CFG_LEN 4
+
+#define V31_GET_HW_VERSION_OFF 0
+#define V31_GET_HW_VERSION_LEN 4
+
+
+#define V31_OPERATION_CFG_LEN     28
+
+#define V31_AXI_OUT_OFF           0x00000038
+#define V31_AXI_OUT_LEN           212
+#define V31_AXI_CH_INF_LEN        24
+#define V31_AXI_CFG_LEN           47
+
+#define V31_FRAME_SKIP_OFF        0x00000504
+#define V31_FRAME_SKIP_LEN        32
+
+#define V31_CHROMA_SUBS_OFF       0x000004F8
+#define V31_CHROMA_SUBS_LEN       12
+
+#define V31_FOV_OFF           0x00000360
+#define V31_FOV_LEN           8
+
+#define V31_MAIN_SCALER_OFF 0x00000368
+#define V31_MAIN_SCALER_LEN 28
+
+#define V31_S2Y_OFF 0x000004D0
+#define V31_S2Y_LEN 20
+
+#define V31_S2CbCr_OFF 0x000004E4
+#define V31_S2CbCr_LEN 20
+
+#define V31_CHROMA_EN_OFF 0x000003C4
+#define V31_CHROMA_EN_LEN 36
+
+#define V31_SYNC_TIMER_OFF      0x0000020C
+#define V31_SYNC_TIMER_POLARITY_OFF 0x00000234
+#define V31_TIMER_SELECT_OFF        0x0000025C
+#define V31_SYNC_TIMER_LEN 28
+
+#define V31_ASYNC_TIMER_OFF 0x00000238
+#define V31_ASYNC_TIMER_LEN 28
+
+#define V31_BLACK_LEVEL_OFF 0x00000264
+#define V31_BLACK_LEVEL_LEN 16
+
+//#define V31_ROLL_OFF_CFG_OFF 0x00000274
+//#define V31_ROLL_OFF_CFG_LEN 16
+
+#define V31_COLOR_COR_OFF 0x00000388
+#define V31_COLOR_COR_LEN 52
+
+#define V31_WB_OFF 0x00000384
+#define V31_WB_LEN 4
+
+#define V31_RGB_G_OFF 0x000003BC
+#define V31_RGB_G_LEN 4
+
+#define V31_LA_OFF 0x000003C0
+#define V31_LA_LEN 4
+
+#define V31_SCE_OFF 0x00000418
+#define V31_SCE_LEN 136
+
+#define V31_CHROMA_SUP_OFF 0x000003E8
+#define V31_CHROMA_SUP_LEN 12
+
+#define V31_MCE_OFF 0x000003F4
+#define V31_MCE_LEN 36
+#define V31_STATS_AF_OFF 0x0000053c
+#define V31_STATS_AF_LEN 16
+
+#define V31_STATS_AE_OFF 0x00000534
+#define V31_STATS_AE_LEN 8
+
+#define V31_STATS_AWB_OFF 0x0000054c
+#define V31_STATS_AWB_LEN 32
+
+#define V31_STATS_IHIST_OFF 0x0000057c
+#define V31_STATS_IHIST_LEN 8
+
+#define V31_STATS_RS_OFF 0x0000056c
+#define V31_STATS_RS_LEN 8
+
+#define V31_STATS_CS_OFF 0x00000574
+#define V31_STATS_CS_LEN 8
+
+#define V31_XBAR_CFG_OFF 0x00000040
+#define V31_XBAR_CFG_LEN 8
+
+#define V31_EZTUNE_CFG_OFF 0x00000010
+#define V31_EZTUNE_CFG_LEN 4
+
+#define V31_ASF_OFF 0x000004A0
+#define V31_ASF_LEN 48
+#define V31_ASF_UPDATE_LEN 36
+
+#define V31_CAPTURE_LEN 4
+
+struct vfe_cmd_hw_version {
+	uint32_t minorVersion;
+	uint32_t majorVersion;
+	uint32_t coreVersion;
+};
+
+enum VFE_AXI_OUTPUT_MODE {
+	VFE_AXI_OUTPUT_MODE_Output1,
+	VFE_AXI_OUTPUT_MODE_Output2,
+	VFE_AXI_OUTPUT_MODE_Output1AndOutput2,
+	VFE_AXI_OUTPUT_MODE_CAMIFToAXIViaOutput2,
+	VFE_AXI_OUTPUT_MODE_Output2AndCAMIFToAXIViaOutput1,
+	VFE_AXI_OUTPUT_MODE_Output1AndCAMIFToAXIViaOutput2,
+	VFE_AXI_LAST_OUTPUT_MODE_ENUM
+};
+
+enum VFE_RAW_WR_PATH_SEL {
+	VFE_RAW_OUTPUT_DISABLED,
+	VFE_RAW_OUTPUT_ENC_CBCR_PATH,
+	VFE_RAW_OUTPUT_VIEW_CBCR_PATH,
+	VFE_RAW_OUTPUT_PATH_INVALID
+};
+
+
+#define VFE_AXI_OUTPUT_BURST_LENGTH     4
+#define VFE_MAX_NUM_FRAGMENTS_PER_FRAME 4
+#define VFE_AXI_OUTPUT_CFG_FRAME_COUNT  3
+
+struct vfe_cmds_per_write_master {
+	uint16_t imageWidth;
+	uint16_t imageHeight;
+	uint16_t outRowCount;
+	uint16_t outRowIncrement;
+	uint32_t outFragments[VFE_AXI_OUTPUT_CFG_FRAME_COUNT]
+		[VFE_MAX_NUM_FRAGMENTS_PER_FRAME];
+};
+
+struct vfe_cmds_axi_per_output_path {
+	uint8_t fragmentCount;
+	struct vfe_cmds_per_write_master firstWM;
+	struct vfe_cmds_per_write_master secondWM;
+};
+
+enum VFE_AXI_BURST_LENGTH {
+	VFE_AXI_BURST_LENGTH_IS_2  = 2,
+	VFE_AXI_BURST_LENGTH_IS_4  = 4,
+	VFE_AXI_BURST_LENGTH_IS_8  = 8,
+	VFE_AXI_BURST_LENGTH_IS_16 = 16
+};
+
+
+struct vfe_cmd_fov_crop_config {
+	uint8_t enable;
+	uint16_t firstPixel;
+	uint16_t lastPixel;
+	uint16_t firstLine;
+	uint16_t lastLine;
+};
+
+struct vfe_cmds_main_scaler_stripe_init {
+	uint16_t MNCounterInit;
+	uint16_t phaseInit;
+};
+
+struct vfe_cmds_scaler_one_dimension {
+	uint8_t  enable;
+	uint16_t inputSize;
+	uint16_t outputSize;
+	uint32_t phaseMultiplicationFactor;
+	uint8_t  interpolationResolution;
+};
+
+struct vfe_cmd_main_scaler_config {
+	uint8_t enable;
+	struct vfe_cmds_scaler_one_dimension    hconfig;
+	struct vfe_cmds_scaler_one_dimension    vconfig;
+	struct vfe_cmds_main_scaler_stripe_init MNInitH;
+	struct vfe_cmds_main_scaler_stripe_init MNInitV;
+};
+
+struct vfe_cmd_scaler2_config {
+	uint8_t enable;
+	struct vfe_cmds_scaler_one_dimension hconfig;
+	struct vfe_cmds_scaler_one_dimension vconfig;
+};
+
+
+struct vfe_cmd_frame_skip_update {
+	uint32_t output1Pattern;
+	uint32_t output2Pattern;
+};
+
+struct vfe_cmd_output_clamp_config {
+	uint8_t minCh0;
+	uint8_t minCh1;
+	uint8_t minCh2;
+	uint8_t maxCh0;
+	uint8_t maxCh1;
+	uint8_t maxCh2;
+};
+
+struct vfe_cmd_chroma_subsample_config {
+	uint8_t enable;
+	uint8_t cropEnable;
+	uint8_t vsubSampleEnable;
+	uint8_t hsubSampleEnable;
+	uint8_t vCosited;
+	uint8_t hCosited;
+	uint8_t vCositedPhase;
+	uint8_t hCositedPhase;
+	uint16_t cropWidthFirstPixel;
+	uint16_t cropWidthLastPixel;
+	uint16_t cropHeightFirstLine;
+	uint16_t cropHeightLastLine;
+};
+
+enum VFE_START_INPUT_SOURCE {
+	VFE_START_INPUT_SOURCE_CAMIF,
+	VFE_START_INPUT_SOURCE_TESTGEN,
+	VFE_START_INPUT_SOURCE_AXI,
+	VFE_START_INPUT_SOURCE_INVALID
+};
+
+enum VFE_START_PIXEL_PATTERN {
+	VFE_BAYER_RGRGRG,
+	VFE_BAYER_GRGRGR,
+	VFE_BAYER_BGBGBG,
+	VFE_BAYER_GBGBGB,
+	VFE_YUV_YCbYCr,
+	VFE_YUV_YCrYCb,
+	VFE_YUV_CbYCrY,
+	VFE_YUV_CrYCbY
+};
+
+enum VFE_BUS_RD_INPUT_PIXEL_PATTERN {
+	VFE_BAYER_RAW,
+	VFE_YUV_INTERLEAVED,
+	VFE_YUV_PSEUDO_PLANAR_Y,
+	VFE_YUV_PSEUDO_PLANAR_CBCR
+};
+
+enum VFE_YUV_INPUT_COSITING_MODE {
+	VFE_YUV_COSITED,
+	VFE_YUV_INTERPOLATED
+};
+
+
+/* 13*1  */
+#define VFE31_ROLL_OFF_INIT_TABLE_SIZE  13
+/* 13*16 */
+#define VFE31_ROLL_OFF_DELTA_TABLE_SIZE 208
+
+#define VFE31_GAMMA_NUM_ENTRIES  64
+
+#define VFE31_LA_TABLE_LENGTH    64
+
+#define VFE31_HIST_TABLE_LENGTH  256
+
+struct vfe_cmds_demosaic_abf {
+	uint8_t   enable;
+	uint8_t   forceOn;
+	uint8_t   shift;
+	uint16_t  lpThreshold;
+	uint16_t  max;
+	uint16_t  min;
+	uint8_t   ratio;
+};
+
+struct vfe_cmds_demosaic_bpc {
+	uint8_t   enable;
+	uint16_t  fmaxThreshold;
+	uint16_t  fminThreshold;
+	uint16_t  redDiffThreshold;
+	uint16_t  blueDiffThreshold;
+	uint16_t  greenDiffThreshold;
+};
+
+struct vfe_cmd_demosaic_config {
+	uint8_t   enable;
+	uint8_t   slopeShift;
+	struct vfe_cmds_demosaic_abf abfConfig;
+	struct vfe_cmds_demosaic_bpc bpcConfig;
+};
+
+struct vfe_cmd_demosaic_bpc_update {
+	struct vfe_cmds_demosaic_bpc bpcUpdate;
+};
+
+struct vfe_cmd_demosaic_abf_update {
+	struct vfe_cmds_demosaic_abf abfUpdate;
+};
+
+struct vfe_cmd_white_balance_config {
+	uint8_t  enable;
+	uint16_t ch2Gain;
+	uint16_t ch1Gain;
+	uint16_t ch0Gain;
+};
+
+enum VFE_COLOR_CORRECTION_COEF_QFACTOR {
+	COEF_IS_Q7_SIGNED,
+	COEF_IS_Q8_SIGNED,
+	COEF_IS_Q9_SIGNED,
+	COEF_IS_Q10_SIGNED
+};
+
+struct vfe_cmd_color_correction_config {
+	uint8_t     enable;
+	enum VFE_COLOR_CORRECTION_COEF_QFACTOR coefQFactor;
+	int16_t  C0;
+	int16_t  C1;
+	int16_t  C2;
+	int16_t  C3;
+	int16_t  C4;
+	int16_t  C5;
+	int16_t  C6;
+	int16_t  C7;
+	int16_t  C8;
+	int16_t  K0;
+	int16_t  K1;
+	int16_t  K2;
+};
+
+#define VFE_LA_TABLE_LENGTH 64
+
+struct vfe_cmd_la_config {
+	uint8_t enable;
+	int16_t table[VFE_LA_TABLE_LENGTH];
+};
+
+#define VFE_GAMMA_TABLE_LENGTH 256
+enum VFE_RGB_GAMMA_TABLE_SELECT {
+	RGB_GAMMA_CH0_SELECTED,
+	RGB_GAMMA_CH1_SELECTED,
+	RGB_GAMMA_CH2_SELECTED,
+	RGB_GAMMA_CH0_CH1_SELECTED,
+	RGB_GAMMA_CH0_CH2_SELECTED,
+	RGB_GAMMA_CH1_CH2_SELECTED,
+	RGB_GAMMA_CH0_CH1_CH2_SELECTED
+};
+
+struct vfe_cmd_rgb_gamma_config {
+	uint8_t enable;
+	enum VFE_RGB_GAMMA_TABLE_SELECT channelSelect;
+	int16_t table[VFE_GAMMA_TABLE_LENGTH];
+};
+
+struct vfe_cmd_chroma_enhan_config {
+	uint8_t  enable;
+	int16_t am;
+	int16_t ap;
+	int16_t bm;
+	int16_t bp;
+	int16_t cm;
+	int16_t cp;
+	int16_t dm;
+	int16_t dp;
+	int16_t kcr;
+	int16_t kcb;
+	int16_t RGBtoYConversionV0;
+	int16_t RGBtoYConversionV1;
+	int16_t RGBtoYConversionV2;
+	uint8_t RGBtoYConversionOffset;
+};
+
+struct vfe_cmd_chroma_suppression_config {
+	uint8_t enable;
+	uint8_t m1;
+	uint8_t m3;
+	uint8_t n1;
+	uint8_t n3;
+	uint8_t nn1;
+	uint8_t mm1;
+};
+
+struct vfe_cmd_asf_config {
+	uint8_t enable;
+	uint8_t smoothFilterEnabled;
+	uint8_t sharpMode;
+	uint8_t smoothCoefCenter;
+	uint8_t smoothCoefSurr;
+	uint8_t normalizeFactor;
+	uint8_t sharpK1;
+	uint8_t sharpK2;
+	uint8_t sharpThreshE1;
+	int8_t sharpThreshE2;
+	int8_t sharpThreshE3;
+	int8_t sharpThreshE4;
+	int8_t sharpThreshE5;
+	int8_t filter1Coefficients[9];
+	int8_t filter2Coefficients[9];
+	uint8_t  cropEnable;
+	uint16_t cropFirstPixel;
+	uint16_t cropLastPixel;
+	uint16_t cropFirstLine;
+	uint16_t cropLastLine;
+};
+
+struct vfe_cmd_asf_update {
+	uint8_t enable;
+	uint8_t smoothFilterEnabled;
+	uint8_t sharpMode;
+	uint8_t smoothCoefCenter;
+	uint8_t smoothCoefSurr;
+	uint8_t normalizeFactor;
+	uint8_t sharpK1;
+	uint8_t sharpK2;
+	uint8_t sharpThreshE1;
+	int8_t  sharpThreshE2;
+	int8_t  sharpThreshE3;
+	int8_t  sharpThreshE4;
+	int8_t  sharpThreshE5;
+	int8_t  filter1Coefficients[9];
+	int8_t  filter2Coefficients[9];
+	uint8_t cropEnable;
+};
+
+enum VFE_TEST_GEN_SYNC_EDGE {
+	VFE_TEST_GEN_SYNC_EDGE_ActiveHigh,
+	VFE_TEST_GEN_SYNC_EDGE_ActiveLow
+};
+
+
+struct vfe_cmd_bus_pm_start {
+	uint8_t output2YWrPmEnable;
+	uint8_t output2CbcrWrPmEnable;
+	uint8_t output1YWrPmEnable;
+	uint8_t output1CbcrWrPmEnable;
+};
+
+struct  vfe_frame_skip_counts {
+	uint32_t  totalFrameCount;
+	uint32_t  output1Count;
+	uint32_t  output2Count;
+};
+
+enum VFE_AXI_RD_UNPACK_HBI_SEL {
+	VFE_AXI_RD_HBI_32_CLOCK_CYCLES,
+	VFE_AXI_RD_HBI_64_CLOCK_CYCLES,
+	VFE_AXI_RD_HBI_128_CLOCK_CYCLES,
+	VFE_AXI_RD_HBI_256_CLOCK_CYCLES,
+	VFE_AXI_RD_HBI_512_CLOCK_CYCLES,
+	VFE_AXI_RD_HBI_1024_CLOCK_CYCLES,
+	VFE_AXI_RD_HBI_2048_CLOCK_CYCLES,
+	VFE_AXI_RD_HBI_4096_CLOCK_CYCLES
+};
+
+/*enum VFE31_MESSAGE_ID {
+	MSG_ID_RESET_ACK, // 0 
+	MSG_ID_START_ACK,
+	MSG_ID_STOP_ACK,
+	MSG_ID_UPDATE_ACK,
+	MSG_ID_OUTPUT_P,
+	MSG_ID_OUTPUT_T,
+	MSG_ID_OUTPUT_S,
+	MSG_ID_OUTPUT_V,
+	MSG_ID_SNAPSHOT_DONE,
+	MSG_ID_COMMON,
+	MSG_ID_EPOCH1, // 10 
+	MSG_ID_EPOCH2,
+	MSG_ID_SYNC_TIMER0_DONE,
+	MSG_ID_SYNC_TIMER1_DONE,
+	MSG_ID_SYNC_TIMER2_DONE,
+	MSG_ID_ASYNC_TIMER0_DONE,
+	MSG_ID_ASYNC_TIMER1_DONE,
+	MSG_ID_ASYNC_TIMER2_DONE,
+	MSG_ID_ASYNC_TIMER3_DONE,
+	MSG_ID_AE_OVERFLOW,
+	MSG_ID_AF_OVERFLOW, // 20 
+	MSG_ID_AWB_OVERFLOW,
+	MSG_ID_RS_OVERFLOW,
+	MSG_ID_CS_OVERFLOW,
+	MSG_ID_IHIST_OVERFLOW,
+	MSG_ID_SKIN_OVERFLOW,
+	MSG_ID_AXI_ERROR,
+	MSG_ID_CAMIF_OVERFLOW,
+	MSG_ID_VIOLATION,
+	MSG_ID_CAMIF_ERROR,
+	MSG_ID_BUS_OVERFLOW, // 30 
+	MSG_ID_SOF_ACK,
+	MSG_ID_STOP_REC_ACK,
+};*/ //old
+
+
+struct stats_buffer {
+	uint8_t awb_ymin;
+	uint32_t aec;
+	uint32_t awb;
+	uint32_t af;
+	uint32_t ihist;
+	uint32_t rs;
+	uint32_t cs;
+	uint32_t skin;
+};
+
+struct vfe_msg_stats {
+	struct stats_buffer buff;
+	uint32_t    frameCounter;
+	uint32_t    status_bits;
+};
+
+
+struct vfe_frame_bpc_info {
+	uint32_t greenDefectPixelCount;
+	uint32_t redBlueDefectPixelCount;
+};
+
+struct vfe_frame_asf_info {
+	uint32_t  asfMaxEdge;
+	uint32_t  asfHbiCount;
+};
+
+struct vfe_msg_camif_status {
+	uint8_t  camifState;
+	uint32_t pixelCount;
+	uint32_t lineCount;
+};
+
+
+struct vfe31_irq_status {
+	uint32_t vfeIrqStatus0;
+	uint32_t vfeIrqStatus1;
+	uint32_t camifStatus;
+	uint32_t demosaicStatus;
+	uint32_t asfMaxEdge;
+	uint32_t vfePingPongStatus;
+};
+
+struct vfe_msg_output {
+	uint8_t   output_id;
+	uint32_t  yBuffer;
+	uint32_t  cbcrBuffer;
+	struct vfe_frame_bpc_info bpcInfo;
+	struct vfe_frame_asf_info asfInfo;
+	uint32_t  frameCounter;
+};
+
+/*struct vfe_message {
+	enum VFE31_MESSAGE_ID _d;
+	union {
+		struct vfe_msg_output              msgOut;
+		struct vfe_msg_stats               msgStats;
+		struct vfe_msg_camif_status        msgCamifError;
+   } _u;
+};*/ //old
+
+/* New one for 7x30 */
+struct msm_vfe31_cmd {
+	int32_t  id;
+	uint16_t length;
+	void     *value;
+};
+
+#define V31_PREVIEW_AXI_FLAG  0x00000001
+#define V31_SNAPSHOT_AXI_FLAG (0x00000001<<1)
+
+struct vfe31_cmd_type {
+	uint16_t id;
+	uint32_t length;
+	uint32_t offset;
+	uint32_t flag;
+};
+
+struct vfe31_free_buf {
+	struct list_head node;
+	uint32_t paddr;
+	uint32_t y_off;
+	uint32_t cbcr_off;
+};
+
+struct vfe31_output_ch {
+	struct list_head free_buf_head;
+	spinlock_t free_buf_lock;
+	uint16_t output_fmt;
+	int8_t ch0;
+	int8_t ch1;
+	int8_t ch2;
+	uint32_t  capture_cnt;
+	uint32_t  frame_drop_cnt;
+	struct msm_free_buf ping;
+	struct msm_free_buf pong;
+	struct msm_free_buf free_buf;
+};
+
+/* no error irq in mask 0 */
+#define VFE31_IMASK_ERROR_ONLY_0  0x0
+/* when normal case, don't want to block error status. */
+/* bit 0-21 are error irq bits */
+#define VFE31_IMASK_ERROR_ONLY_1               0x003FFFFF
+#define VFE31_IMASK_CAMIF_ERROR               (0x00000001<<0)
+#define VFE31_IMASK_STATS_CS_OVWR             (0x00000001<<1)
+#define VFE31_IMASK_STATS_IHIST_OVWR          (0x00000001<<2)
+#define VFE31_IMASK_REALIGN_BUF_Y_OVFL        (0x00000001<<3)
+#define VFE31_IMASK_REALIGN_BUF_CB_OVFL       (0x00000001<<4)
+#define VFE31_IMASK_REALIGN_BUF_CR_OVFL       (0x00000001<<5)
+#define VFE31_IMASK_VIOLATION                 (0x00000001<<6)
+#define VFE31_IMASK_IMG_MAST_0_BUS_OVFL       (0x00000001<<7)
+#define VFE31_IMASK_IMG_MAST_1_BUS_OVFL       (0x00000001<<8)
+#define VFE31_IMASK_IMG_MAST_2_BUS_OVFL       (0x00000001<<9)
+#define VFE31_IMASK_IMG_MAST_3_BUS_OVFL       (0x00000001<<10)
+#define VFE31_IMASK_IMG_MAST_4_BUS_OVFL       (0x00000001<<11)
+#define VFE31_IMASK_IMG_MAST_5_BUS_OVFL       (0x00000001<<12)
+#define VFE31_IMASK_IMG_MAST_6_BUS_OVFL       (0x00000001<<13)
+#define VFE31_IMASK_STATS_AE_BUS_OVFL         (0x00000001<<14)
+#define VFE31_IMASK_STATS_AF_BUS_OVFL         (0x00000001<<15)
+#define VFE31_IMASK_STATS_AWB_BUS_OVFL        (0x00000001<<16)
+#define VFE31_IMASK_STATS_RS_BUS_OVFL         (0x00000001<<17)
+#define VFE31_IMASK_STATS_CS_BUS_OVFL         (0x00000001<<18)
+#define VFE31_IMASK_STATS_IHIST_BUS_OVFL      (0x00000001<<19)
+#define VFE31_IMASK_STATS_SKIN_BUS_OVFL       (0x00000001<<20)
+#define VFE31_IMASK_AXI_ERROR                 (0x00000001<<21)
+
+#define VFE_COM_STATUS 0x000FE000
+
+struct vfe31_output_path {
+	uint16_t output_mode;     /* bitmask  */
+
+	struct vfe31_output_ch out0; /* preview and thumbnail */
+	struct vfe31_output_ch out1; /* snapshot */
+	struct vfe31_output_ch out2; /* video    */
+};
+
+#define VFE31_OUTPUT_MODE_P_ALL_CHNLS (0x1 << 5)
+
+struct vfe31_frame_extra {
+	uint32_t greenDefectPixelCount;
+	uint32_t redBlueDefectPixelCount;
+
+	uint32_t  asfMaxEdge;
+	uint32_t  asfHbiCount;
+
+	uint32_t yWrPmStats0;
+	uint32_t yWrPmStats1;
+	uint32_t cbcrWrPmStats0;
+	uint32_t cbcrWrPmStats1;
+
+	uint32_t  frameCounter;
+};
+
+#define VFE_DISABLE_ALL_IRQS             0
+#define VFE_CLEAR_ALL_IRQS               0xffffffff
+
+#define VFE_GLOBAL_RESET                 0x00000004
+#define VFE_CGC_OVERRIDE                 0x0000000C
+#define VFE_MODULE_CFG                   0x00000010
+#define VFE_CFG_OFF                      0x00000014
+#define VFE_IRQ_CMD                      0x00000018
+#define VFE_IRQ_MASK_0                   0x0000001C
+#define VFE_IRQ_MASK_1                   0x00000020
+#define VFE_IRQ_CLEAR_0                  0x00000024
+#define VFE_IRQ_CLEAR_1                  0x00000028
+#define VFE_IRQ_STATUS_0                 0x0000002C
+#define VFE_IRQ_STATUS_1                 0x00000030
+#define VFE_IRQ_COMP_MASK                0x00000034
+#define VFE_BUS_CMD                      0x00000038
+#define VFE_BUS_PING_PONG_STATUS         0x00000180
+#define VFE_BUS_OPERATION_STATUS         0x00000184
+
+#define VFE_BUS_IMAGE_MASTER_0_WR_PM_STATS_0        0x00000190
+#define VFE_BUS_IMAGE_MASTER_0_WR_PM_STATS_1        0x00000194
+
+#define VFE_AXI_CMD                      0x000001D8
+#define VFE_AXI_STATUS                   0x000001DC
+#define VFE_BUS_STATS_PING_PONG_BASE     0x000000F4
+
+#define VFE_BUS_STATS_AEC_WR_PING_ADDR   0x000000F4
+#define VFE_BUS_STATS_AEC_WR_PONG_ADDR   0x000000F8
+#define VFE_BUS_STATS_AEC_UB_CFG         0x000000FC
+#define VFE_BUS_STATS_AF_WR_PING_ADDR    0x00000100
+#define VFE_BUS_STATS_AF_WR_PONG_ADDR    0x00000104
+#define VFE_BUS_STATS_AF_UB_CFG          0x00000108
+#define VFE_BUS_STATS_AWB_WR_PING_ADDR   0x0000010C
+#define VFE_BUS_STATS_AWB_WR_PONG_ADDR   0x00000110
+#define VFE_BUS_STATS_AWB_UB_CFG         0x00000114
+#define VFE_BUS_STATS_RS_WR_PING_ADDR    0x00000118
+#define VFE_BUS_STATS_RS_WR_PONG_ADDR    0x0000011C
+#define VFE_BUS_STATS_RS_UB_CFG          0x00000120
+
+#define VFE_BUS_STATS_CS_WR_PING_ADDR    0x00000124
+#define VFE_BUS_STATS_CS_WR_PONG_ADDR    0x00000128
+#define VFE_BUS_STATS_CS_UB_CFG          0x0000012C
+#define VFE_BUS_STATS_HIST_WR_PING_ADDR  0x00000130
+#define VFE_BUS_STATS_HIST_WR_PONG_ADDR  0x00000134
+#define VFE_BUS_STATS_HIST_UB_CFG        0x00000138
+#define VFE_BUS_STATS_SKIN_WR_PING_ADDR  0x0000013C
+#define VFE_BUS_STATS_SKIN_WR_PONG_ADDR  0x00000140
+#define VFE_BUS_STATS_SKIN_UB_CFG        0x00000144
+#define VFE_BUS_PM_CMD                   0x00000188
+#define VFE_BUS_PM_CFG                   0x0000018C
+#define VFE_CAMIF_COMMAND                0x000001E0
+#define VFE_CAMIF_STATUS                 0x00000204
+#define VFE_REG_UPDATE_CMD               0x00000260
+#define VFE_DEMUX_GAIN_0                 0x00000288
+#define VFE_DEMUX_GAIN_1                 0x0000028C
+#define VFE_CHROMA_UP                    0x0000035C
+#define VFE_FRAMEDROP_ENC_Y_CFG          0x00000504
+#define VFE_FRAMEDROP_ENC_CBCR_CFG       0x00000508
+#define VFE_FRAMEDROP_ENC_Y_PATTERN      0x0000050C
+#define VFE_FRAMEDROP_ENC_CBCR_PATTERN   0x00000510
+#define VFE_FRAMEDROP_VIEW_Y             0x00000514
+#define VFE_FRAMEDROP_VIEW_CBCR          0x00000518
+#define VFE_FRAMEDROP_VIEW_Y_PATTERN     0x0000051C
+#define VFE_FRAMEDROP_VIEW_CBCR_PATTERN  0x00000520
+#define VFE_CLAMP_MAX                    0x00000524
+#define VFE_CLAMP_MIN                    0x00000528
+#define VFE_REALIGN_BUF                  0x0000052C
+#define VFE_STATS_CFG                    0x00000530
+#define VFE_STATS_AWB_SGW_CFG            0x00000554
+#define VFE_DMI_CFG                      0x00000598
+#define VFE_DMI_ADDR                     0x0000059C
+#define VFE_DMI_DATA_LO                  0x000005A4
+#define VFE_AXI_CFG                      0x00000600
+
+struct vfe_stats_control {
+	uint8_t  ackPending;
+	uint32_t nextFrameAddrBuf;
+	uint32_t droppedStatsFrameCount;
+	uint32_t bufToRender;
+};
+
+struct vfe31_ctrl_type {
+	uint16_t operation_mode;     /* streaming or snapshot */
+	struct vfe31_output_path outpath;
+
+	uint32_t vfeImaskCompositePacked;
+
+	spinlock_t  stop_flag_lock;
+	spinlock_t  update_ack_lock;
+	spinlock_t  state_lock;
+	spinlock_t  io_lock;
+
+	spinlock_t  aec_ack_lock;
+	spinlock_t  awb_ack_lock;
+	spinlock_t  af_ack_lock;
+
+
+	int8_t aec_ack_pending;
+	int8_t awb_ack_pending;
+	int8_t af_ack_pending;
+	int8_t ihist_ack_pending;
+	int8_t rs_ack_pending;
+	int8_t cs_ack_pending;
+
+	struct msm_vfe_callback *resp;
+	uint32_t extlen;
+	void *extdata;
+
+	int8_t start_ack_pending;
+	int8_t stop_ack_pending;
+	int8_t reset_ack_pending;
+	int8_t update_ack_pending;
+	enum vfe_recording_state recording_state;
+	int8_t output0_available;
+	int8_t output1_available;
+	int8_t update_gamma;
+	int8_t update_luma;
+	int8_t update_linear;
+	int8_t update_rolloff;
+	int8_t update_la;
+	spinlock_t  tasklet_lock;
+	struct list_head tasklet_q;
+	void __iomem *vfebase;
+	void *syncdata;
+	uint32_t register_total;
+
+	struct resource	*vfemem;
+	struct resource *vfeio;
+	struct resource *vfeirq;
+	struct regulator *fs_vfe;
+
+	uint32_t stats_comp;
+	uint32_t hfr_mode;
+	atomic_t vstate;
+	uint32_t vfe_capture_count;
+	uint32_t sync_timer_repeat_count;
+	uint32_t sync_timer_state;
+	uint32_t sync_timer_number;
+
+	uint32_t vfeFrameId;
+	uint32_t output1Pattern;
+	uint32_t output1Period;
+	uint32_t output2Pattern;
+	uint32_t output2Period;
+	uint32_t vfeFrameSkipCount;
+	uint32_t vfeFrameSkipPeriod;
+	uint32_t status_bits;
+	struct vfe_stats_control afStatsControl;
+	struct vfe_stats_control awbStatsControl;
+	struct vfe_stats_control aecStatsControl;
+	struct vfe_stats_control ihistStatsControl;
+	struct vfe_stats_control rsStatsControl;
+	struct vfe_stats_control csStatsControl;
+	struct msm_camera_sensor_info *s_info;
+	//struct vfe_message vMsgHold_Snap;
+	//struct vfe_message vMsgHold_Thumb;
+	int8_t xbar_update_pending;
+	uint32_t xbar_cfg[2];
+	spinlock_t xbar_lock;
+	uint32_t while_stopping_mask;
+	
+	/* v4l2 subdev */
+	struct v4l2_subdev subdev;
+	struct platform_device *pdev;
+	struct clk *vfe_clk[3];
+	spinlock_t  sd_notify_lock;
+};
+
+#define statsAeNum      0
+#define statsAfNum      1
+#define statsAwbNum     2
+#define statsRsNum      3
+#define statsCsNum      4
+#define statsIhistNum   5
+#define statsSkinNum    6
+
+struct vfe_cmd_stats_ack{
+  uint32_t  nextStatsBuf;
+};
+
+#define VFE_STATS_BUFFER_COUNT            3
+
+struct vfe_cmd_stats_buf{
+   uint32_t statsBuf[VFE_STATS_BUFFER_COUNT];
+};
+#endif /* __MSM_VFE31_V4L2_H__ */
diff --git a/drivers/media/video/msm/sensors/Makefile b/drivers/media/video/msm/sensors/Makefile
index 3e42126..9d6121d 100644
--- a/drivers/media/video/msm/sensors/Makefile
+++ b/drivers/media/video/msm/sensors/Makefile
@@ -4,4 +4,6 @@ EXTRA_CFLAGS += -Idrivers/media/video/msm/io
 EXTRA_CFLAGS += -Idrivers/media/video/msm/csi
 obj-$(CONFIG_MSM_CAMERA_SENSOR) += msm_sensor.o
 obj-$(CONFIG_IMX074) += imx074_v4l2.o
+obj-$(CONFIG_VX6953) += vx6953.o vx6953_reg.o
+obj-$(CONFIG_S5K4ECGX) += s5k4ecgx.o
 obj-$(CONFIG_OV2720) += ov2720.o
diff --git a/drivers/media/video/msm/sensors/s5k4ecgx.c b/drivers/media/video/msm/sensors/s5k4ecgx.c
new file mode 100644
index 0000000..2fd8aaa
--- /dev/null
+++ b/drivers/media/video/msm/sensors/s5k4ecgx.c
@@ -0,0 +1,885 @@
+/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#include <media/msm_camera.h>
+#include <mach/gpio.h>
+#include <mach/camera.h>
+#include <linux/slab.h>
+#include <media/v4l2-subdev.h>
+#include "msm.h"
+#include "msm_sensor.h"
+#include "s5k4ecgx.h"
+#include "s5k4ecgx_reg.h"
+
+/* Samsung S5K4ECGX Registers and their values */
+/* Sensor Core Registers */
+#define S5K4ECGX_VERSION_ID      0x4EC0
+#define S5K4ECGX_REVISION_ID     0x0011
+#define SENSOR_DEBUG 0
+
+#define CAPTURE_5MP 1
+
+struct s5k4ecgx_work {
+	struct work_struct work;
+};
+
+static struct  s5k4ecgx_work *s5k4ecgx_sensorw;
+static struct  i2c_client *s5k4ecgx_client;
+
+struct s5k4ecgx_ctrl {
+	const struct msm_camera_sensor_info *sensordata;
+};
+
+static struct v4l2_subdev *s5k4ecgx_sdev;
+static struct s5k4ecgx_ctrl *s5k4ecgx_ctrl;
+static int8_t cam_mode = -1;
+static DECLARE_WAIT_QUEUE_HEAD(s5k4ecgx_wait_queue);
+DEFINE_SEMAPHORE(s5k4ecgx_sem);
+
+/*=============================================================
+	EXTERNAL DECLARATIONS
+==============================================================*/
+
+
+/*=============================================================*/
+static int s5k4ecgx_reset(const struct msm_camera_sensor_info *dev)
+{
+	int rc = 0;
+	rc = gpio_request(dev->sensor_reset, "s5k4ecgx");
+	CDBG("%s reset probe rc = %d\n", __func__, rc);
+	if (!rc) {
+		rc = gpio_direction_output(dev->sensor_reset, 0);
+		msleep(20);
+		gpio_set_value_cansleep(dev->sensor_reset, 1);
+		msleep(20);
+	}
+	CDBG("%s reset probe succeeded\n", __func__);
+	return rc;
+}
+
+static int32_t s5k4ecgx_i2c_txdata(unsigned short saddr,
+	unsigned char *txdata, int length)
+{
+	struct i2c_msg msg[] = {
+		{
+			.addr = saddr,
+			.flags = 0,
+			.len = length,
+			.buf = txdata,
+		},
+	};
+
+#if SENSOR_DEBUG
+	if (length == 2)
+		CDBG("msm_io_i2c_w: 0x%04x 0x%04x\n",
+			*(u16 *) txdata, *(u16 *) (txdata + 2));
+	else if (length == 4)
+		CDBG("msm_io_i2c_w: 0x%04x\n", *(u16 *) txdata);
+	else
+		CDBG("msm_io_i2c_w: length = %d\n", length);
+#endif
+	if (i2c_transfer(s5k4ecgx_client->adapter, msg, 1) < 0) {
+		CDBG("s5k4ecgx_i2c_txdata failed\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int32_t s5k4ecgx_i2c_write(unsigned short saddr,
+	unsigned short waddr, unsigned short wdata, enum s5k4ecgx_width width)
+{
+	int32_t rc = -EIO;
+	unsigned char buf[4];
+
+	memset(buf, 0, sizeof(buf));
+	switch (width) {
+	case WORD_LEN: {
+		buf[0] = (waddr & 0xFF00)>>8;
+		buf[1] = (waddr & 0x00FF);
+		buf[2] = (wdata & 0xFF00)>>8;
+		buf[3] = (wdata & 0x00FF);
+
+		rc = s5k4ecgx_i2c_txdata(saddr, buf, 4);
+	}
+		break;
+
+	case BYTE_LEN: {
+		buf[0] = waddr;
+		buf[1] = wdata;
+		rc = s5k4ecgx_i2c_txdata(saddr, buf, 2);
+	}
+		break;
+
+	default:
+		break;
+	}
+
+	if (rc < 0)
+		CDBG(
+		"i2c_write failed, addr = 0x%x, val = 0x%x!\n",
+		waddr, wdata);
+
+	return rc;
+}
+static int32_t s5k4ecgx_i2c_write_table(
+	struct register_address_value_pair const *reg_conf_tbl,
+	int num_of_items_in_table)
+{
+	int i;
+	int32_t rc = -EIO;
+
+	for (i = 0; i < num_of_items_in_table; i++) {
+		rc = s5k4ecgx_i2c_write(s5k4ecgx_client->addr,
+		reg_conf_tbl->register_address, reg_conf_tbl->register_value,
+		WORD_LEN);
+		if (rc < 0)
+			break;
+		reg_conf_tbl++;
+	}
+
+	return rc;
+}
+
+static int s5k4ecgx_i2c_rxdata(unsigned short saddr,
+	unsigned char *rxdata, int length)
+{
+	struct i2c_msg msgs[] = {
+	{
+		.addr   = saddr,
+		.flags = 0,
+		.len   = 2,
+		.buf   = rxdata,
+	},
+	{
+		.addr   = saddr,
+		.flags = I2C_M_RD,
+		.len   = length,
+		.buf   = rxdata,
+	},
+	};
+
+#if SENSOR_DEBUG
+	if (length == 2)
+		CDBG("msm_io_i2c_r: 0x%04x 0x%04x\n",
+			*(u16 *) rxdata, *(u16 *) (rxdata + 2));
+	else if (length == 4)
+		CDBG("msm_io_i2c_r: 0x%04x\n", *(u16 *) rxdata);
+	else
+		CDBG("msm_io_i2c_r: length = %d\n", length);
+#endif
+
+	if (i2c_transfer(s5k4ecgx_client->adapter, msgs, 2) < 0) {
+		CDBG("s5k4ecgx_i2c_rxdata failed!\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int32_t s5k4ecgx_i2c_read(unsigned short   saddr,
+	unsigned short raddr, unsigned short *rdata, enum s5k4ecgx_width width)
+{
+	int32_t rc = 0;
+	unsigned char buf[4];
+
+	if (!rdata)
+		return -EIO;
+
+	memset(buf, 0, sizeof(buf));
+
+	switch (width) {
+	case WORD_LEN: {
+		buf[0] = (raddr & 0xFF00)>>8;
+		buf[1] = (raddr & 0x00FF);
+
+		rc = s5k4ecgx_i2c_rxdata(saddr, buf, 2);
+		if (rc < 0)
+			return rc;
+
+		*rdata = buf[0] << 8 | buf[1];
+	}
+		break;
+
+	default:
+		break;
+	}
+
+	if (rc < 0)
+		CDBG("s5k4ecgx_i2c_read failed!\n");
+
+	return rc;
+}
+
+static long s5k4ecgx_reg_init(void)
+{
+	long rc;
+	CDBG("%s reg size = %d\n",
+		__func__,
+		s5k4ecgx_regs.s5k4ecgx_init_settings_size);
+	rc = s5k4ecgx_i2c_write_table(s5k4ecgx_regs.s5k4ecgx_init_settings,
+		s5k4ecgx_regs.s5k4ecgx_init_settings_size);
+	if (rc < 0) {
+		CDBG("%s reg1 write failed\n", __func__);
+		return rc;
+	}
+
+	msleep(40);
+
+	rc = s5k4ecgx_i2c_write_table(s5k4ecgx_regs.s5k4ecgx_Flash_init,
+		s5k4ecgx_regs.s5k4ecgx_Flash_init_size);
+	if (rc < 0) {
+		CDBG("%s flash init write failed\n", __func__);
+		return rc;
+	}
+
+	return 0;
+}
+
+static long s5k4ecgx_set_effect(int mode, int effect)
+{
+	long rc = 0;
+
+	switch (mode) {
+	case SENSOR_PREVIEW_MODE:
+		break;
+
+	case SENSOR_RAW_SNAPSHOT_MODE:
+	case SENSOR_SNAPSHOT_MODE:
+		break;
+
+	default:
+		break;
+	}
+
+	switch (effect) {
+	case CAMERA_EFFECT_OFF:
+		break;
+
+	case CAMERA_EFFECT_MONO:
+		break;
+
+	case CAMERA_EFFECT_NEGATIVE:
+		break;
+
+	case CAMERA_EFFECT_SOLARIZE:
+		break;
+
+	case CAMERA_EFFECT_SEPIA:
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	return rc;
+}
+
+struct debug_address_value_pair {
+	uint16_t register_address_msb;
+	uint16_t register_address_lsb;
+	uint16_t register_value;
+};
+
+static struct debug_address_value_pair debug_reg[] = {
+{0xD000, 0x1082, 4},
+{0xD000, 0x100E, 1},
+{0xD000, 0x007A, 1},
+{0xD000, 0xE406, 1},
+{0xD000, 0xE410, 1},
+{0xD000, 0xE41A, 1},
+{0xD000, 0xF132, 1},
+{0xD000, 0xF142, 1},
+{0xD000, 0xE420, 2},
+{0xD000, 0xE42E, 1},
+{0xD000, 0xF400, 30},
+{0xD000, 0xF552, 2},
+{0x7000, 0x18BC, 210},
+{0x7000, 0x1AF8, 1},
+{0x7000, 0x1896, 3},
+{0x7000, 0x189E, 1},
+{0x7000, 0x18AC, 4},
+{0x7000, 0x1AEA, 2},
+{0x7000, 0x1AE0, 1},
+{0x7000, 0x1A72, 1},
+{0x7000, 0x18A2, 1},
+{0x7000, 0x1A6A, 1},
+{0x7000, 0x385E, 1},
+{0x7000, 0x0EE6, 1},
+{0x7000, 0x1B2A, 5},
+{0x7000, 0x0722, 1},
+{0x7000, 0x0726, 1},
+{0x7000, 0x08D6, 1},
+{0x7000, 0x146E, 1},
+{0x7000, 0x08DC, 1},
+{0x7000, 0x3AF8, 1372},
+{0xD000, 0x1000, 1},
+{0x7000, 0x47B0, 1},
+{0x7000, 0x01FC, 1},
+{0x7000, 0x01FE, 2},
+{0x7000, 0x0204, 1},
+{0x7000, 0x020C, 2},
+{0x7000, 0x0294, 9},
+{0x7000, 0x070E, 1},
+{0x7000, 0x071E, 1},
+{0x7000, 0x163C, 1},
+{0x7000, 0x1648, 1},
+{0x7000, 0x1652, 2},
+{0x7000, 0x15E0, 1},
+{0x7000, 0x164C, 1},
+{0x7000, 0x163E, 2},
+{0x7000, 0x15D4, 2},
+{0x7000, 0x169A, 1},
+{0x7000, 0x166A, 1},
+{0x7000, 0x1676, 2},
+{0x7000, 0x16BC, 1},
+{0x7000, 0x16E0, 1},
+{0x7000, 0x16D4, 1},
+{0x7000, 0x1656, 1},
+{0x7000, 0x15E6, 27},
+{0x7000, 0x1722, 12},
+{0x7000, 0x028C, 1},
+{0x7000, 0x08B4, 1},
+{0x7000, 0x08BC, 7},
+{0x7000, 0x08F6, 32},
+{0x7000, 0x08F4, 1},
+{0x7000, 0x1492, 32},
+{0x7000, 0x1484, 1},
+{0x7000, 0x148A, 1},
+{0x7000, 0x058C, 8},
+{0x7000, 0x059C, 4},
+{0x7000, 0x0544, 2},
+{0x7000, 0x0F2A, 1},
+{0x7000, 0x04E6, 1},
+{0x7000, 0x0F30, 1},
+{0x7000, 0x0608, 24},
+{0x7000, 0x0638, 20},
+{0x7000, 0x0660, 2},
+{0x7000, 0x06B8, 2},
+{0x7000, 0x05D0, 1},
+{0x7000, 0x145E, 3},
+{0x7000, 0x11F0, 2},
+{0x7000, 0x101C, 41},
+{0x7000, 0x1070, 1},
+{0x7000, 0x1074, 1},
+{0x7000, 0x1078, 25},
+{0x7000, 0x10AC, 1},
+{0x7000, 0x10B0, 1},
+{0x7000, 0x10B4, 25},
+{0x7000, 0x10E8, 1},
+{0x7000, 0x10EC, 1},
+{0x7000, 0x10F0, 6},
+{0x7000, 0x1464, 3},
+{0x7000, 0x1228, 1},
+{0x7000, 0x122C, 1},
+{0x7000, 0x122A, 1},
+{0x7000, 0x120A, 1},
+{0x7000, 0x120E, 5},
+{0x7000, 0x1278, 7},
+{0x7000, 0x1224, 5},
+{0x7000, 0x2BA4, 1},
+{0x7000, 0x146C, 1},
+{0x7000, 0x1434, 13},
+{0x7000, 0x13A4, 54},
+{0x7000, 0x1410, 18},
+{0x7000, 0x1208, 1},
+{0x7000, 0x144E, 3},
+{0x7000, 0x0734, 120},
+{0x7000, 0x08A6, 7},
+{0x7000, 0x0898, 2},
+{0x7000, 0x08A0, 2},
+{0x7000, 0x4800, 126},
+{0x7000, 0x0944, 5},
+{0x7000, 0x097A, 8},
+{0x7000, 0x0976, 2},
+{0x7000, 0x0938, 6},
+{0x7000, 0x098C, 461},
+{0x7000, 0x01F8, 1},
+{0x7000, 0x0212, 3},
+{0x7000, 0x021A, 6},
+{0x7000, 0x022C, 1},
+{0x7000, 0x0478, 6},
+{0x7000, 0x17DC, 1},
+{0x7000, 0x1AE4, 1},
+{0x7000, 0x0284, 1},
+{0x7000, 0x028A, 1},
+{0x7000, 0x02A6, 16},
+{0x7000, 0x02D0, 3},
+{0x7000, 0x0396, 17},
+{0x7000, 0x0250, 8},
+{0x7000, 0x0494, 8},
+{0x7000, 0x0262, 2},
+{0x7000, 0x1CC2, 4},
+{0x7000, 0x01A8, 1},
+{0x7000, 0x147C, 1},
+{0x7000, 0x1482, 1},
+{0x7000, 0x0266, 1},
+{0x7000, 0x026A, 1},
+{0x7000, 0x024E, 1},
+{0x7000, 0x0268, 1},
+{0x7000, 0x0270, 1},
+{0x7000, 0x023E, 2},
+{0x7000, 0x0258, 4},
+{0x7000, 0x0264, 1},
+{0x7000, 0x049C, 4},
+{0x7000, 0x047C, 3},
+{0x7000, 0x0398, 2},
+{0x7000, 0x024E, 1},
+{0x7000, 0x0270, 1},
+};
+
+static long s5k4ecgx_set_sensor_mode(int mode)
+{
+	long rc = 0;
+	int count = 0;
+	uint16_t model_id = 0;
+	int out_index = 0, in_index = 0;
+	int arr_size = 0;
+	int arr_reg_msb = 0, arr_reg_lsb = 0;
+	uint16_t arr_val = 0;
+	CDBG("%s mode = %d\n", __func__, mode);
+	switch (mode) {
+	case SENSOR_PREVIEW_MODE:
+	case SENSOR_HFR_60FPS_MODE:
+		CDBG("%s preview table size = %d\n",
+		__func__,
+		s5k4ecgx_regs.s5k4ecgx_Preview.s5k4ecgx_Preview_640x480_size);
+		if ((cam_mode == SENSOR_SNAPSHOT_MODE) ||
+		   (cam_mode == SENSOR_RAW_SNAPSHOT_MODE)) {
+			CDBG("%s writing preview return table\n", __func__);
+			rc = s5k4ecgx_i2c_write_table(
+				  s5k4ecgx_regs.s5k4ecgx_Preview_Return,
+				  s5k4ecgx_regs.s5k4ecgx_Preview_Return_size);
+		}
+		else {
+			printk("%s writing preview config table\n", __func__);
+			rc = s5k4ecgx_i2c_write_table(
+				s5k4ecgx_regs.s5k4ecgx_Preview.
+					s5k4ecgx_Preview_640x480,
+				s5k4ecgx_regs.s5k4ecgx_Preview.
+					s5k4ecgx_Preview_640x480_size);
+		}
+		msleep(200);
+		do {
+			msleep(20);
+			s5k4ecgx_i2c_write_table(
+				s5k4ecgx_regs.s5k4ecgx_Get_Preview_Status,
+				s5k4ecgx_regs.s5k4ecgx_Get_Preview_Status_size);
+			rc = s5k4ecgx_i2c_read(s5k4ecgx_client->addr, 0x0F12,
+				&model_id, WORD_LEN);
+			if (model_id == 0x00)
+				break;
+			count++;
+		} while (count < 250);
+		CDBG("%s count = %d\n", __func__, count);
+		cam_mode = mode;
+		break;
+
+	case SENSOR_SNAPSHOT_MODE:
+	case SENSOR_RAW_SNAPSHOT_MODE:
+		CDBG("%s snapshot table size = %d\n",
+			__func__,
+			s5k4ecgx_regs.s5k4ecgx_Capture_Start_size);
+#if CAPTURE_5MP
+		printk("%s configure res 5MP\n", __func__);
+		rc = s5k4ecgx_i2c_write_table(
+			s5k4ecgx_regs.s5k4ecgx_Capture.s5k4ecgx_5M_Capture,
+			s5k4ecgx_regs.s5k4ecgx_Capture.
+				s5k4ecgx_5M_Capture_size);
+#else
+		printk("%s configure res = VGA\n", __func__);
+		rc = s5k4ecgx_i2c_write_table(
+			s5k4ecgx_regs.s5k4ecgx_Capture.s5k4ecgx_VGA_Capture,
+			s5k4ecgx_regs.s5k4ecgx_Capture.
+				s5k4ecgx_VGA_Capture_size);
+#endif
+		msleep(200);
+		rc = s5k4ecgx_i2c_write_table(
+				s5k4ecgx_regs.s5k4ecgx_Capture_Start,
+				s5k4ecgx_regs.s5k4ecgx_Capture_Start_size);
+		do {
+			msleep(20);
+			s5k4ecgx_i2c_write_table(
+				s5k4ecgx_regs.s5k4ecgx_Get_Capture_Status,
+				s5k4ecgx_regs.s5k4ecgx_Get_Capture_Status_size);
+			rc = s5k4ecgx_i2c_read(s5k4ecgx_client->addr, 0x0F12,
+				&model_id, WORD_LEN);
+			if (model_id == 0x00)
+				break;
+			count++;
+		} while (count < 250);
+		CDBG("%s count = %d\n", __func__, count);
+		cam_mode = mode;
+		arr_size = ARRAY_SIZE(debug_reg);
+		CDBG("%s debug reg arr size = %d\n", __func__, arr_size);
+		rc = s5k4ecgx_i2c_write(s5k4ecgx_client->addr,
+			0xFCFC, 0xD000, WORD_LEN);
+		for (out_index = 0; out_index < arr_size; out_index++) {
+			arr_reg_msb = debug_reg[out_index].register_address_msb;
+			rc = s5k4ecgx_i2c_write(s5k4ecgx_client->addr,
+				0x002C,
+				arr_reg_msb,
+				WORD_LEN);
+			arr_reg_lsb = debug_reg[out_index].register_address_lsb;
+			rc = s5k4ecgx_i2c_write(s5k4ecgx_client->addr,
+				0x002E,
+				arr_reg_lsb,
+				WORD_LEN);
+			for(in_index = 0;
+			    in_index < debug_reg[out_index].register_value;
+			    in_index++) {
+				rc = s5k4ecgx_i2c_read(s5k4ecgx_client->addr,
+					0x0F12, &arr_val, WORD_LEN);
+				CDBG("%s 0x%x%x = 0x%x\n", __func__, arr_reg_msb,
+					arr_reg_lsb, arr_val);
+				arr_reg_lsb += 2;
+			}
+		}
+
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	msleep(1000);
+
+	return rc;
+}
+
+static int s5k4ecgx_sensor_init_probe(const struct msm_camera_sensor_info *data)
+{
+	uint16_t model_id = 0;
+	int rc = 0;
+
+	CDBG("%s init entry\n", __func__);
+	rc = s5k4ecgx_reset(data);
+	if (rc < 0) {
+		CDBG("%s reset failed!\n", __func__);
+		goto init_probe_fail;
+	}
+
+	msleep(20);
+
+
+	rc = s5k4ecgx_i2c_write(s5k4ecgx_client->addr,
+	0xFCFC, 0xD000, WORD_LEN);
+	rc = s5k4ecgx_i2c_write(s5k4ecgx_client->addr,
+	0x002C, 0x7000, WORD_LEN);
+	rc = s5k4ecgx_i2c_write(s5k4ecgx_client->addr,
+	0x002E, 0x01A4, WORD_LEN);
+	/* Read the version ID of the sensor */
+	rc = s5k4ecgx_i2c_read(s5k4ecgx_client->addr,
+	0x0F12, &model_id, WORD_LEN);
+	if (rc < 0)
+		goto init_probe_fail;
+
+	CDBG("%s s5k4ecgx version id = 0x%x\n", __func__, model_id);
+
+	/* Check if it matches it with the value in Datasheet */
+	if (model_id != S5K4ECGX_VERSION_ID) {
+		CDBG("%s version id failed\n", __func__);
+		rc = -EINVAL;
+		goto init_probe_fail;
+	}
+	/* Read the version ID of the sensor */
+	rc = s5k4ecgx_i2c_read(s5k4ecgx_client->addr,
+	0x0F12, &model_id, WORD_LEN);
+	if (rc < 0)
+		goto init_probe_fail;
+
+	CDBG("%s s5k4ecgx revision id = 0x%x\n", __func__, model_id);
+
+	/* Check if it matches it with the value in Datasheet */
+	if (model_id != S5K4ECGX_REVISION_ID) {
+		CDBG("%s revision id failed\n", __func__);
+		rc = -EINVAL;
+		goto init_probe_fail;
+	}
+
+	CDBG("%s match id succeeded\n", __func__);
+	rc = s5k4ecgx_reg_init();
+	if (rc < 0)
+		goto init_probe_fail;
+
+	return rc;
+
+init_probe_fail:
+	return rc;
+}
+
+int s5k4ecgx_sensor_init(const struct msm_camera_sensor_info *data)
+{
+	int rc = 0;
+
+	s5k4ecgx_ctrl = kzalloc(sizeof(struct s5k4ecgx_ctrl), GFP_KERNEL);
+	if (!s5k4ecgx_ctrl) {
+		CDBG("s5k4ecgx_init failed!\n");
+		rc = -ENOMEM;
+		goto init_done;
+	}
+
+	if (data)
+		s5k4ecgx_ctrl->sensordata = data;
+
+	/* Input MCLK = 24MHz */
+	msm_camio_clk_rate_set(24000000);
+	msleep(20);
+
+	msm_camio_camif_pad_reg_reset();
+
+	rc = s5k4ecgx_sensor_init_probe(data);
+	if (rc < 0) {
+		CDBG("s5k4ecgx_sensor_init failed!\n");
+		goto init_fail;
+	}
+
+init_done:
+	return rc;
+
+init_fail:
+	kfree(s5k4ecgx_ctrl);
+	return rc;
+}
+
+static int s5k4ecgx_init_client(struct i2c_client *client)
+{
+	/* Initialize the MSM_CAMI2C Chip */
+	init_waitqueue_head(&s5k4ecgx_wait_queue);
+	return 0;
+}
+
+int s5k4ecgx_sensor_config(void __user *argp)
+{
+	struct sensor_cfg_data cfg_data;
+	long   rc = 0;
+
+	if (copy_from_user(&cfg_data,
+			(void *)argp,
+			sizeof(struct sensor_cfg_data)))
+		return -EFAULT;
+
+	/* down(&s5k4ecgx_sem); */
+
+	CDBG("s5k4ecgx_ioctl, cfgtype = %d, mode = %d\n",
+		cfg_data.cfgtype, cfg_data.mode);
+
+		switch (cfg_data.cfgtype) {
+		case CFG_SET_MODE:
+			rc = s5k4ecgx_set_sensor_mode(
+						cfg_data.mode);
+			break;
+
+		case CFG_SET_EFFECT:
+			rc = s5k4ecgx_set_effect(cfg_data.mode,
+						cfg_data.cfg.effect);
+			break;
+
+		case CFG_GET_PICT_FPS:
+		case CFG_GET_PREV_L_PF:
+		case CFG_GET_PREV_P_PL:
+		case CFG_GET_PICT_L_PF:
+		case CFG_GET_PICT_P_PL:
+		case CFG_GET_PICT_MAX_EXP_LC:
+		case CFG_SET_FPS:
+		case CFG_SET_PICT_FPS:
+		case CFG_SET_EXP_GAIN:
+		case CFG_SET_PICT_EXP_GAIN:
+		case CFG_PWR_DOWN:
+		case CFG_MOVE_FOCUS:
+		case CFG_SET_DEFAULT_FOCUS:
+		case CFG_SEND_WB_INFO:
+		case CFG_GET_AF_MAX_STEPS:
+			break;
+
+		default:
+			rc = -EINVAL;
+			break;
+		}
+
+	/* up(&s5k4ecgx_sem); */
+
+	return rc;
+}
+
+int s5k4ecgx_sensor_release(void)
+{
+	int rc = 0;
+
+	/* down(&s5k4ecgx_sem); */
+	gpio_set_value_cansleep(s5k4ecgx_ctrl->sensordata->sensor_reset, 0);
+	msleep(20);
+	gpio_free(s5k4ecgx_ctrl->sensordata->sensor_reset);
+	kfree(s5k4ecgx_ctrl);
+	/* up(&s5k4ecgx_sem); */
+
+	return rc;
+}
+
+static int s5k4ecgx_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	int rc = 0;
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		rc = -ENOTSUPP;
+		goto probe_failure;
+	}
+
+	s5k4ecgx_sensorw =
+		kzalloc(sizeof(struct s5k4ecgx_work), GFP_KERNEL);
+
+	if (!s5k4ecgx_sensorw) {
+		rc = -ENOMEM;
+		goto probe_failure;
+	}
+
+	i2c_set_clientdata(client, s5k4ecgx_sensorw);
+	s5k4ecgx_init_client(client);
+	s5k4ecgx_client = client;
+
+	CDBG("s5k4ecgx_probe succeeded!\n");
+
+	return 0;
+
+probe_failure:
+	kfree(s5k4ecgx_sensorw);
+	s5k4ecgx_sensorw = NULL;
+	CDBG("s5k4ecgx_probe failed!\n");
+	return rc;
+}
+
+static const struct i2c_device_id s5k4ecgx_i2c_id[] = {
+	{ "s5k4ecgx", 0},
+	{ },
+};
+
+static struct i2c_driver s5k4ecgx_i2c_driver = {
+	.id_table = s5k4ecgx_i2c_id,
+	.probe  = s5k4ecgx_i2c_probe,
+	.remove = __exit_p(s5k4ecgx_i2c_remove),
+	.driver = {
+		.name = "s5k4ecgx",
+	},
+};
+
+static int s5k4ecgx_sensor_probe(const struct msm_camera_sensor_info *info,
+				struct msm_sensor_ctrl *s)
+{
+	int rc = i2c_add_driver(&s5k4ecgx_i2c_driver);
+	if (rc < 0 || s5k4ecgx_client == NULL) {
+		rc = -ENOTSUPP;
+		goto probe_done;
+	}
+	CDBG("%s called\n", __func__);
+
+	/* Input MCLK = 24MHz */
+	msm_camio_clk_rate_set(24000000);
+	msleep(20);
+
+	rc = s5k4ecgx_sensor_init_probe(info);
+	if (rc < 0) {
+		gpio_free(info->sensor_reset);
+		goto probe_done;
+	}
+	s->s_init = s5k4ecgx_sensor_init;
+	s->s_release = s5k4ecgx_sensor_release;
+	s->s_config  = s5k4ecgx_sensor_config;
+	s->s_camera_type = FRONT_CAMERA_2D;
+	s->s_mount_angle  = 0;
+	gpio_set_value_cansleep(info->sensor_reset, 0);
+	msleep(20);
+	gpio_free(info->sensor_reset);
+
+probe_done:
+	CDBG("%s %s:%d\n", __FILE__, __func__, __LINE__);
+	return rc;
+}
+
+struct s5k4ecgx_v4l2_subdev_info {
+	enum v4l2_mbus_pixelcode code;
+	enum v4l2_colorspace colorspace;
+	uint16_t fmt;
+	uint16_t order;
+};
+
+static struct s5k4ecgx_v4l2_subdev_info s5k4ecgx_subdev_info[] = {
+	{
+	.code   = V4L2_MBUS_FMT_SBGGR10_1X10,
+	.colorspace = V4L2_COLORSPACE_JPEG,
+	.fmt    = 1,
+	.order    = 0,
+	},
+	/* more can be supported, to be added later */
+};
+
+static int32_t s5k4ecgx_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
+			   enum v4l2_mbus_pixelcode *code)
+{
+	if ((unsigned int)index >= ARRAY_SIZE(s5k4ecgx_subdev_info))
+		return -EINVAL;
+
+	*code = s5k4ecgx_subdev_info[index].code;
+	return 0;
+}
+
+static struct v4l2_subdev_core_ops s5k4ecgx_subdev_core_ops;
+static struct v4l2_subdev_video_ops s5k4ecgx_subdev_video_ops = {
+	.enum_mbus_fmt = s5k4ecgx_enum_fmt,
+};
+
+static struct v4l2_subdev_ops s5k4ecgx_subdev_ops = {
+	.core = &s5k4ecgx_subdev_core_ops,
+	.video  = &s5k4ecgx_subdev_video_ops,
+};
+
+static int s5k4ecgx_v4l2_probe(const struct msm_camera_sensor_info *info,
+	struct v4l2_subdev *sdev, struct msm_sensor_ctrl *s)
+{
+	int32_t rc = 0;
+	CDBG("%s called\n", __func__);
+
+	rc = s5k4ecgx_sensor_probe(info, s);
+	if (rc < 0)
+		return rc;
+	s5k4ecgx_sdev = sdev;
+	v4l2_i2c_subdev_init(s5k4ecgx_sdev,
+		s5k4ecgx_client,
+		&s5k4ecgx_subdev_ops);
+	return rc;
+}
+
+static int __s5k4ecgx_probe(struct platform_device *pdev)
+{
+	CDBG("%s called\n", __func__);
+	return msm_sensor_register(pdev, s5k4ecgx_v4l2_probe);
+}
+
+static struct platform_driver msm_camera_driver = {
+	.probe = __s5k4ecgx_probe,
+	.driver = {
+		.name = "msm_camera_s5k4ecgx",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init s5k4ecgx_init(void)
+{
+	CDBG("%s called\n", __func__);
+	return platform_driver_register(&msm_camera_driver);
+}
+
+module_init(s5k4ecgx_init);
diff --git a/drivers/media/video/msm/sensors/s5k4ecgx.h b/drivers/media/video/msm/sensors/s5k4ecgx.h
new file mode 100644
index 0000000..53789eb
--- /dev/null
+++ b/drivers/media/video/msm/sensors/s5k4ecgx.h
@@ -0,0 +1,77 @@
+/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef S5K4ECGX_H
+#define S5K4ECGX_H
+
+#include <linux/types.h>
+#include <mach/camera.h>
+
+
+enum s5k4ecgx_width {
+	WORD_LEN,
+	BYTE_LEN
+};
+
+struct s5k4ecgx_reg_Capture {
+	const struct register_address_value_pair *s5k4ecgx_5M_Capture;
+	uint16_t s5k4ecgx_5M_Capture_size;
+	const struct register_address_value_pair *s5k4ecgx_W4M_Capture;
+	uint16_t s5k4ecgx_W4M_Capture_size;
+	const struct register_address_value_pair *s5k4ecgx_3M_Capture;
+	uint16_t s5k4ecgx_3M_Capture_size;
+	const struct register_address_value_pair *s5k4ecgx_2M_Capture;
+	uint16_t s5k4ecgx_2M_Capture_size;
+	const struct register_address_value_pair *s5k4ecgx_W2M_Capture;
+	uint16_t s5k4ecgx_W2M_Capture_size;
+	const struct register_address_value_pair *s5k4ecgx_1M_Capture;
+	uint16_t s5k4ecgx_1M_Capture_size;
+	const struct register_address_value_pair *s5k4ecgx_W1M_Capture;
+	uint16_t s5k4ecgx_W1M_Capture_size;
+	const struct register_address_value_pair *s5k4ecgx_WVGA_Capture;
+	uint16_t s5k4ecgx_WVGA_Capture_size;
+	const struct register_address_value_pair *s5k4ecgx_VGA_Capture;
+	uint16_t s5k4ecgx_VGA_Capture_size;
+};
+
+struct s5k4ecgx_reg_Preview {
+	const struct register_address_value_pair *s5k4ecgx_Preview_1280x960;
+	uint16_t s5k4ecgx_Preview_1280x960_size;
+	const struct register_address_value_pair *s5k4ecgx_Preview_1280x720;
+	uint16_t s5k4ecgx_Preview_1280x720_size;
+	const struct register_address_value_pair *s5k4ecgx_Preview_720x480;
+	uint16_t s5k4ecgx_Preview_720x480_size;
+	const struct register_address_value_pair *s5k4ecgx_Preview_800x480;
+	uint16_t s5k4ecgx_Preview_800x480_size;
+	const struct register_address_value_pair *s5k4ecgx_Preview_640x480;
+	uint16_t s5k4ecgx_Preview_640x480_size;
+};
+
+struct s5k4ecgx_reg {
+	const struct register_address_value_pair *s5k4ecgx_init_settings;
+	uint16_t s5k4ecgx_init_settings_size;
+	struct s5k4ecgx_reg_Capture s5k4ecgx_Capture;
+	struct s5k4ecgx_reg_Preview s5k4ecgx_Preview;
+	const struct register_address_value_pair *s5k4ecgx_Flash_init;
+	uint16_t s5k4ecgx_Flash_init_size;
+	const struct register_address_value_pair *s5k4ecgx_Get_Preview_Status;
+	uint16_t s5k4ecgx_Get_Preview_Status_size;
+	const struct register_address_value_pair *s5k4ecgx_Get_Capture_Status;
+	uint16_t s5k4ecgx_Get_Capture_Status_size;
+	const struct register_address_value_pair *s5k4ecgx_Capture_Start;
+	uint16_t s5k4ecgx_Capture_Start_size;
+	const struct register_address_value_pair *s5k4ecgx_Preview_Return;
+	uint16_t s5k4ecgx_Preview_Return_size;
+};
+
+#endif /* S5K4ECGX_H */
diff --git a/drivers/media/video/msm/sensors/s5k4ecgx_reg.h b/drivers/media/video/msm/sensors/s5k4ecgx_reg.h
new file mode 100644
index 0000000..c788d4c
--- /dev/null
+++ b/drivers/media/video/msm/sensors/s5k4ecgx_reg.h
@@ -0,0 +1,4352 @@
+/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "s5k4ecgx.h"
+
+
+/* FOR 4EC EVT1.1 */
+
+/* ARM Initiation */
+static struct register_address_value_pair Cam_Cfg_Init_Table[] = {
+{0xFCFC, 0xD000},
+{0x0010, 0x0001},	/*sw_reset */
+{0x1030, 0x0000},
+{0x0014, 0x0001},
+
+{0xFFFF, 0x000A},	/* delay 10ms */
+
+
+
+/* Driving Current Setting - MIPI Do not care about Data Pin - SEHF_CHECK_IT */
+/* 00 - 2mA, 01 - 4mA, 10 - 8mA, 11 - 12mA */
+{0x0028, 0xD000},
+{0x002A, 0x1082},
+{0x0F12, 0x0000},	/*cregs_d0_d4_cd10 D4[8:9], D3[6:7], D2[4:5], D1[2:3],
+D0[0:1] */
+{0x0F12, 0x0000},	/*cregs_d5_d9_cd10 D9[8:9], D8[6:7], D7[4:5], D6[2:3],
+D5[0:1] */
+{0x0F12, 0x0000},	/*_cd10 */
+{0x0F12, 0x0A00},
+/*cregs_clks_output_cd10 SDA[11:10], SCL[9:8], PCLK[7:6],
+VSYNC[3:2], HSYNC[1:0] SDA/SCL 8mA, PCLK/VSYNC/HSYNC 2mA */
+{0x002A, 0x100E},
+{0x0F12, 0x0000},	/*pclk_delay_r */
+
+{0x002A, 0x007A},
+{0x0F12, 0x0000},	/*config_clk_setting */
+
+/* This register is for FACTORY ONLY. If you change it without prior
+notification */
+/* YOU are RESPONSIBLE for the FAILURE that will happen in the future. */
+
+/* ISP FE(ADLC) */
+{0x002A, 0xE406},
+{0x0F12, 0x0092},	/*adlc_enable */
+{0x002A, 0xE410},
+{0x0F12, 0x3804},	/*adlc_fadlc_filter_co */
+{0x002A, 0xE41A},
+{0x0F12, 0x0010},	/*adlc_ptune_total */
+{0x002A, 0xF132},
+{0x0F12, 0x0200},
+{0x002A, 0xF142},
+{0x0F12, 0x0200},   /*110404 AE haunting - from_LSI */
+{0x002A, 0xE420},
+{0x0F12, 0x0003},	/*adlc_fadlc_filter_refresh */
+{0x0F12, 0x0060},	/*adlc_filter_level_diff_threshold */
+{0x002A, 0xE42E},
+{0x0F12, 0x0004},	/*adlc_qec */
+{0x002A, 0xF400},
+{0x0F12, 0x5A3C},	/*aig_shutter_width */
+{0x0F12, 0x0023},	/*aig_cds_tune */
+{0x0F12, 0x8080},	/*aig_cds_option */
+{0x0F12, 0x03AF},	/*aig_mx */
+{0x0F12, 0x000A},	/*aig_mode_en */
+{0x0F12, 0xAA54},	/*aig_ms */
+{0x0F12, 0x0040},	/*aig_rmp_tune_1 */
+{0x0F12, 0x464E},	/*aig_rmp_tune_2 */
+{0x0F12, 0x0240},	/*aig_bist_sig_width_e */
+{0x0F12, 0x0240},	/*aig_bist_sig_width_o */
+{0x0F12, 0x0040},	/*aig_dbs_bist */
+{0x0F12, 0x1000},	/*aig_dbs_tune */
+{0x0F12, 0x55FF},	/*aig_bias_tune */
+{0x0F12, 0xD000},	/*aig_ref_tune_1 */
+{0x0F12, 0x0010},	/*aig_ref_tune_2 */
+{0x0F12, 0x0202},	/*aig_reg_tune_1 */
+{0x0F12, 0x0401},	/*aig_reg_tune_2 */
+{0x0F12, 0x0022},	/*aig_rosc_tune */
+{0x0F12, 0x0088},	/*aig_dbr_tune_1 */
+{0x0F12, 0x009F},	/*aig_dbr_tune_2 */
+{0x0F12, 0x0000},	/*aig_bist_en_cintr */
+{0x0F12, 0x1800},	/*aig_vdec_tune */
+{0x0F12, 0x0088},	/*aig_pmg_reg_tune */
+{0x0F12, 0x0000},	/*aig_pmg_tune_1 */
+{0x0F12, 0x2428},	/*aig_shutter_gap */
+{0x0F12, 0x0000},	/*aig_atx_option */
+{0x0F12, 0x03EE},	/*aig_avg_half */
+{0x0F12, 0x0000},	/*aig_hvs_test_reg */
+{0x0F12, 0x0000},	/*aig_dbus_bist_auto */
+{0x0F12, 0x0000},	/*aig_dbr_option */
+{0x002A, 0xF552},
+{0x0F12, 0x0708},	/*aig_1h_time_1 */
+{0x0F12, 0x080C},	/*aig_1h_time_2 */
+
+{0x0028, 0x7000},
+{0x002A, 0x18BC},
+{0x0F12, 0x0004},	/*senHal_ContPtrs_senModesDataArr_0_ */
+{0x0F12, 0x05B6},	/*senHal_ContPtrs_senModesDataArr_1_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_2_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_3_ */
+{0x0F12, 0x0001},	/*senHal_ContPtrs_senModesDataArr_4_ */
+{0x0F12, 0x05BA},	/*senHal_ContPtrs_senModesDataArr_5_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_6_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_7_ */
+{0x0F12, 0x0007},	/*senHal_ContPtrs_senModesDataArr_8_ */
+{0x0F12, 0x05BA},	/*senHal_ContPtrs_senModesDataArr_9_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_10_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_11_ */
+{0x0F12, 0x01F4},	/*senHal_ContPtrs_senModesDataArr_12_ */
+{0x0F12, 0x024E},	/*senHal_ContPtrs_senModesDataArr_13_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_14_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_15_ */
+{0x0F12, 0x01F4},	/*senHal_ContPtrs_senModesDataArr_16_ */
+{0x0F12, 0x05B6},	/*senHal_ContPtrs_senModesDataArr_17_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_18_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_19_ */
+{0x0F12, 0x01F4},	/*senHal_ContPtrs_senModesDataArr_20_ */
+{0x0F12, 0x05BA},	/*senHal_ContPtrs_senModesDataArr_21_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_22_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_23_ */
+{0x0F12, 0x01F4},	/*senHal_ContPtrs_senModesDataArr_24_ */
+{0x0F12, 0x024F},	/*senHal_ContPtrs_senModesDataArr_25_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_26_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_27_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_28_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_29_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_30_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_31_ */
+{0x0F12, 0x0075},	/*senHal_ContPtrs_senModesDataArr_32_ */
+{0x0F12, 0x00CF},	/*senHal_ContPtrs_senModesDataArr_33_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_34_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_35_ */
+{0x0F12, 0x0075},	/*senHal_ContPtrs_senModesDataArr_36_ */
+{0x0F12, 0x00D6},	/*senHal_ContPtrs_senModesDataArr_37_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_38_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_39_ */
+{0x0F12, 0x0004},	/*senHal_ContPtrs_senModesDataArr_40_ */
+{0x0F12, 0x01F4},	/*senHal_ContPtrs_senModesDataArr_41_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_42_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_43_ */
+{0x0F12, 0x00F0},	/*senHal_ContPtrs_senModesDataArr_44_ */
+{0x0F12, 0x01F4},	/*senHal_ContPtrs_senModesDataArr_45_ */
+{0x0F12, 0x029E},	/*senHal_ContPtrs_senModesDataArr_46_ */
+{0x0F12, 0x05B2},	/*senHal_ContPtrs_senModesDataArr_47_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_48_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_49_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_50_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_51_ */
+{0x0F12, 0x01F8},	/*senHal_ContPtrs_senModesDataArr_52_ */
+{0x0F12, 0x0228},	/*senHal_ContPtrs_senModesDataArr_53_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_54_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_55_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_56_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_57_ */
+{0x0F12, 0x0208},	/*senHal_ContPtrs_senModesDataArr_58_ */
+{0x0F12, 0x0238},	/*senHal_ContPtrs_senModesDataArr_59_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_60_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_61_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_62_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_63_ */
+{0x0F12, 0x0218},	/*senHal_ContPtrs_senModesDataArr_64_ */
+{0x0F12, 0x0238},	/*senHal_ContPtrs_senModesDataArr_65_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_66_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_67_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_68_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_69_ */
+{0x0F12, 0x0001},	/*senHal_ContPtrs_senModesDataArr_70_ */
+{0x0F12, 0x0009},	/*senHal_ContPtrs_senModesDataArr_71_ */
+{0x0F12, 0x00DE},	/*senHal_ContPtrs_senModesDataArr_72_ */
+{0x0F12, 0x05C0},	/*senHal_ContPtrs_senModesDataArr_73_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_74_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_75_ */
+{0x0F12, 0x00DF},	/*senHal_ContPtrs_senModesDataArr_76_ */
+{0x0F12, 0x00E4},	/*senHal_ContPtrs_senModesDataArr_77_ */
+{0x0F12, 0x01F8},	/*senHal_ContPtrs_senModesDataArr_78_ */
+{0x0F12, 0x01FD},	/*senHal_ContPtrs_senModesDataArr_79_ */
+{0x0F12, 0x05B6},	/*senHal_ContPtrs_senModesDataArr_80_ */
+{0x0F12, 0x05BB},	/*senHal_ContPtrs_senModesDataArr_81_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_82_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_83_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_84_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_85_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_86_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_87_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_88_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_89_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_90_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_91_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_92_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_93_ */
+{0x0F12, 0x01F8},	/*senHal_ContPtrs_senModesDataArr_94_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_95_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_96_ */
+{0x0F12, 0x0077},	/*senHal_ContPtrs_senModesDataArr_97_ */
+{0x0F12, 0x007E},	/*senHal_ContPtrs_senModesDataArr_98_ */
+{0x0F12, 0x024F},	/*senHal_ContPtrs_senModesDataArr_99_ */
+{0x0F12, 0x025E},	/*senHal_ContPtrs_senModesDataArr_100_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_101_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_102_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_103_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senModesDataArr_104_ */
+
+{0x0F12, 0x0004},	/*senHal_ContPtrs_senAvgModesDataArr_0_ */
+{0x0F12, 0x09D1},	/*senHal_ContPtrs_senAvgModesDataArr_1_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_2_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_3_ */
+{0x0F12, 0x0001},	/*senHal_ContPtrs_senAvgModesDataArr_4_ */
+{0x0F12, 0x09D5},	/*senHal_ContPtrs_senAvgModesDataArr_5_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_6_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_7_ */
+{0x0F12, 0x0008},	/*senHal_ContPtrs_senAvgModesDataArr_8_ */
+{0x0F12, 0x09D5},	/*senHal_ContPtrs_senAvgModesDataArr_9_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_10_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_11_ */
+{0x0F12, 0x02AA},	/*senHal_ContPtrs_senAvgModesDataArr_12_ */
+{0x0F12, 0x0326},	/*senHal_ContPtrs_senAvgModesDataArr_13_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_14_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_15_ */
+{0x0F12, 0x02AA},	/*senHal_ContPtrs_senAvgModesDataArr_16_ */
+{0x0F12, 0x09D1},	/*senHal_ContPtrs_senAvgModesDataArr_17_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_18_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_19_ */
+{0x0F12, 0x02AA},	/*senHal_ContPtrs_senAvgModesDataArr_20_ */
+{0x0F12, 0x09D5},	/*senHal_ContPtrs_senAvgModesDataArr_21_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_22_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_23_ */
+{0x0F12, 0x02AA},	/*senHal_ContPtrs_senAvgModesDataArr_24_ */
+{0x0F12, 0x0327},	/*senHal_ContPtrs_senAvgModesDataArr_25_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_26_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_27_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_28_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_29_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_30_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_31_ */
+{0x0F12, 0x0008},	/*senHal_ContPtrs_senAvgModesDataArr_32_ */
+{0x0F12, 0x0084},	/*senHal_ContPtrs_senAvgModesDataArr_33_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_34_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_35_ */
+{0x0F12, 0x0008},	/*senHal_ContPtrs_senAvgModesDataArr_36_ */
+{0x0F12, 0x008D},	/*senHal_ContPtrs_senAvgModesDataArr_37_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_38_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_39_ */
+{0x0F12, 0x0008},	/*senHal_ContPtrs_senAvgModesDataArr_40_ */
+{0x0F12, 0x02AA},	/*senHal_ContPtrs_senAvgModesDataArr_41_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_42_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_43_ */
+{0x0F12, 0x00AA},	/*senHal_ContPtrs_senAvgModesDataArr_44_ */
+{0x0F12, 0x02AA},	/*senHal_ContPtrs_senAvgModesDataArr_45_ */
+{0x0F12, 0x03AD},	/*senHal_ContPtrs_senAvgModesDataArr_46_ */
+{0x0F12, 0x09CD},	/*senHal_ContPtrs_senAvgModesDataArr_47_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_48_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_49_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_50_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_51_ */
+{0x0F12, 0x02AE},	/*senHal_ContPtrs_senAvgModesDataArr_52_ */
+{0x0F12, 0x02DE},	/*senHal_ContPtrs_senAvgModesDataArr_53_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_54_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_55_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_56_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_57_ */
+{0x0F12, 0x02BE},	/*senHal_ContPtrs_senAvgModesDataArr_58_ */
+{0x0F12, 0x02EE},	/*senHal_ContPtrs_senAvgModesDataArr_59_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_60_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_61_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_62_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_63_ */
+{0x0F12, 0x02CE},	/*senHal_ContPtrs_senAvgModesDataArr_64_ */
+{0x0F12, 0x02EE},	/*senHal_ContPtrs_senAvgModesDataArr_65_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_66_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_67_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_68_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_69_ */
+{0x0F12, 0x0001},	/*senHal_ContPtrs_senAvgModesDataArr_70_ */
+{0x0F12, 0x0009},	/*senHal_ContPtrs_senAvgModesDataArr_71_ */
+{0x0F12, 0x0095},	/*senHal_ContPtrs_senAvgModesDataArr_72_ */
+{0x0F12, 0x09DB},	/*senHal_ContPtrs_senAvgModesDataArr_73_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_74_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_75_ */
+{0x0F12, 0x0096},	/*senHal_ContPtrs_senAvgModesDataArr_76_ */
+{0x0F12, 0x009B},	/*senHal_ContPtrs_senAvgModesDataArr_77_ */
+{0x0F12, 0x02AE},	/*senHal_ContPtrs_senAvgModesDataArr_78_ */
+{0x0F12, 0x02B3},	/*senHal_ContPtrs_senAvgModesDataArr_79_ */
+{0x0F12, 0x09D1},	/*senHal_ContPtrs_senAvgModesDataArr_80_ */
+{0x0F12, 0x09D6},	/*senHal_ContPtrs_senAvgModesDataArr_81_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_82_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_83_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_84_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_85_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_86_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_87_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_88_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_89_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_90_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_91_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_92_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_93_ */
+{0x0F12, 0x02AE},	/*senHal_ContPtrs_senAvgModesDataArr_94_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_95_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_96_ */
+{0x0F12, 0x0009},	/*senHal_ContPtrs_senAvgModesDataArr_97_ */
+{0x0F12, 0x0010},	/*senHal_ContPtrs_senAvgModesDataArr_98_ */
+{0x0F12, 0x0327},	/*senHal_ContPtrs_senAvgModesDataArr_99_ */
+{0x0F12, 0x0336},	/*senHal_ContPtrs_senAvgModesDataArr_100_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_101_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_102_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_103_ */
+{0x0F12, 0x0000},	/*senHal_ContPtrs_senAvgModesDataArr_104_ */
+
+{0x002A, 0x1AF8},
+{0x0F12, 0x5A3C},
+/*senHal_TuneStr_AngTuneData1_2_ register at subsampling */
+
+{0x002A, 0x1896},
+{0x0F12, 0x0002},	/*senHal_SamplingType */
+{0x0F12, 0x0000},	/*senHal_SamplingMode 0000 : 2PLA, 0001 : 4PLA */
+{0x0F12, 0x0003},	/*senHal_PLAOption [0] VPLA enable, [1] HPLA enable */
+
+{0x002A, 0x189E},
+{0x0F12, 0x0FB0},	/*senHal_ExpMinPixels */
+
+{0x002A, 0x18AC},
+{0x0F12, 0x0060},	/*senHal_uAddColsBin */
+{0x0F12, 0x0060},	/*senHal_uAddColsNoBin */
+{0x0F12, 0x05C0},	/*senHal_uMinColsBin */
+{0x0F12, 0x05C0},	/*senHal_uMinColsNoBin */
+
+{0x002A, 0x1AEA},
+{0x0F12, 0x8080},	/*senHal_SubF404Tune */
+{0x0F12, 0x0080},	/*senHal_FullF404Tune */
+{0x002A, 0x1AE0},
+{0x0F12, 0x0000},	/*senHal_bSenAAC */
+
+{0x002A, 0x1A72},
+{0x0F12, 0x0000},	/*senHal_bSRX SRX off */
+{0x002A, 0x18A2},
+{0x0F12, 0x0004},
+/*senHal_NExpLinesCheckFine extend Forbidden area line */
+{0x002A, 0x1A6A},
+{0x0F12, 0x009A},	/*senHal_usForbiddenRightOfs extend right Forbidden area
+line */
+{0x002A, 0x385E},
+{0x0F12, 0x024C},	/*Mon_Sen_uExpPixelsOfs */
+
+{0x002A, 0x0EE6},
+{0x0F12, 0x0000},	/*setot_bUseDigitalHbin */
+{0x002A, 0x1B2A},
+{0x0F12, 0x0300},	/*senHal_TuneStr2_usAngTuneGainTh */
+{0x0F12, 0x00D6},	/*senHal_TuneStr2_AngTuneF4CA_0_ */
+{0x0F12, 0x008D},	/*senHal_TuneStr2_AngTuneF4CA_1_ */
+{0x0F12, 0x00CF},	/*senHal_TuneStr2_AngTuneF4C2_0_ */
+{0x0F12, 0x0084},	/*senHal_TuneStr2_AngTuneF4C2_1_ */
+
+/*=================================================================== */
+/* OTP setting */
+/*=================================================================== */
+{0x002A, 0x0722},
+{0x0F12, 0x0100},	/*skl_OTP_usWaitTime This reg should be in fornt of
+D0001000 */
+{0x002A, 0x0726},
+{0x0F12, 0x0001},
+/*skl_bUseOTPfunc OTP shading is used,this reg should be 1*/
+{0x002A, 0x08D6},
+{0x0F12, 0x0001},
+/*ash_bUseOTPData OTP shading is used, this reg should be 1*/
+{0x002A, 0x146E},
+{0x0F12, 0x0000},	/*awbb_otp_disable OTP AWB (0: use AWB Cal.)*/
+{0x002A, 0x08DC},
+{0x0F12, 0x0000},
+/*ash_bUseGasAlphaOTP OTP alpha is used, this reg should be 1 */
+
+/*=================================================================== */
+/* Trap & Patch */
+/*=================================================================== */
+
+/* TnP setting */
+/* Start of Patch data */
+{0x0028, 0x7000},
+{0x002A, 0x3AF8},
+{0x0F12, 0xB5F8},     /*  70003AF8 */
+{0x0F12, 0x4B41},     /*  70003AFA */
+{0x0F12, 0x4941},     /*  70003AFC */
+{0x0F12, 0x4842},     /*  70003AFE */
+{0x0F12, 0x2200},     /*  70003B00 */
+{0x0F12, 0xC008},     /*  70003B02 */
+{0x0F12, 0x6001},     /*  70003B04 */
+{0x0F12, 0x4941},     /*  70003B06 */
+{0x0F12, 0x4841},     /*  70003B08 */
+{0x0F12, 0x2401},     /*  70003B0A */
+{0x0F12, 0xF000},     /*  70003B0C */
+{0x0F12, 0xFC5E},     /*  70003B0E */
+{0x0F12, 0x4940},     /*  70003B10 */
+{0x0F12, 0x4841},     /*  70003B12 */
+{0x0F12, 0x2702},     /*  70003B14 */
+{0x0F12, 0x0022},     /*  70003B16 */
+{0x0F12, 0xF000},     /*  70003B18 */
+{0x0F12, 0xFC58},     /*  70003B1A */
+{0x0F12, 0x0260},     /*  70003B1C */
+{0x0F12, 0x4C3F},     /*  70003B1E */
+{0x0F12, 0x8020},     /*  70003B20 */
+{0x0F12, 0x2600},     /*  70003B22 */
+{0x0F12, 0x8066},     /*  70003B24 */
+{0x0F12, 0x493E},     /*  70003B26 */
+{0x0F12, 0x483E},     /*  70003B28 */
+{0x0F12, 0x6041},     /*  70003B2A */
+{0x0F12, 0x493E},     /*  70003B2C */
+{0x0F12, 0x483F},     /*  70003B2E */
+{0x0F12, 0x003A},     /*  70003B30 */
+{0x0F12, 0x2503},     /*  70003B32 */
+{0x0F12, 0xF000},     /*  70003B34 */
+{0x0F12, 0xFC4A},     /*  70003B36 */
+{0x0F12, 0x483A},     /*  70003B38 */
+{0x0F12, 0x493D},     /*  70003B3A */
+{0x0F12, 0x30C0},     /*  70003B3C */
+{0x0F12, 0x63C1},     /*  70003B3E */
+{0x0F12, 0x4F38},     /*  70003B40 */
+{0x0F12, 0x483C},     /*  70003B42 */
+{0x0F12, 0x3F80},     /*  70003B44 */
+{0x0F12, 0x6438},     /*  70003B46 */
+{0x0F12, 0x483B},     /*  70003B48 */
+{0x0F12, 0x493C},     /*  70003B4A */
+{0x0F12, 0x6388},     /*  70003B4C */
+{0x0F12, 0x002A},     /*  70003B4E */
+{0x0F12, 0x493B},     /*  70003B50 */
+{0x0F12, 0x483C},     /*  70003B52 */
+{0x0F12, 0x2504},     /*  70003B54 */
+{0x0F12, 0xF000},     /*  70003B56 */
+{0x0F12, 0xFC39},     /*  70003B58 */
+{0x0F12, 0x002A},     /*  70003B5A */
+{0x0F12, 0x493A},     /*  70003B5C */
+{0x0F12, 0x483B},     /*  70003B5E */
+{0x0F12, 0x2505},     /*  70003B60 */
+{0x0F12, 0xF000},     /*  70003B62 */
+{0x0F12, 0xF89D},     /*  70003B64 */
+{0x0F12, 0x4839},     /*  70003B66 */
+{0x0F12, 0x002A},     /*  70003B68 */
+{0x0F12, 0x4939},     /*  70003B6A */
+{0x0F12, 0x2506},     /*  70003B6C */
+{0x0F12, 0x1D80},     /*  70003B6E */
+{0x0F12, 0xF000},     /*  70003B70 */
+{0x0F12, 0xF896},     /*  70003B72 */
+{0x0F12, 0x4835},     /*  70003B74 */
+{0x0F12, 0x002A},     /*  70003B76 */
+{0x0F12, 0x4936},     /*  70003B78 */
+{0x0F12, 0x2507},     /*  70003B7A */
+{0x0F12, 0x300C},     /*  70003B7C */
+{0x0F12, 0xF000},     /*  70003B7E */
+{0x0F12, 0xF88F},     /*  70003B80 */
+{0x0F12, 0x4832},     /*  70003B82 */
+{0x0F12, 0x002A},     /*  70003B84 */
+{0x0F12, 0x4934},     /*  70003B86 */
+{0x0F12, 0x2508},     /*  70003B88 */
+{0x0F12, 0x3010},     /*  70003B8A */
+{0x0F12, 0xF000},     /*  70003B8C */
+{0x0F12, 0xF888},     /*  70003B8E */
+{0x0F12, 0x002A},     /*  70003B90 */
+{0x0F12, 0x4932},     /*  70003B92 */
+{0x0F12, 0x4832},     /*  70003B94 */
+{0x0F12, 0x2509},     /*  70003B96 */
+{0x0F12, 0xF000},     /*  70003B98 */
+{0x0F12, 0xFC18},     /*  70003B9A */
+{0x0F12, 0x002A},     /*  70003B9C */
+{0x0F12, 0x4931},     /*  70003B9E */
+{0x0F12, 0x4831},     /*  70003BA0 */
+{0x0F12, 0x250A},     /*  70003BA2 */
+{0x0F12, 0xF000},     /*  70003BA4 */
+{0x0F12, 0xFC12},     /*  70003BA6 */
+{0x0F12, 0x002A},     /*  70003BA8 */
+{0x0F12, 0x4930},     /*  70003BAA */
+{0x0F12, 0x4830},     /*  70003BAC */
+{0x0F12, 0x250B},     /*  70003BAE */
+{0x0F12, 0xF000},     /*  70003BB0 */
+{0x0F12, 0xFC0C},     /*  70003BB2 */
+{0x0F12, 0x002A},     /*  70003BB4 */
+{0x0F12, 0x492F},     /*  70003BB6 */
+{0x0F12, 0x482F},     /*  70003BB8 */
+{0x0F12, 0x250C},     /*  70003BBA */
+{0x0F12, 0xF000},     /*  70003BBC */
+{0x0F12, 0xFC06},     /*  70003BBE */
+{0x0F12, 0x002A},     /*  70003BC0 */
+{0x0F12, 0x492E},     /*  70003BC2 */
+{0x0F12, 0x482E},     /*  70003BC4 */
+{0x0F12, 0x250D},     /*  70003BC6 */
+{0x0F12, 0xF000},     /*  70003BC8 */
+{0x0F12, 0xFC00},     /*  70003BCA */
+{0x0F12, 0x002A},     /*  70003BCC */
+{0x0F12, 0x492D},     /*  70003BCE */
+{0x0F12, 0x482D},     /*  70003BD0 */
+{0x0F12, 0x250E},     /*  70003BD2 */
+{0x0F12, 0xF000},     /*  70003BD4 */
+{0x0F12, 0xFBFA},     /*  70003BD6 */
+{0x0F12, 0x8626},     /*  70003BD8 */
+{0x0F12, 0x20FF},     /*  70003BDA */
+{0x0F12, 0x1C40},     /*  70003BDC */
+{0x0F12, 0x8660},     /*  70003BDE */
+{0x0F12, 0x482A},     /*  70003BE0 */
+{0x0F12, 0x64F8},     /*  70003BE2 */
+{0x0F12, 0x492A},     /*  70003BE4 */
+{0x0F12, 0x482B},     /*  70003BE6 */
+{0x0F12, 0x002A},     /*  70003BE8 */
+{0x0F12, 0x240F},     /*  70003BEA */
+{0x0F12, 0xF000},     /*  70003BEC */
+{0x0F12, 0xFBEE},     /*  70003BEE */
+{0x0F12, 0x4929},     /*  70003BF0 */
+{0x0F12, 0x482A},     /*  70003BF2 */
+{0x0F12, 0x0022},     /*  70003BF4 */
+{0x0F12, 0xF000},     /*  70003BF6 */
+{0x0F12, 0xFBE9},     /*  70003BF8 */
+{0x0F12, 0xBCF8},     /*  70003BFA */
+{0x0F12, 0xBC08},     /*  70003BFC */
+{0x0F12, 0x4718},     /*  70003BFE */
+{0x0F12, 0x017B},     /*  70003C00 */
+{0x0F12, 0x4EC2},     /*  70003C02 */
+{0x0F12, 0x237F},     /*  70003C04 */
+{0x0F12, 0x0000},     /*  70003C06 */
+{0x0F12, 0x1F90},     /*  70003C08 */
+{0x0F12, 0x7000},     /*  70003C0A */
+{0x0F12, 0x3CB9},     /*  70003C0C */
+{0x0F12, 0x7000},     /*  70003C0E */
+{0x0F12, 0xE38B},     /*  70003C10 */
+{0x0F12, 0x0000},     /*  70003C12 */
+{0x0F12, 0x3CF1},     /*  70003C14 */
+{0x0F12, 0x7000},     /*  70003C16 */
+{0x0F12, 0xC3B1},     /*  70003C18 */
+{0x0F12, 0x0000},     /*  70003C1A */
+{0x0F12, 0x4780},     /*  70003C1C */
+{0x0F12, 0x7000},     /*  70003C1E */
+{0x0F12, 0x3D4F},     /*  70003C20 */
+{0x0F12, 0x7000},     /*  70003C22 */
+{0x0F12, 0x0080},     /*  70003C24 */
+{0x0F12, 0x7000},     /*  70003C26 */
+{0x0F12, 0x3D8B},     /*  70003C28 */
+{0x0F12, 0x7000},     /*  70003C2A */
+{0x0F12, 0xB49D},     /*  70003C2C */
+{0x0F12, 0x0000},     /*  70003C2E */
+{0x0F12, 0x3E37},     /*  70003C30 */
+{0x0F12, 0x7000},     /*  70003C32 */
+{0x0F12, 0x3DEB},     /*  70003C34 */
+{0x0F12, 0x7000},     /*  70003C36 */
+{0x0F12, 0xFFFF},     /*  70003C38 */
+{0x0F12, 0x00FF},     /*  70003C3A */
+{0x0F12, 0x17E0},     /*  70003C3C */
+{0x0F12, 0x7000},     /*  70003C3E */
+{0x0F12, 0x3FB3},     /*  70003C40 */
+{0x0F12, 0x7000},     /*  70003C42 */
+{0x0F12, 0x053D},     /*  70003C44 */
+{0x0F12, 0x0000},     /*  70003C46 */
+{0x0F12, 0x0000},     /*  70003C48 */
+{0x0F12, 0x0A89},     /*  70003C4A */
+{0x0F12, 0x6CD2},     /*  70003C4C */
+{0x0F12, 0x0000},     /*  70003C4E */
+{0x0F12, 0x02C9},     /*  70003C50 */
+{0x0F12, 0x0000},     /*  70003C52 */
+{0x0F12, 0x0000},     /*  70003C54 */
+{0x0F12, 0x0A9A},     /*  70003C56 */
+{0x0F12, 0x0000},     /*  70003C58 */
+{0x0F12, 0x02D2},     /*  70003C5A */
+{0x0F12, 0x4001},     /*  70003C5C */
+{0x0F12, 0x7000},     /*  70003C5E */
+{0x0F12, 0x9E65},     /*  70003C60 */
+{0x0F12, 0x0000},     /*  70003C62 */
+{0x0F12, 0x4075},     /*  70003C64 */
+{0x0F12, 0x7000},     /*  70003C66 */
+{0x0F12, 0x7C49},     /*  70003C68 */
+{0x0F12, 0x0000},     /*  70003C6A */
+{0x0F12, 0x40E9},     /*  70003C6C */
+{0x0F12, 0x7000},     /*  70003C6E */
+{0x0F12, 0x7C63},     /*  70003C70 */
+{0x0F12, 0x0000},     /*  70003C72 */
+{0x0F12, 0x4105},     /*  70003C74 */
+{0x0F12, 0x7000},     /*  70003C76 */
+{0x0F12, 0x8F01},     /*  70003C78 */
+{0x0F12, 0x0000},     /*  70003C7A */
+{0x0F12, 0x41A7},     /*  70003C7C */
+{0x0F12, 0x7000},     /*  70003C7E */
+{0x0F12, 0x7F3F},     /*  70003C80 */
+{0x0F12, 0x0000},     /*  70003C82 */
+{0x0F12, 0x4235},     /*  70003C84 */
+{0x0F12, 0x7000},     /*  70003C86 */
+{0x0F12, 0x98C5},     /*  70003C88 */
+{0x0F12, 0x0000},     /*  70003C8A */
+{0x0F12, 0x42FB},     /*  70003C8C */
+{0x0F12, 0x7000},     /*  70003C8E */
+{0x0F12, 0x4351},     /*  70003C90 */
+{0x0F12, 0x7000},     /*  70003C92 */
+{0x0F12, 0xA70B},     /*  70003C94 */
+{0x0F12, 0x0000},     /*  70003C96 */
+{0x0F12, 0x4373},     /*  70003C98 */
+{0x0F12, 0x7000},     /*  70003C9A */
+{0x0F12, 0x400D},     /*  70003C9C */
+{0x0F12, 0x0000},     /*  70003C9E */
+{0x0F12, 0xB570},     /*  70003CA0 */
+{0x0F12, 0x000C},     /*  70003CA2 */
+{0x0F12, 0x0015},     /*  70003CA4 */
+{0x0F12, 0x0029},     /*  70003CA6 */
+{0x0F12, 0xF000},     /*  70003CA8 */
+{0x0F12, 0xFB98},     /*  70003CAA */
+{0x0F12, 0x49F8},     /*  70003CAC */
+{0x0F12, 0x00A8},     /*  70003CAE */
+{0x0F12, 0x500C},     /*  70003CB0 */
+{0x0F12, 0xBC70},     /*  70003CB2 */
+{0x0F12, 0xBC08},     /*  70003CB4 */
+{0x0F12, 0x4718},     /*  70003CB6 */
+{0x0F12, 0x6808},     /*  70003CB8 */
+{0x0F12, 0x0400},     /*  70003CBA */
+{0x0F12, 0x0C00},     /*  70003CBC */
+{0x0F12, 0x6849},     /*  70003CBE */
+{0x0F12, 0x0409},     /*  70003CC0 */
+{0x0F12, 0x0C09},     /*  70003CC2 */
+{0x0F12, 0x4AF3},     /*  70003CC4 */
+{0x0F12, 0x8992},     /*  70003CC6 */
+{0x0F12, 0x2A00},     /*  70003CC8 */
+{0x0F12, 0xD00D},     /*  70003CCA */
+{0x0F12, 0x2300},     /*  70003CCC */
+{0x0F12, 0x1A89},     /*  70003CCE */
+{0x0F12, 0xD400},     /*  70003CD0 */
+{0x0F12, 0x000B},     /*  70003CD2 */
+{0x0F12, 0x0419},     /*  70003CD4 */
+{0x0F12, 0x0C09},     /*  70003CD6 */
+{0x0F12, 0x23FF},     /*  70003CD8 */
+{0x0F12, 0x33C1},     /*  70003CDA */
+{0x0F12, 0x1810},     /*  70003CDC */
+{0x0F12, 0x4298},     /*  70003CDE */
+{0x0F12, 0xD800},     /*  70003CE0 */
+{0x0F12, 0x0003},     /*  70003CE2 */
+{0x0F12, 0x0418},     /*  70003CE4 */
+{0x0F12, 0x0C00},     /*  70003CE6 */
+{0x0F12, 0x4AEB},     /*  70003CE8 */
+{0x0F12, 0x8150},     /*  70003CEA */
+{0x0F12, 0x8191},     /*  70003CEC */
+{0x0F12, 0x4770},     /*  70003CEE */
+{0x0F12, 0xB5F3},     /*  70003CF0 */
+{0x0F12, 0x0004},     /*  70003CF2 */
+{0x0F12, 0xB081},     /*  70003CF4 */
+{0x0F12, 0x9802},     /*  70003CF6 */
+{0x0F12, 0x6800},     /*  70003CF8 */
+{0x0F12, 0x0600},     /*  70003CFA */
+{0x0F12, 0x0E00},     /*  70003CFC */
+{0x0F12, 0x2201},     /*  70003CFE */
+{0x0F12, 0x0015},     /*  70003D00 */
+{0x0F12, 0x0021},     /*  70003D02 */
+{0x0F12, 0x3910},     /*  70003D04 */
+{0x0F12, 0x408A},     /*  70003D06 */
+{0x0F12, 0x40A5},     /*  70003D08 */
+{0x0F12, 0x4FE4},     /*  70003D0A */
+{0x0F12, 0x0016},     /*  70003D0C */
+{0x0F12, 0x2C10},     /*  70003D0E */
+{0x0F12, 0xDA03},     /*  70003D10 */
+{0x0F12, 0x8839},     /*  70003D12 */
+{0x0F12, 0x43A9},     /*  70003D14 */
+{0x0F12, 0x8039},     /*  70003D16 */
+{0x0F12, 0xE002},     /*  70003D18 */
+{0x0F12, 0x8879},     /*  70003D1A */
+{0x0F12, 0x43B1},     /*  70003D1C */
+{0x0F12, 0x8079},     /*  70003D1E */
+{0x0F12, 0xF000},     /*  70003D20 */
+{0x0F12, 0xFB64},     /*  70003D22 */
+{0x0F12, 0x2C10},     /*  70003D24 */
+{0x0F12, 0xDA03},     /*  70003D26 */
+{0x0F12, 0x8839},     /*  70003D28 */
+{0x0F12, 0x4329},     /*  70003D2A */
+{0x0F12, 0x8039},     /*  70003D2C */
+{0x0F12, 0xE002},     /*  70003D2E */
+{0x0F12, 0x8879},     /*  70003D30 */
+{0x0F12, 0x4331},     /*  70003D32 */
+{0x0F12, 0x8079},     /*  70003D34 */
+{0x0F12, 0x49DA},     /*  70003D36 */
+{0x0F12, 0x8809},     /*  70003D38 */
+{0x0F12, 0x2900},     /*  70003D3A */
+{0x0F12, 0xD102},     /*  70003D3C */
+{0x0F12, 0xF000},     /*  70003D3E */
+{0x0F12, 0xFB5D},     /*  70003D40 */
+{0x0F12, 0x2000},     /*  70003D42 */
+{0x0F12, 0x9902},     /*  70003D44 */
+{0x0F12, 0x6008},     /*  70003D46 */
+{0x0F12, 0xBCFE},     /*  70003D48 */
+{0x0F12, 0xBC08},     /*  70003D4A */
+{0x0F12, 0x4718},     /*  70003D4C */
+{0x0F12, 0xB538},     /*  70003D4E */
+{0x0F12, 0x9C04},     /*  70003D50 */
+{0x0F12, 0x0015},     /*  70003D52 */
+{0x0F12, 0x002A},     /*  70003D54 */
+{0x0F12, 0x9400},     /*  70003D56 */
+{0x0F12, 0xF000},     /*  70003D58 */
+{0x0F12, 0xFB58},     /*  70003D5A */
+{0x0F12, 0x4AD1},     /*  70003D5C */
+{0x0F12, 0x8811},     /*  70003D5E */
+{0x0F12, 0x2900},     /*  70003D60 */
+{0x0F12, 0xD00F},     /*  70003D62 */
+{0x0F12, 0x8820},     /*  70003D64 */
+{0x0F12, 0x4281},     /*  70003D66 */
+{0x0F12, 0xD20C},     /*  70003D68 */
+{0x0F12, 0x8861},     /*  70003D6A */
+{0x0F12, 0x8853},     /*  70003D6C */
+{0x0F12, 0x4299},     /*  70003D6E */
+{0x0F12, 0xD200},     /*  70003D70 */
+{0x0F12, 0x1E40},     /*  70003D72 */
+{0x0F12, 0x0400},     /*  70003D74 */
+{0x0F12, 0x0C00},     /*  70003D76 */
+{0x0F12, 0x8020},     /*  70003D78 */
+{0x0F12, 0x8851},     /*  70003D7A */
+{0x0F12, 0x8061},     /*  70003D7C */
+{0x0F12, 0x4368},     /*  70003D7E */
+{0x0F12, 0x1840},     /*  70003D80 */
+{0x0F12, 0x6060},     /*  70003D82 */
+{0x0F12, 0xBC38},     /*  70003D84 */
+{0x0F12, 0xBC08},     /*  70003D86 */
+{0x0F12, 0x4718},     /*  70003D88 */
+{0x0F12, 0xB5F8},     /*  70003D8A */
+{0x0F12, 0x0004},     /*  70003D8C */
+{0x0F12, 0x6808},     /*  70003D8E */
+{0x0F12, 0x0400},     /*  70003D90 */
+{0x0F12, 0x0C00},     /*  70003D92 */
+{0x0F12, 0x2201},     /*  70003D94 */
+{0x0F12, 0x0015},     /*  70003D96 */
+{0x0F12, 0x0021},     /*  70003D98 */
+{0x0F12, 0x3910},     /*  70003D9A */
+{0x0F12, 0x408A},     /*  70003D9C */
+{0x0F12, 0x40A5},     /*  70003D9E */
+{0x0F12, 0x4FBE},     /*  70003DA0 */
+{0x0F12, 0x0016},     /*  70003DA2 */
+{0x0F12, 0x2C10},     /*  70003DA4 */
+{0x0F12, 0xDA03},     /*  70003DA6 */
+{0x0F12, 0x8839},     /*  70003DA8 */
+{0x0F12, 0x43A9},     /*  70003DAA */
+{0x0F12, 0x8039},     /*  70003DAC */
+{0x0F12, 0xE002},     /*  70003DAE */
+{0x0F12, 0x8879},     /*  70003DB0 */
+{0x0F12, 0x43B1},     /*  70003DB2 */
+{0x0F12, 0x8079},     /*  70003DB4 */
+{0x0F12, 0xF000},     /*  70003DB6 */
+{0x0F12, 0xFB31},     /*  70003DB8 */
+{0x0F12, 0x2C10},     /*  70003DBA */
+{0x0F12, 0xDA03},     /*  70003DBC */
+{0x0F12, 0x8838},     /*  70003DBE */
+{0x0F12, 0x4328},     /*  70003DC0 */
+{0x0F12, 0x8038},     /*  70003DC2 */
+{0x0F12, 0xE002},     /*  70003DC4 */
+{0x0F12, 0x8878},     /*  70003DC6 */
+{0x0F12, 0x4330},     /*  70003DC8 */
+{0x0F12, 0x8078},     /*  70003DCA */
+{0x0F12, 0x48B6},     /*  70003DCC */
+{0x0F12, 0x8800},     /*  70003DCE */
+{0x0F12, 0x0400},     /*  70003DD0 */
+{0x0F12, 0xD507},     /*  70003DD2 */
+{0x0F12, 0x4BB5},     /*  70003DD4 */
+{0x0F12, 0x7819},     /*  70003DD6 */
+{0x0F12, 0x4AB5},     /*  70003DD8 */
+{0x0F12, 0x7810},     /*  70003DDA */
+{0x0F12, 0x7018},     /*  70003DDC */
+{0x0F12, 0x7011},     /*  70003DDE */
+{0x0F12, 0x49B4},     /*  70003DE0 */
+{0x0F12, 0x8188},     /*  70003DE2 */
+{0x0F12, 0xBCF8},     /*  70003DE4 */
+{0x0F12, 0xBC08},     /*  70003DE6 */
+{0x0F12, 0x4718},     /*  70003DE8 */
+{0x0F12, 0xB538},     /*  70003DEA */
+{0x0F12, 0x48B2},     /*  70003DEC */
+{0x0F12, 0x4669},     /*  70003DEE */
+{0x0F12, 0xF000},     /*  70003DF0 */
+{0x0F12, 0xFB1C},     /*  70003DF2 */
+{0x0F12, 0x48B1},     /*  70003DF4 */
+{0x0F12, 0x49B0},     /*  70003DF6 */
+{0x0F12, 0x69C2},     /*  70003DF8 */
+{0x0F12, 0x2400},     /*  70003DFA */
+{0x0F12, 0x31A8},     /*  70003DFC */
+{0x0F12, 0x2A00},     /*  70003DFE */
+{0x0F12, 0xD008},     /*  70003E00 */
+{0x0F12, 0x61C4},     /*  70003E02 */
+{0x0F12, 0x684A},     /*  70003E04 */
+{0x0F12, 0x6242},     /*  70003E06 */
+{0x0F12, 0x6282},     /*  70003E08 */
+{0x0F12, 0x466B},     /*  70003E0A */
+{0x0F12, 0x881A},     /*  70003E0C */
+{0x0F12, 0x6302},     /*  70003E0E */
+{0x0F12, 0x885A},     /*  70003E10 */
+{0x0F12, 0x6342},     /*  70003E12 */
+{0x0F12, 0x6A02},     /*  70003E14 */
+{0x0F12, 0x2A00},     /*  70003E16 */
+{0x0F12, 0xD00A},     /*  70003E18 */
+{0x0F12, 0x6204},     /*  70003E1A */
+{0x0F12, 0x6849},     /*  70003E1C */
+{0x0F12, 0x6281},     /*  70003E1E */
+{0x0F12, 0x466B},     /*  70003E20 */
+{0x0F12, 0x8819},     /*  70003E22 */
+{0x0F12, 0x6301},     /*  70003E24 */
+{0x0F12, 0x8859},     /*  70003E26 */
+{0x0F12, 0x6341},     /*  70003E28 */
+{0x0F12, 0x49A5},     /*  70003E2A */
+{0x0F12, 0x88C9},     /*  70003E2C */
+{0x0F12, 0x63C1},     /*  70003E2E */
+{0x0F12, 0xF000},     /*  70003E30 */
+{0x0F12, 0xFB04},     /*  70003E32 */
+{0x0F12, 0xE7A6},     /*  70003E34 */
+{0x0F12, 0xB5F0},     /*  70003E36 */
+{0x0F12, 0xB08B},     /*  70003E38 */
+{0x0F12, 0x20FF},     /*  70003E3A */
+{0x0F12, 0x1C40},     /*  70003E3C */
+{0x0F12, 0x49A1},     /*  70003E3E */
+{0x0F12, 0x89CC},     /*  70003E40 */
+{0x0F12, 0x4E9E},     /*  70003E42 */
+{0x0F12, 0x6AB1},     /*  70003E44 */
+{0x0F12, 0x4284},     /*  70003E46 */
+{0x0F12, 0xD101},     /*  70003E48 */
+{0x0F12, 0x489F},     /*  70003E4A */
+{0x0F12, 0x6081},     /*  70003E4C */
+{0x0F12, 0x6A70},     /*  70003E4E */
+{0x0F12, 0x0200},     /*  70003E50 */
+{0x0F12, 0xF000},     /*  70003E52 */
+{0x0F12, 0xFAFB},     /*  70003E54 */
+{0x0F12, 0x0400},     /*  70003E56 */
+{0x0F12, 0x0C00},     /*  70003E58 */
+{0x0F12, 0x4A96},     /*  70003E5A */
+{0x0F12, 0x8A11},     /*  70003E5C */
+{0x0F12, 0x9109},     /*  70003E5E */
+{0x0F12, 0x2101},     /*  70003E60 */
+{0x0F12, 0x0349},     /*  70003E62 */
+{0x0F12, 0x4288},     /*  70003E64 */
+{0x0F12, 0xD200},     /*  70003E66 */
+{0x0F12, 0x0001},     /*  70003E68 */
+{0x0F12, 0x4A92},     /*  70003E6A */
+{0x0F12, 0x8211},     /*  70003E6C */
+{0x0F12, 0x4D97},     /*  70003E6E */
+{0x0F12, 0x8829},     /*  70003E70 */
+{0x0F12, 0x9108},     /*  70003E72 */
+{0x0F12, 0x4A8B},     /*  70003E74 */
+{0x0F12, 0x2303},     /*  70003E76 */
+{0x0F12, 0x3222},     /*  70003E78 */
+{0x0F12, 0x1F91},     /*  70003E7A */
+{0x0F12, 0xF000},     /*  70003E7C */
+{0x0F12, 0xFAEC},     /*  70003E7E */
+{0x0F12, 0x8028},     /*  70003E80 */
+{0x0F12, 0x488E},     /*  70003E82 */
+{0x0F12, 0x4987},     /*  70003E84 */
+{0x0F12, 0x6BC2},     /*  70003E86 */
+{0x0F12, 0x6AC0},     /*  70003E88 */
+{0x0F12, 0x4282},     /*  70003E8A */
+{0x0F12, 0xD201},     /*  70003E8C */
+{0x0F12, 0x8CC8},     /*  70003E8E */
+{0x0F12, 0x8028},     /*  70003E90 */
+{0x0F12, 0x88E8},     /*  70003E92 */
+{0x0F12, 0x9007},     /*  70003E94 */
+{0x0F12, 0x2240},     /*  70003E96 */
+{0x0F12, 0x4310},     /*  70003E98 */
+{0x0F12, 0x80E8},     /*  70003E9A */
+{0x0F12, 0x2000},     /*  70003E9C */
+{0x0F12, 0x0041},     /*  70003E9E */
+{0x0F12, 0x194B},     /*  70003EA0 */
+{0x0F12, 0x001E},     /*  70003EA2 */
+{0x0F12, 0x3680},     /*  70003EA4 */
+{0x0F12, 0x8BB2},     /*  70003EA6 */
+{0x0F12, 0xAF04},     /*  70003EA8 */
+{0x0F12, 0x527A},     /*  70003EAA */
+{0x0F12, 0x4A7D},     /*  70003EAC */
+{0x0F12, 0x188A},     /*  70003EAE */
+{0x0F12, 0x8897},     /*  70003EB0 */
+{0x0F12, 0x83B7},     /*  70003EB2 */
+{0x0F12, 0x33A0},     /*  70003EB4 */
+{0x0F12, 0x891F},     /*  70003EB6 */
+{0x0F12, 0xAE01},     /*  70003EB8 */
+{0x0F12, 0x5277},     /*  70003EBA */
+{0x0F12, 0x8A11},     /*  70003EBC */
+{0x0F12, 0x8119},     /*  70003EBE */
+{0x0F12, 0x1C40},     /*  70003EC0 */
+{0x0F12, 0x0400},     /*  70003EC2 */
+{0x0F12, 0x0C00},     /*  70003EC4 */
+{0x0F12, 0x2806},     /*  70003EC6 */
+{0x0F12, 0xD3E9},     /*  70003EC8 */
+{0x0F12, 0xF000},     /*  70003ECA */
+{0x0F12, 0xFACD},     /*  70003ECC */
+{0x0F12, 0xF000},     /*  70003ECE */
+{0x0F12, 0xFAD3},     /*  70003ED0 */
+{0x0F12, 0x4F79},     /*  70003ED2 */
+{0x0F12, 0x37A8},     /*  70003ED4 */
+{0x0F12, 0x2800},     /*  70003ED6 */
+{0x0F12, 0xD10A},     /*  70003ED8 */
+{0x0F12, 0x1FE0},     /*  70003EDA */
+{0x0F12, 0x38FD},     /*  70003EDC */
+{0x0F12, 0xD001},     /*  70003EDE */
+{0x0F12, 0x1CC0},     /*  70003EE0 */
+{0x0F12, 0xD105},     /*  70003EE2 */
+{0x0F12, 0x4874},     /*  70003EE4 */
+{0x0F12, 0x8829},     /*  70003EE6 */
+{0x0F12, 0x3818},     /*  70003EE8 */
+{0x0F12, 0x6840},     /*  70003EEA */
+{0x0F12, 0x4348},     /*  70003EEC */
+{0x0F12, 0x6078},     /*  70003EEE */
+{0x0F12, 0x4972},     /*  70003EF0 */
+{0x0F12, 0x6878},     /*  70003EF2 */
+{0x0F12, 0x6B89},     /*  70003EF4 */
+{0x0F12, 0x4288},     /*  70003EF6 */
+{0x0F12, 0xD300},     /*  70003EF8 */
+{0x0F12, 0x0008},     /*  70003EFA */
+{0x0F12, 0x6078},     /*  70003EFC */
+{0x0F12, 0x2000},     /*  70003EFE */
+{0x0F12, 0x0041},     /*  70003F00 */
+{0x0F12, 0xAA04},     /*  70003F02 */
+{0x0F12, 0x5A53},     /*  70003F04 */
+{0x0F12, 0x194A},     /*  70003F06 */
+{0x0F12, 0x269C},     /*  70003F08 */
+{0x0F12, 0x52B3},     /*  70003F0A */
+{0x0F12, 0xAB01},     /*  70003F0C */
+{0x0F12, 0x5A59},     /*  70003F0E */
+{0x0F12, 0x32A0},     /*  70003F10 */
+{0x0F12, 0x8111},     /*  70003F12 */
+{0x0F12, 0x1C40},     /*  70003F14 */
+{0x0F12, 0x0400},     /*  70003F16 */
+{0x0F12, 0x0C00},     /*  70003F18 */
+{0x0F12, 0x2806},     /*  70003F1A */
+{0x0F12, 0xD3F0},     /*  70003F1C */
+{0x0F12, 0x4965},     /*  70003F1E */
+{0x0F12, 0x9809},     /*  70003F20 */
+{0x0F12, 0x8208},     /*  70003F22 */
+{0x0F12, 0x9808},     /*  70003F24 */
+{0x0F12, 0x8028},     /*  70003F26 */
+{0x0F12, 0x9807},     /*  70003F28 */
+{0x0F12, 0x80E8},     /*  70003F2A */
+{0x0F12, 0x1FE0},     /*  70003F2C */
+{0x0F12, 0x38FD},     /*  70003F2E */
+{0x0F12, 0xD13B},     /*  70003F30 */
+{0x0F12, 0x4D64},     /*  70003F32 */
+{0x0F12, 0x89E8},     /*  70003F34 */
+{0x0F12, 0x1FC1},     /*  70003F36 */
+{0x0F12, 0x39FF},     /*  70003F38 */
+{0x0F12, 0xD136},     /*  70003F3A */
+{0x0F12, 0x4C5F},     /*  70003F3C */
+{0x0F12, 0x8AE0},     /*  70003F3E */
+{0x0F12, 0xF000},     /*  70003F40 */
+{0x0F12, 0xFAA2},     /*  70003F42 */
+{0x0F12, 0x0006},     /*  70003F44 */
+{0x0F12, 0x8B20},     /*  70003F46 */
+{0x0F12, 0xF000},     /*  70003F48 */
+{0x0F12, 0xFAA6},     /*  70003F4A */
+{0x0F12, 0x9000},     /*  70003F4C */
+{0x0F12, 0x6AA1},     /*  70003F4E */
+{0x0F12, 0x6878},     /*  70003F50 */
+{0x0F12, 0x1809},     /*  70003F52 */
+{0x0F12, 0x0200},     /*  70003F54 */
+{0x0F12, 0xF000},     /*  70003F56 */
+{0x0F12, 0xFA79},     /*  70003F58 */
+{0x0F12, 0x0400},     /*  70003F5A */
+{0x0F12, 0x0C00},     /*  70003F5C */
+{0x0F12, 0x0022},     /*  70003F5E */
+{0x0F12, 0x3246},     /*  70003F60 */
+{0x0F12, 0x0011},     /*  70003F62 */
+{0x0F12, 0x310A},     /*  70003F64 */
+{0x0F12, 0x2305},     /*  70003F66 */
+{0x0F12, 0xF000},     /*  70003F68 */
+{0x0F12, 0xFA76},     /*  70003F6A */
+{0x0F12, 0x66E8},     /*  70003F6C */
+{0x0F12, 0x6B23},     /*  70003F6E */
+{0x0F12, 0x0002},     /*  70003F70 */
+{0x0F12, 0x0031},     /*  70003F72 */
+{0x0F12, 0x0018},     /*  70003F74 */
+{0x0F12, 0xF000},     /*  70003F76 */
+{0x0F12, 0xFA97},     /*  70003F78 */
+{0x0F12, 0x466B},     /*  70003F7A */
+{0x0F12, 0x8518},     /*  70003F7C */
+{0x0F12, 0x6EEA},     /*  70003F7E */
+{0x0F12, 0x6B60},     /*  70003F80 */
+{0x0F12, 0x9900},     /*  70003F82 */
+{0x0F12, 0xF000},     /*  70003F84 */
+{0x0F12, 0xFA90},     /*  70003F86 */
+{0x0F12, 0x466B},     /*  70003F88 */
+{0x0F12, 0x8558},     /*  70003F8A */
+{0x0F12, 0x0029},     /*  70003F8C */
+{0x0F12, 0x980A},     /*  70003F8E */
+{0x0F12, 0x3170},     /*  70003F90 */
+{0x0F12, 0xF000},     /*  70003F92 */
+{0x0F12, 0xFA91},     /*  70003F94 */
+{0x0F12, 0x0028},     /*  70003F96 */
+{0x0F12, 0x3060},     /*  70003F98 */
+{0x0F12, 0x8A02},     /*  70003F9A */
+{0x0F12, 0x4946},     /*  70003F9C */
+{0x0F12, 0x3128},     /*  70003F9E */
+{0x0F12, 0x808A},     /*  70003FA0 */
+{0x0F12, 0x8A42},     /*  70003FA2 */
+{0x0F12, 0x80CA},     /*  70003FA4 */
+{0x0F12, 0x8A80},     /*  70003FA6 */
+{0x0F12, 0x8108},     /*  70003FA8 */
+{0x0F12, 0xB00B},     /*  70003FAA */
+{0x0F12, 0xBCF0},     /*  70003FAC */
+{0x0F12, 0xBC08},     /*  70003FAE */
+{0x0F12, 0x4718},     /*  70003FB0 */
+{0x0F12, 0xB570},     /*  70003FB2 */
+{0x0F12, 0x2400},     /*  70003FB4 */
+{0x0F12, 0x4D46},     /*  70003FB6 */
+{0x0F12, 0x4846},     /*  70003FB8 */
+{0x0F12, 0x8881},     /*  70003FBA */
+{0x0F12, 0x4846},     /*  70003FBC */
+{0x0F12, 0x8041},     /*  70003FBE */
+{0x0F12, 0x2101},     /*  70003FC0 */
+{0x0F12, 0x8001},     /*  70003FC2 */
+{0x0F12, 0xF000},     /*  70003FC4 */
+{0x0F12, 0xFA80},     /*  70003FC6 */
+{0x0F12, 0x4842},     /*  70003FC8 */
+{0x0F12, 0x3820},     /*  70003FCA */
+{0x0F12, 0x8BC0},     /*  70003FCC */
+{0x0F12, 0xF000},     /*  70003FCE */
+{0x0F12, 0xFA83},     /*  70003FD0 */
+{0x0F12, 0x4B42},     /*  70003FD2 */
+{0x0F12, 0x220D},     /*  70003FD4 */
+{0x0F12, 0x0712},     /*  70003FD6 */
+{0x0F12, 0x18A8},     /*  70003FD8 */
+{0x0F12, 0x8806},     /*  70003FDA */
+{0x0F12, 0x00E1},     /*  70003FDC */
+{0x0F12, 0x18C9},     /*  70003FDE */
+{0x0F12, 0x81CE},     /*  70003FE0 */
+{0x0F12, 0x8846},     /*  70003FE2 */
+{0x0F12, 0x818E},     /*  70003FE4 */
+{0x0F12, 0x8886},     /*  70003FE6 */
+{0x0F12, 0x824E},     /*  70003FE8 */
+{0x0F12, 0x88C0},     /*  70003FEA */
+{0x0F12, 0x8208},     /*  70003FEC */
+{0x0F12, 0x3508},     /*  70003FEE */
+{0x0F12, 0x042D},     /*  70003FF0 */
+{0x0F12, 0x0C2D},     /*  70003FF2 */
+{0x0F12, 0x1C64},     /*  70003FF4 */
+{0x0F12, 0x0424},     /*  70003FF6 */
+{0x0F12, 0x0C24},     /*  70003FF8 */
+{0x0F12, 0x2C07},     /*  70003FFA */
+{0x0F12, 0xD3EC},     /*  70003FFC */
+{0x0F12, 0xE658},     /*  70003FFE */
+{0x0F12, 0xB510},     /*  70004000 */
+{0x0F12, 0x4834},     /*  70004002 */
+{0x0F12, 0x4C34},     /*  70004004 */
+{0x0F12, 0x88C0},     /*  70004006 */
+{0x0F12, 0x8060},     /*  70004008 */
+{0x0F12, 0x2001},     /*  7000400A */
+{0x0F12, 0x8020},     /*  7000400C */
+{0x0F12, 0x4831},     /*  7000400E */
+{0x0F12, 0x3820},     /*  70004010 */
+{0x0F12, 0x8BC0},     /*  70004012 */
+{0x0F12, 0xF000},     /*  70004014 */
+{0x0F12, 0xFA60},     /*  70004016 */
+{0x0F12, 0x88E0},     /*  70004018 */
+{0x0F12, 0x4A31},     /*  7000401A */
+{0x0F12, 0x2800},     /*  7000401C */
+{0x0F12, 0xD003},     /*  7000401E */
+{0x0F12, 0x4930},     /*  70004020 */
+{0x0F12, 0x8849},     /*  70004022 */
+{0x0F12, 0x2900},     /*  70004024 */
+{0x0F12, 0xD009},     /*  70004026 */
+{0x0F12, 0x2001},     /*  70004028 */
+{0x0F12, 0x03C0},     /*  7000402A */
+{0x0F12, 0x8050},     /*  7000402C */
+{0x0F12, 0x80D0},     /*  7000402E */
+{0x0F12, 0x2000},     /*  70004030 */
+{0x0F12, 0x8090},     /*  70004032 */
+{0x0F12, 0x8110},     /*  70004034 */
+{0x0F12, 0xBC10},     /*  70004036 */
+{0x0F12, 0xBC08},     /*  70004038 */
+{0x0F12, 0x4718},     /*  7000403A */
+{0x0F12, 0x8050},     /*  7000403C */
+{0x0F12, 0x8920},     /*  7000403E */
+{0x0F12, 0x80D0},     /*  70004040 */
+{0x0F12, 0x8960},     /*  70004042 */
+{0x0F12, 0x0400},     /*  70004044 */
+{0x0F12, 0x1400},     /*  70004046 */
+{0x0F12, 0x8090},     /*  70004048 */
+{0x0F12, 0x89A1},     /*  7000404A */
+{0x0F12, 0x0409},     /*  7000404C */
+{0x0F12, 0x1409},     /*  7000404E */
+{0x0F12, 0x8111},     /*  70004050 */
+{0x0F12, 0x89E3},     /*  70004052 */
+{0x0F12, 0x8A24},     /*  70004054 */
+{0x0F12, 0x2B00},     /*  70004056 */
+{0x0F12, 0xD104},     /*  70004058 */
+{0x0F12, 0x17C3},     /*  7000405A */
+{0x0F12, 0x0F5B},     /*  7000405C */
+{0x0F12, 0x1818},     /*  7000405E */
+{0x0F12, 0x10C0},     /*  70004060 */
+{0x0F12, 0x8090},     /*  70004062 */
+{0x0F12, 0x2C00},     /*  70004064 */
+{0x0F12, 0xD1E6},     /*  70004066 */
+{0x0F12, 0x17C8},     /*  70004068 */
+{0x0F12, 0x0F40},     /*  7000406A */
+{0x0F12, 0x1840},     /*  7000406C */
+{0x0F12, 0x10C0},     /*  7000406E */
+{0x0F12, 0x8110},     /*  70004070 */
+{0x0F12, 0xE7E0},     /*  70004072 */
+{0x0F12, 0xB510},     /*  70004074 */
+{0x0F12, 0x000C},     /*  70004076 */
+{0x0F12, 0x4919},     /*  70004078 */
+{0x0F12, 0x2204},     /*  7000407A */
+{0x0F12, 0x6820},     /*  7000407C */
+{0x0F12, 0x5E8A},     /*  7000407E */
+{0x0F12, 0x0140},     /*  70004080 */
+{0x0F12, 0x1A80},     /*  70004082 */
+{0x0F12, 0x0280},     /*  70004084 */
+{0x0F12, 0x8849},     /*  70004086 */
+{0x0F12, 0xF000},     /*  70004088 */
+{0x0F12, 0xFA2E},     /*  7000408A */
+{0x0F12, 0x6020},     /*  7000408C */
+{0x0F12, 0xE7D2},     /*  7000408E */
+{0x0F12, 0x38D4},     /*  70004090 */
+{0x0F12, 0x7000},     /*  70004092 */
+{0x0F12, 0x17D0},     /*  70004094 */
+{0x0F12, 0x7000},     /*  70004096 */
+{0x0F12, 0x5000},     /*  70004098 */
+{0x0F12, 0xD000},     /*  7000409A */
+{0x0F12, 0x1100},     /*  7000409C */
+{0x0F12, 0xD000},     /*  7000409E */
+{0x0F12, 0x171A},     /*  700040A0 */
+{0x0F12, 0x7000},     /*  700040A2 */
+{0x0F12, 0x4780},     /*  700040A4 */
+{0x0F12, 0x7000},     /*  700040A6 */
+{0x0F12, 0x2FCA},     /*  700040A8 */
+{0x0F12, 0x7000},     /*  700040AA */
+{0x0F12, 0x2FC5},     /*  700040AC */
+{0x0F12, 0x7000},     /*  700040AE */
+{0x0F12, 0x2FC6},     /*  700040B0 */
+{0x0F12, 0x7000},     /*  700040B2 */
+{0x0F12, 0x2ED8},     /*  700040B4 */
+{0x0F12, 0x7000},     /*  700040B6 */
+{0x0F12, 0x2BD0},     /*  700040B8 */
+{0x0F12, 0x7000},     /*  700040BA */
+{0x0F12, 0x17E0},     /*  700040BC */
+{0x0F12, 0x7000},     /*  700040BE */
+{0x0F12, 0x2DE8},     /*  700040C0 */
+{0x0F12, 0x7000},     /*  700040C2 */
+{0x0F12, 0x37E0},     /*  700040C4 */
+{0x0F12, 0x7000},     /*  700040C6 */
+{0x0F12, 0x210C},     /*  700040C8 */
+{0x0F12, 0x7000},     /*  700040CA */
+{0x0F12, 0x1484},     /*  700040CC */
+{0x0F12, 0x7000},     /*  700040CE */
+{0x0F12, 0xA006},     /*  700040D0 */
+{0x0F12, 0x0000},     /*  700040D2 */
+{0x0F12, 0x0724},     /*  700040D4 */
+{0x0F12, 0x7000},     /*  700040D6 */
+{0x0F12, 0xA000},     /*  700040D8 */
+{0x0F12, 0xD000},     /*  700040DA */
+{0x0F12, 0x2270},     /*  700040DC */
+{0x0F12, 0x7000},     /*  700040DE */
+{0x0F12, 0x2558},     /*  700040E0 */
+{0x0F12, 0x7000},     /*  700040E2 */
+{0x0F12, 0x146C},     /*  700040E4 */
+{0x0F12, 0x7000},     /*  700040E6 */
+{0x0F12, 0xB510},     /*  700040E8 */
+{0x0F12, 0x000C},     /*  700040EA */
+{0x0F12, 0x49AC},     /*  700040EC */
+{0x0F12, 0x2208},     /*  700040EE */
+{0x0F12, 0x6820},     /*  700040F0 */
+{0x0F12, 0x5E8A},     /*  700040F2 */
+{0x0F12, 0x0140},     /*  700040F4 */
+{0x0F12, 0x1A80},     /*  700040F6 */
+{0x0F12, 0x0280},     /*  700040F8 */
+{0x0F12, 0x88C9},     /*  700040FA */
+{0x0F12, 0xF000},     /*  700040FC */
+{0x0F12, 0xF9F4},     /*  700040FE */
+{0x0F12, 0x6020},     /*  70004100 */
+{0x0F12, 0xE798},     /*  70004102 */
+{0x0F12, 0xB5FE},     /*  70004104 */
+{0x0F12, 0x000C},     /*  70004106 */
+{0x0F12, 0x6825},     /*  70004108 */
+{0x0F12, 0x6866},     /*  7000410A */
+{0x0F12, 0x68A0},     /*  7000410C */
+{0x0F12, 0x9001},     /*  7000410E */
+{0x0F12, 0x68E7},     /*  70004110 */
+{0x0F12, 0x1BA8},     /*  70004112 */
+{0x0F12, 0x42B5},     /*  70004114 */
+{0x0F12, 0xDA00},     /*  70004116 */
+{0x0F12, 0x1B70},     /*  70004118 */
+{0x0F12, 0x9000},     /*  7000411A */
+{0x0F12, 0x49A0},     /*  7000411C */
+{0x0F12, 0x48A1},     /*  7000411E */
+{0x0F12, 0x884A},     /*  70004120 */
+{0x0F12, 0x8843},     /*  70004122 */
+{0x0F12, 0x435A},     /*  70004124 */
+{0x0F12, 0x2304},     /*  70004126 */
+{0x0F12, 0x5ECB},     /*  70004128 */
+{0x0F12, 0x0A92},     /*  7000412A */
+{0x0F12, 0x18D2},     /*  7000412C */
+{0x0F12, 0x02D2},     /*  7000412E */
+{0x0F12, 0x0C12},     /*  70004130 */
+{0x0F12, 0x88CB},     /*  70004132 */
+{0x0F12, 0x8880},     /*  70004134 */
+{0x0F12, 0x4343},     /*  70004136 */
+{0x0F12, 0x0A98},     /*  70004138 */
+{0x0F12, 0x2308},     /*  7000413A */
+{0x0F12, 0x5ECB},     /*  7000413C */
+{0x0F12, 0x18C0},     /*  7000413E */
+{0x0F12, 0x02C0},     /*  70004140 */
+{0x0F12, 0x0C00},     /*  70004142 */
+{0x0F12, 0x0411},     /*  70004144 */
+{0x0F12, 0x0400},     /*  70004146 */
+{0x0F12, 0x1409},     /*  70004148 */
+{0x0F12, 0x1400},     /*  7000414A */
+{0x0F12, 0x1A08},     /*  7000414C */
+{0x0F12, 0x4995},     /*  7000414E */
+{0x0F12, 0x39E0},     /*  70004150 */
+{0x0F12, 0x6148},     /*  70004152 */
+{0x0F12, 0x9801},     /*  70004154 */
+{0x0F12, 0x3040},     /*  70004156 */
+{0x0F12, 0x7880},     /*  70004158 */
+{0x0F12, 0x2800},     /*  7000415A */
+{0x0F12, 0xD103},     /*  7000415C */
+{0x0F12, 0x9801},     /*  7000415E */
+{0x0F12, 0x0029},     /*  70004160 */
+{0x0F12, 0xF000},     /*  70004162 */
+{0x0F12, 0xF9C7},     /*  70004164 */
+{0x0F12, 0x8839},     /*  70004166 */
+{0x0F12, 0x9800},     /*  70004168 */
+{0x0F12, 0x4281},     /*  7000416A */
+{0x0F12, 0xD814},     /*  7000416C */
+{0x0F12, 0x8879},     /*  7000416E */
+{0x0F12, 0x9800},     /*  70004170 */
+{0x0F12, 0x4281},     /*  70004172 */
+{0x0F12, 0xD20C},     /*  70004174 */
+{0x0F12, 0x9801},     /*  70004176 */
+{0x0F12, 0x0029},     /*  70004178 */
+{0x0F12, 0xF000},     /*  7000417A */
+{0x0F12, 0xF9C3},     /*  7000417C */
+{0x0F12, 0x9801},     /*  7000417E */
+{0x0F12, 0x0029},     /*  70004180 */
+{0x0F12, 0xF000},     /*  70004182 */
+{0x0F12, 0xF9BF},     /*  70004184 */
+{0x0F12, 0x9801},     /*  70004186 */
+{0x0F12, 0x0029},     /*  70004188 */
+{0x0F12, 0xF000},     /*  7000418A */
+{0x0F12, 0xF9BB},     /*  7000418C */
+{0x0F12, 0xE003},     /*  7000418E */
+{0x0F12, 0x9801},     /*  70004190 */
+{0x0F12, 0x0029},     /*  70004192 */
+{0x0F12, 0xF000},     /*  70004194 */
+{0x0F12, 0xF9B6},     /*  70004196 */
+{0x0F12, 0x9801},     /*  70004198 */
+{0x0F12, 0x0032},     /*  7000419A */
+{0x0F12, 0x0039},     /*  7000419C */
+{0x0F12, 0xF000},     /*  7000419E */
+{0x0F12, 0xF9B9},     /*  700041A0 */
+{0x0F12, 0x6020},     /*  700041A2 */
+{0x0F12, 0xE5D0},     /*  700041A4 */
+{0x0F12, 0xB57C},     /*  700041A6 */
+{0x0F12, 0x487F},     /*  700041A8 */
+{0x0F12, 0xA901},     /*  700041AA */
+{0x0F12, 0x0004},     /*  700041AC */
+{0x0F12, 0xF000},     /*  700041AE */
+{0x0F12, 0xF93D},     /*  700041B0 */
+{0x0F12, 0x466B},     /*  700041B2 */
+{0x0F12, 0x88D9},     /*  700041B4 */
+{0x0F12, 0x8898},     /*  700041B6 */
+{0x0F12, 0x4B7A},     /*  700041B8 */
+{0x0F12, 0x3346},     /*  700041BA */
+{0x0F12, 0x1E9A},     /*  700041BC */
+{0x0F12, 0xF000},     /*  700041BE */
+{0x0F12, 0xF9B1},     /*  700041C0 */
+{0x0F12, 0x4879},     /*  700041C2 */
+{0x0F12, 0x4977},     /*  700041C4 */
+{0x0F12, 0x3812},     /*  700041C6 */
+{0x0F12, 0x3140},     /*  700041C8 */
+{0x0F12, 0x8A42},     /*  700041CA */
+{0x0F12, 0x888B},     /*  700041CC */
+{0x0F12, 0x18D2},     /*  700041CE */
+{0x0F12, 0x8242},     /*  700041D0 */
+{0x0F12, 0x8AC2},     /*  700041D2 */
+{0x0F12, 0x88C9},     /*  700041D4 */
+{0x0F12, 0x1851},     /*  700041D6 */
+{0x0F12, 0x82C1},     /*  700041D8 */
+{0x0F12, 0x0020},     /*  700041DA */
+{0x0F12, 0x4669},     /*  700041DC */
+{0x0F12, 0xF000},     /*  700041DE */
+{0x0F12, 0xF925},     /*  700041E0 */
+{0x0F12, 0x4872},     /*  700041E2 */
+{0x0F12, 0x214D},     /*  700041E4 */
+{0x0F12, 0x8301},     /*  700041E6 */
+{0x0F12, 0x2196},     /*  700041E8 */
+{0x0F12, 0x8381},     /*  700041EA */
+{0x0F12, 0x211D},     /*  700041EC */
+{0x0F12, 0x3020},     /*  700041EE */
+{0x0F12, 0x8001},     /*  700041F0 */
+{0x0F12, 0xF000},     /*  700041F2 */
+{0x0F12, 0xF99F},     /*  700041F4 */
+{0x0F12, 0xF000},     /*  700041F6 */
+{0x0F12, 0xF9A5},     /*  700041F8 */
+{0x0F12, 0x486D},     /*  700041FA */
+{0x0F12, 0x4C6D},     /*  700041FC */
+{0x0F12, 0x6E00},     /*  700041FE */
+{0x0F12, 0x60E0},     /*  70004200 */
+{0x0F12, 0x466B},     /*  70004202 */
+{0x0F12, 0x8818},     /*  70004204 */
+{0x0F12, 0x8859},     /*  70004206 */
+{0x0F12, 0x0025},     /*  70004208 */
+{0x0F12, 0x1A40},     /*  7000420A */
+{0x0F12, 0x3540},     /*  7000420C */
+{0x0F12, 0x61A8},     /*  7000420E */
+{0x0F12, 0x4864},     /*  70004210 */
+{0x0F12, 0x9900},     /*  70004212 */
+{0x0F12, 0x3060},     /*  70004214 */
+{0x0F12, 0xF000},     /*  70004216 */
+{0x0F12, 0xF99D},     /*  70004218 */
+{0x0F12, 0x466B},     /*  7000421A */
+{0x0F12, 0x8819},     /*  7000421C */
+{0x0F12, 0x1DE0},     /*  7000421E */
+{0x0F12, 0x30F9},     /*  70004220 */
+{0x0F12, 0x8741},     /*  70004222 */
+{0x0F12, 0x8859},     /*  70004224 */
+{0x0F12, 0x8781},     /*  70004226 */
+{0x0F12, 0x2000},     /*  70004228 */
+{0x0F12, 0x71A0},     /*  7000422A */
+{0x0F12, 0x74A8},     /*  7000422C */
+{0x0F12, 0xBC7C},     /*  7000422E */
+{0x0F12, 0xBC08},     /*  70004230 */
+{0x0F12, 0x4718},     /*  70004232 */
+{0x0F12, 0xB5F8},     /*  70004234 */
+{0x0F12, 0x0005},     /*  70004236 */
+{0x0F12, 0x6808},     /*  70004238 */
+{0x0F12, 0x0400},     /*  7000423A */
+{0x0F12, 0x0C00},     /*  7000423C */
+{0x0F12, 0x684A},     /*  7000423E */
+{0x0F12, 0x0412},     /*  70004240 */
+{0x0F12, 0x0C12},     /*  70004242 */
+{0x0F12, 0x688E},     /*  70004244 */
+{0x0F12, 0x68CC},     /*  70004246 */
+{0x0F12, 0x4955},     /*  70004248 */
+{0x0F12, 0x884B},     /*  7000424A */
+{0x0F12, 0x4343},     /*  7000424C */
+{0x0F12, 0x0A98},     /*  7000424E */
+{0x0F12, 0x2304},     /*  70004250 */
+{0x0F12, 0x5ECB},     /*  70004252 */
+{0x0F12, 0x18C0},     /*  70004254 */
+{0x0F12, 0x02C0},     /*  70004256 */
+{0x0F12, 0x0C00},     /*  70004258 */
+{0x0F12, 0x88CB},     /*  7000425A */
+{0x0F12, 0x4353},     /*  7000425C */
+{0x0F12, 0x0A9A},     /*  7000425E */
+{0x0F12, 0x2308},     /*  70004260 */
+{0x0F12, 0x5ECB},     /*  70004262 */
+{0x0F12, 0x18D1},     /*  70004264 */
+{0x0F12, 0x02C9},     /*  70004266 */
+{0x0F12, 0x0C09},     /*  70004268 */
+{0x0F12, 0x2701},     /*  7000426A */
+{0x0F12, 0x003A},     /*  7000426C */
+{0x0F12, 0x40AA},     /*  7000426E */
+{0x0F12, 0x9200},     /*  70004270 */
+{0x0F12, 0x002A},     /*  70004272 */
+{0x0F12, 0x3A10},     /*  70004274 */
+{0x0F12, 0x4097},     /*  70004276 */
+{0x0F12, 0x2D10},     /*  70004278 */
+{0x0F12, 0xDA06},     /*  7000427A */
+{0x0F12, 0x4A4E},     /*  7000427C */
+{0x0F12, 0x9B00},     /*  7000427E */
+{0x0F12, 0x8812},     /*  70004280 */
+{0x0F12, 0x439A},     /*  70004282 */
+{0x0F12, 0x4B4C},     /*  70004284 */
+{0x0F12, 0x801A},     /*  70004286 */
+{0x0F12, 0xE003},     /*  70004288 */
+{0x0F12, 0x4B4B},     /*  7000428A */
+{0x0F12, 0x885A},     /*  7000428C */
+{0x0F12, 0x43BA},     /*  7000428E */
+{0x0F12, 0x805A},     /*  70004290 */
+{0x0F12, 0x0023},     /*  70004292 */
+{0x0F12, 0x0032},     /*  70004294 */
+{0x0F12, 0xF000},     /*  70004296 */
+{0x0F12, 0xF945},     /*  70004298 */
+{0x0F12, 0x2D10},     /*  7000429A */
+{0x0F12, 0xDA05},     /*  7000429C */
+{0x0F12, 0x4946},     /*  7000429E */
+{0x0F12, 0x9A00},     /*  700042A0 */
+{0x0F12, 0x8808},     /*  700042A2 */
+{0x0F12, 0x4310},     /*  700042A4 */
+{0x0F12, 0x8008},     /*  700042A6 */
+{0x0F12, 0xE003},     /*  700042A8 */
+{0x0F12, 0x4843},     /*  700042AA */
+{0x0F12, 0x8841},     /*  700042AC */
+{0x0F12, 0x4339},     /*  700042AE */
+{0x0F12, 0x8041},     /*  700042B0 */
+{0x0F12, 0x4D40},     /*  700042B2 */
+{0x0F12, 0x2000},     /*  700042B4 */
+{0x0F12, 0x3580},     /*  700042B6 */
+{0x0F12, 0x88AA},     /*  700042B8 */
+{0x0F12, 0x5E30},     /*  700042BA */
+{0x0F12, 0x2100},     /*  700042BC */
+{0x0F12, 0xF000},     /*  700042BE */
+{0x0F12, 0xF951},     /*  700042C0 */
+{0x0F12, 0x8030},     /*  700042C2 */
+{0x0F12, 0x2000},     /*  700042C4 */
+{0x0F12, 0x88AA},     /*  700042C6 */
+{0x0F12, 0x5E20},     /*  700042C8 */
+{0x0F12, 0x2100},     /*  700042CA */
+{0x0F12, 0xF000},     /*  700042CC */
+{0x0F12, 0xF94A},     /*  700042CE */
+{0x0F12, 0x8020},     /*  700042D0 */
+{0x0F12, 0xE587},     /*  700042D2 */
+{0x0F12, 0xB510},     /*  700042D4 */
+{0x0F12, 0xF000},     /*  700042D6 */
+{0x0F12, 0xF94D},     /*  700042D8 */
+{0x0F12, 0x4A38},     /*  700042DA */
+{0x0F12, 0x8D50},     /*  700042DC */
+{0x0F12, 0x2800},     /*  700042DE */
+{0x0F12, 0xD007},     /*  700042E0 */
+{0x0F12, 0x4933},     /*  700042E2 */
+{0x0F12, 0x31C0},     /*  700042E4 */
+{0x0F12, 0x684B},     /*  700042E6 */
+{0x0F12, 0x4935},     /*  700042E8 */
+{0x0F12, 0x4283},     /*  700042EA */
+{0x0F12, 0xD202},     /*  700042EC */
+{0x0F12, 0x8D90},     /*  700042EE */
+{0x0F12, 0x81C8},     /*  700042F0 */
+{0x0F12, 0xE6A0},     /*  700042F2 */
+{0x0F12, 0x8DD0},     /*  700042F4 */
+{0x0F12, 0x81C8},     /*  700042F6 */
+{0x0F12, 0xE69D},     /*  700042F8 */
+{0x0F12, 0xB5F8},     /*  700042FA */
+{0x0F12, 0xF000},     /*  700042FC */
+{0x0F12, 0xF942},     /*  700042FE */
+{0x0F12, 0x4D2E},     /*  70004300 */
+{0x0F12, 0x8E28},     /*  70004302 */
+{0x0F12, 0x2800},     /*  70004304 */
+{0x0F12, 0xD01F},     /*  70004306 */
+{0x0F12, 0x4E2E},     /*  70004308 */
+{0x0F12, 0x4829},     /*  7000430A */
+{0x0F12, 0x68B4},     /*  7000430C */
+{0x0F12, 0x6800},     /*  7000430E */
+{0x0F12, 0x4284},     /*  70004310 */
+{0x0F12, 0xD903},     /*  70004312 */
+{0x0F12, 0x1A21},     /*  70004314 */
+{0x0F12, 0x0849},     /*  70004316 */
+{0x0F12, 0x1847},     /*  70004318 */
+{0x0F12, 0xE006},     /*  7000431A */
+{0x0F12, 0x4284},     /*  7000431C */
+{0x0F12, 0xD203},     /*  7000431E */
+{0x0F12, 0x1B01},     /*  70004320 */
+{0x0F12, 0x0849},     /*  70004322 */
+{0x0F12, 0x1A47},     /*  70004324 */
+{0x0F12, 0xE000},     /*  70004326 */
+{0x0F12, 0x0027},     /*  70004328 */
+{0x0F12, 0x0020},     /*  7000432A */
+{0x0F12, 0x4920},     /*  7000432C */
+{0x0F12, 0x3120},     /*  7000432E */
+{0x0F12, 0x7A0C},     /*  70004330 */
+{0x0F12, 0x2C00},     /*  70004332 */
+{0x0F12, 0xD004},     /*  70004334 */
+{0x0F12, 0x0200},     /*  70004336 */
+{0x0F12, 0x0039},     /*  70004338 */
+{0x0F12, 0xF000},     /*  7000433A */
+{0x0F12, 0xF887},     /*  7000433C */
+{0x0F12, 0x8668},     /*  7000433E */
+{0x0F12, 0x2C00},     /*  70004340 */
+{0x0F12, 0xD000},     /*  70004342 */
+{0x0F12, 0x60B7},     /*  70004344 */
+{0x0F12, 0xE54D},     /*  70004346 */
+{0x0F12, 0x20FF},     /*  70004348 */
+{0x0F12, 0x1C40},     /*  7000434A */
+{0x0F12, 0x8668},     /*  7000434C */
+{0x0F12, 0xE549},     /*  7000434E */
+{0x0F12, 0xB510},     /*  70004350 */
+{0x0F12, 0x000C},     /*  70004352 */
+{0x0F12, 0x6820},     /*  70004354 */
+{0x0F12, 0x0400},     /*  70004356 */
+{0x0F12, 0x0C00},     /*  70004358 */
+{0x0F12, 0x4918},     /*  7000435A */
+{0x0F12, 0x8E0A},     /*  7000435C */
+{0x0F12, 0x2A00},     /*  7000435E */
+{0x0F12, 0xD003},     /*  70004360 */
+{0x0F12, 0x8E49},     /*  70004362 */
+{0x0F12, 0x0200},     /*  70004364 */
+{0x0F12, 0xF000},     /*  70004366 */
+{0x0F12, 0xF871},     /*  70004368 */
+{0x0F12, 0x6020},     /*  7000436A */
+{0x0F12, 0x0400},     /*  7000436C */
+{0x0F12, 0x0C00},     /*  7000436E */
+{0x0F12, 0xE661},     /*  70004370 */
+{0x0F12, 0xB570},     /*  70004372 */
+{0x0F12, 0x680C},     /*  70004374 */
+{0x0F12, 0x4D14},     /*  70004376 */
+{0x0F12, 0x0020},     /*  70004378 */
+{0x0F12, 0x6F29},     /*  7000437A */
+{0x0F12, 0xF000},     /*  7000437C */
+{0x0F12, 0xF90A},     /*  7000437E */
+{0x0F12, 0x6F69},     /*  70004380 */
+{0x0F12, 0x1D20},     /*  70004382 */
+{0x0F12, 0xF000},     /*  70004384 */
+{0x0F12, 0xF906},     /*  70004386 */
+{0x0F12, 0x480C},     /*  70004388 */
+{0x0F12, 0x8E00},     /*  7000438A */
+{0x0F12, 0x2800},     /*  7000438C */
+{0x0F12, 0xD006},     /*  7000438E */
+{0x0F12, 0x4907},     /*  70004390 */
+{0x0F12, 0x2214},     /*  70004392 */
+{0x0F12, 0x3168},     /*  70004394 */
+{0x0F12, 0x0008},     /*  70004396 */
+{0x0F12, 0x383C},     /*  70004398 */
+{0x0F12, 0xF000},     /*  7000439A */
+{0x0F12, 0xF903},     /*  7000439C */
+{0x0F12, 0xE488},     /*  7000439E */
+{0x0F12, 0x2558},     /*  700043A0 */
+{0x0F12, 0x7000},     /*  700043A2 */
+{0x0F12, 0x2AB8},     /*  700043A4 */
+{0x0F12, 0x7000},     /*  700043A6 */
+{0x0F12, 0x145E},     /*  700043A8 */
+{0x0F12, 0x7000},     /*  700043AA */
+{0x0F12, 0x2698},     /*  700043AC */
+{0x0F12, 0x7000},     /*  700043AE */
+{0x0F12, 0x2BB8},     /*  700043B0 */
+{0x0F12, 0x7000},     /*  700043B2 */
+{0x0F12, 0x2998},     /*  700043B4 */
+{0x0F12, 0x7000},     /*  700043B6 */
+{0x0F12, 0x1100},     /*  700043B8 */
+{0x0F12, 0xD000},     /*  700043BA */
+{0x0F12, 0x4780},     /*  700043BC */
+{0x0F12, 0x7000},     /*  700043BE */
+{0x0F12, 0xE200},     /*  700043C0 */
+{0x0F12, 0xD000},     /*  700043C2 */
+{0x0F12, 0x210C},     /*  700043C4 */
+{0x0F12, 0x7000},     /*  700043C6 */
+{0x0F12, 0x0000},     /*  700043C8 */
+{0x0F12, 0x7000},     /*  700043CA */
+{0x0F12, 0x4778},     /*  700043CC */
+{0x0F12, 0x46C0},     /*  700043CE */
+{0x0F12, 0xC000},     /*  700043D0 */
+{0x0F12, 0xE59F},     /*  700043D2 */
+{0x0F12, 0xFF1C},     /*  700043D4 */
+{0x0F12, 0xE12F},     /*  700043D6 */
+{0x0F12, 0x1789},     /*  700043D8 */
+{0x0F12, 0x0001},     /*  700043DA */
+{0x0F12, 0x4778},     /*  700043DC */
+{0x0F12, 0x46C0},     /*  700043DE */
+{0x0F12, 0xC000},     /*  700043E0 */
+{0x0F12, 0xE59F},     /*  700043E2 */
+{0x0F12, 0xFF1C},     /*  700043E4 */
+{0x0F12, 0xE12F},     /*  700043E6 */
+{0x0F12, 0x16F1},     /*  700043E8 */
+{0x0F12, 0x0001},     /*  700043EA */
+{0x0F12, 0x4778},     /*  700043EC */
+{0x0F12, 0x46C0},     /*  700043EE */
+{0x0F12, 0xC000},     /*  700043F0 */
+{0x0F12, 0xE59F},     /*  700043F2 */
+{0x0F12, 0xFF1C},     /*  700043F4 */
+{0x0F12, 0xE12F},     /*  700043F6 */
+{0x0F12, 0xC3B1},     /*  700043F8 */
+{0x0F12, 0x0000},     /*  700043FA */
+{0x0F12, 0x4778},     /*  700043FC */
+{0x0F12, 0x46C0},     /*  700043FE */
+{0x0F12, 0xC000},     /*  70004400 */
+{0x0F12, 0xE59F},     /*  70004402 */
+{0x0F12, 0xFF1C},     /*  70004404 */
+{0x0F12, 0xE12F},     /*  70004406 */
+{0x0F12, 0xC36D},     /*  70004408 */
+{0x0F12, 0x0000},     /*  7000440A */
+{0x0F12, 0x4778},     /*  7000440C */
+{0x0F12, 0x46C0},     /*  7000440E */
+{0x0F12, 0xC000},     /*  70004410 */
+{0x0F12, 0xE59F},     /*  70004412 */
+{0x0F12, 0xFF1C},     /*  70004414 */
+{0x0F12, 0xE12F},     /*  70004416 */
+{0x0F12, 0xF6D7},     /*  70004418 */
+{0x0F12, 0x0000},     /*  7000441A */
+{0x0F12, 0x4778},     /*  7000441C */
+{0x0F12, 0x46C0},     /*  7000441E */
+{0x0F12, 0xC000},     /*  70004420 */
+{0x0F12, 0xE59F},     /*  70004422 */
+{0x0F12, 0xFF1C},     /*  70004424 */
+{0x0F12, 0xE12F},     /*  70004426 */
+{0x0F12, 0xB49D},     /*  70004428 */
+{0x0F12, 0x0000},     /*  7000442A */
+{0x0F12, 0x4778},     /*  7000442C */
+{0x0F12, 0x46C0},     /*  7000442E */
+{0x0F12, 0xC000},     /*  70004430 */
+{0x0F12, 0xE59F},     /*  70004432 */
+{0x0F12, 0xFF1C},     /*  70004434 */
+{0x0F12, 0xE12F},     /*  70004436 */
+{0x0F12, 0x7EDF},     /*  70004438 */
+{0x0F12, 0x0000},     /*  7000443A */
+{0x0F12, 0x4778},     /*  7000443C */
+{0x0F12, 0x46C0},     /*  7000443E */
+{0x0F12, 0xC000},     /*  70004440 */
+{0x0F12, 0xE59F},     /*  70004442 */
+{0x0F12, 0xFF1C},     /*  70004444 */
+{0x0F12, 0xE12F},     /*  70004446 */
+{0x0F12, 0x448D},     /*  70004448 */
+{0x0F12, 0x0000},     /*  7000444A */
+{0x0F12, 0x4778},     /*  7000444C */
+{0x0F12, 0x46C0},     /*  7000444E */
+{0x0F12, 0xF004},     /*  70004450 */
+{0x0F12, 0xE51F},     /*  70004452 */
+{0x0F12, 0x29EC},     /*  70004454 */
+{0x0F12, 0x0001},     /*  70004456 */
+{0x0F12, 0x4778},     /*  70004458 */
+{0x0F12, 0x46C0},     /*  7000445A */
+{0x0F12, 0xC000},     /*  7000445C */
+{0x0F12, 0xE59F},     /*  7000445E */
+{0x0F12, 0xFF1C},     /*  70004460 */
+{0x0F12, 0xE12F},     /*  70004462 */
+{0x0F12, 0x2EF1},     /*  70004464 */
+{0x0F12, 0x0000},     /*  70004466 */
+{0x0F12, 0x4778},     /*  70004468 */
+{0x0F12, 0x46C0},     /*  7000446A */
+{0x0F12, 0xC000},     /*  7000446C */
+{0x0F12, 0xE59F},     /*  7000446E */
+{0x0F12, 0xFF1C},     /*  70004470 */
+{0x0F12, 0xE12F},     /*  70004472 */
+{0x0F12, 0xEE03},     /*  70004474 */
+{0x0F12, 0x0000},     /*  70004476 */
+{0x0F12, 0x4778},     /*  70004478 */
+{0x0F12, 0x46C0},     /*  7000447A */
+{0x0F12, 0xC000},     /*  7000447C */
+{0x0F12, 0xE59F},     /*  7000447E */
+{0x0F12, 0xFF1C},     /*  70004480 */
+{0x0F12, 0xE12F},     /*  70004482 */
+{0x0F12, 0xA58B},     /*  70004484 */
+{0x0F12, 0x0000},     /*  70004486 */
+{0x0F12, 0x4778},     /*  70004488 */
+{0x0F12, 0x46C0},     /*  7000448A */
+{0x0F12, 0xC000},     /*  7000448C */
+{0x0F12, 0xE59F},     /*  7000448E */
+{0x0F12, 0xFF1C},     /*  70004490 */
+{0x0F12, 0xE12F},     /*  70004492 */
+{0x0F12, 0x7C49},     /*  70004494 */
+{0x0F12, 0x0000},     /*  70004496 */
+{0x0F12, 0x4778},     /*  70004498 */
+{0x0F12, 0x46C0},     /*  7000449A */
+{0x0F12, 0xC000},     /*  7000449C */
+{0x0F12, 0xE59F},     /*  7000449E */
+{0x0F12, 0xFF1C},     /*  700044A0 */
+{0x0F12, 0xE12F},     /*  700044A2 */
+{0x0F12, 0x7C63},     /*  700044A4 */
+{0x0F12, 0x0000},     /*  700044A6 */
+{0x0F12, 0x4778},     /*  700044A8 */
+{0x0F12, 0x46C0},     /*  700044AA */
+{0x0F12, 0xC000},     /*  700044AC */
+{0x0F12, 0xE59F},     /*  700044AE */
+{0x0F12, 0xFF1C},     /*  700044B0 */
+{0x0F12, 0xE12F},     /*  700044B2 */
+{0x0F12, 0x2DB7},     /*  700044B4 */
+{0x0F12, 0x0000},     /*  700044B6 */
+{0x0F12, 0x4778},     /*  700044B8 */
+{0x0F12, 0x46C0},     /*  700044BA */
+{0x0F12, 0xC000},     /*  700044BC */
+{0x0F12, 0xE59F},     /*  700044BE */
+{0x0F12, 0xFF1C},     /*  700044C0 */
+{0x0F12, 0xE12F},     /*  700044C2 */
+{0x0F12, 0xEB3D},     /*  700044C4 */
+{0x0F12, 0x0000},     /*  700044C6 */
+{0x0F12, 0x4778},     /*  700044C8 */
+{0x0F12, 0x46C0},     /*  700044CA */
+{0x0F12, 0xC000},     /*  700044CC */
+{0x0F12, 0xE59F},     /*  700044CE */
+{0x0F12, 0xFF1C},     /*  700044D0 */
+{0x0F12, 0xE12F},     /*  700044D2 */
+{0x0F12, 0xF061},     /*  700044D4 */
+{0x0F12, 0x0000},     /*  700044D6 */
+{0x0F12, 0x4778},     /*  700044D8 */
+{0x0F12, 0x46C0},     /*  700044DA */
+{0x0F12, 0xC000},     /*  700044DC */
+{0x0F12, 0xE59F},     /*  700044DE */
+{0x0F12, 0xFF1C},     /*  700044E0 */
+{0x0F12, 0xE12F},     /*  700044E2 */
+{0x0F12, 0xF0EF},     /*  700044E4 */
+{0x0F12, 0x0000},     /*  700044E6 */
+{0x0F12, 0x4778},     /*  700044E8 */
+{0x0F12, 0x46C0},     /*  700044EA */
+{0x0F12, 0xF004},     /*  700044EC */
+{0x0F12, 0xE51F},     /*  700044EE */
+{0x0F12, 0x2824},     /*  700044F0 */
+{0x0F12, 0x0001},     /*  700044F2 */
+{0x0F12, 0x4778},     /*  700044F4 */
+{0x0F12, 0x46C0},     /*  700044F6 */
+{0x0F12, 0xC000},     /*  700044F8 */
+{0x0F12, 0xE59F},     /*  700044FA */
+{0x0F12, 0xFF1C},     /*  700044FC */
+{0x0F12, 0xE12F},     /*  700044FE */
+{0x0F12, 0x8EDD},     /*  70004500 */
+{0x0F12, 0x0000},     /*  70004502 */
+{0x0F12, 0x4778},     /*  70004504 */
+{0x0F12, 0x46C0},     /*  70004506 */
+{0x0F12, 0xC000},     /*  70004508 */
+{0x0F12, 0xE59F},     /*  7000450A */
+{0x0F12, 0xFF1C},     /*  7000450C */
+{0x0F12, 0xE12F},     /*  7000450E */
+{0x0F12, 0x8DCB},     /*  70004510 */
+{0x0F12, 0x0000},     /*  70004512 */
+{0x0F12, 0x4778},     /*  70004514 */
+{0x0F12, 0x46C0},     /*  70004516 */
+{0x0F12, 0xC000},     /*  70004518 */
+{0x0F12, 0xE59F},     /*  7000451A */
+{0x0F12, 0xFF1C},     /*  7000451C */
+{0x0F12, 0xE12F},     /*  7000451E */
+{0x0F12, 0x8E17},     /*  70004520 */
+{0x0F12, 0x0000},     /*  70004522 */
+{0x0F12, 0x4778},     /*  70004524 */
+{0x0F12, 0x46C0},     /*  70004526 */
+{0x0F12, 0xC000},     /*  70004528 */
+{0x0F12, 0xE59F},     /*  7000452A */
+{0x0F12, 0xFF1C},     /*  7000452C */
+{0x0F12, 0xE12F},     /*  7000452E */
+{0x0F12, 0x98C5},     /*  70004530 */
+{0x0F12, 0x0000},     /*  70004532 */
+{0x0F12, 0x4778},     /*  70004534 */
+{0x0F12, 0x46C0},     /*  70004536 */
+{0x0F12, 0xC000},     /*  70004538 */
+{0x0F12, 0xE59F},     /*  7000453A */
+{0x0F12, 0xFF1C},     /*  7000453C */
+{0x0F12, 0xE12F},     /*  7000453E */
+{0x0F12, 0x7C7D},     /*  70004540 */
+{0x0F12, 0x0000},     /*  70004542 */
+{0x0F12, 0x4778},     /*  70004544 */
+{0x0F12, 0x46C0},     /*  70004546 */
+{0x0F12, 0xC000},     /*  70004548 */
+{0x0F12, 0xE59F},     /*  7000454A */
+{0x0F12, 0xFF1C},     /*  7000454C */
+{0x0F12, 0xE12F},     /*  7000454E */
+{0x0F12, 0x7E31},     /*  70004550 */
+{0x0F12, 0x0000},     /*  70004552 */
+{0x0F12, 0x4778},     /*  70004554 */
+{0x0F12, 0x46C0},     /*  70004556 */
+{0x0F12, 0xC000},     /*  70004558 */
+{0x0F12, 0xE59F},     /*  7000455A */
+{0x0F12, 0xFF1C},     /*  7000455C */
+{0x0F12, 0xE12F},     /*  7000455E */
+{0x0F12, 0x7EAB},     /*  70004560 */
+{0x0F12, 0x0000},     /*  70004562 */
+{0x0F12, 0x4778},     /*  70004564 */
+{0x0F12, 0x46C0},     /*  70004566 */
+{0x0F12, 0xC000},     /*  70004568 */
+{0x0F12, 0xE59F},     /*  7000456A */
+{0x0F12, 0xFF1C},     /*  7000456C */
+{0x0F12, 0xE12F},     /*  7000456E */
+{0x0F12, 0x7501},     /*  70004570 */
+{0x0F12, 0x0000},     /*  70004572 */
+{0x0F12, 0x4778},     /*  70004574 */
+{0x0F12, 0x46C0},     /*  70004576 */
+{0x0F12, 0xC000},     /*  70004578 */
+{0x0F12, 0xE59F},     /*  7000457A */
+{0x0F12, 0xFF1C},     /*  7000457C */
+{0x0F12, 0xE12F},     /*  7000457E */
+{0x0F12, 0xF63F},     /*  70004580 */
+{0x0F12, 0x0000},     /*  70004582 */
+{0x0F12, 0x4778},     /*  70004584 */
+{0x0F12, 0x46C0},     /*  70004586 */
+{0x0F12, 0xC000},     /*  70004588 */
+{0x0F12, 0xE59F},     /*  7000458A */
+{0x0F12, 0xFF1C},     /*  7000458C */
+{0x0F12, 0xE12F},     /*  7000458E */
+{0x0F12, 0x3D0B},     /*  70004590 */
+{0x0F12, 0x0000},     /*  70004592 */
+{0x0F12, 0x4778},     /*  70004594 */
+{0x0F12, 0x46C0},     /*  70004596 */
+{0x0F12, 0xC000},     /*  70004598 */
+{0x0F12, 0xE59F},     /*  7000459A */
+{0x0F12, 0xFF1C},     /*  7000459C */
+{0x0F12, 0xE12F},     /*  7000459E */
+{0x0F12, 0x29BF},     /*  700045A0 */
+{0x0F12, 0x0001},     /*  700045A2 */
+{0x0F12, 0x4778},     /*  700045A4 */
+{0x0F12, 0x46C0},     /*  700045A6 */
+{0x0F12, 0xF004},     /*  700045A8 */
+{0x0F12, 0xE51F},     /*  700045AA */
+{0x0F12, 0x26D8},     /*  700045AC */
+{0x0F12, 0x0001},     /*  700045AE */
+/* End of Patch Data(Last : 700045AEh) */
+/* Total Size 2744 (0AB8) */
+/* Addr : 3AF8 , Size : 2742(AB6h) */
+
+/*	TNP_USER_MBCV_CONTROL */
+/* TNP_4EC_MBR_TUNE */
+/* TNP_4EC_FORBIDDEN_TUNE */
+/* TNP_AF_FINESEARCH_DRIVEBACK */
+/* TNP_FLASH_ALG */
+/* TNP_GAS_ALPHA_OTP */
+/*	TNP_AWB_MODUL_COMP */
+/* TNP_AWB_INIT_QUEUE */
+/* TNP_AWB_GRID_LOWBR */
+/* TNP_AWB_GRID_MODULECOMP */
+/*	TNP_ADLC_TUNE */
+/* TNP_1FRAME_AE */
+
+
+{0x0028, 0xD000},
+{0x002A, 0x1000},
+{0x0F12, 0x0001},
+
+{0x0028, 0x7000},
+{0x002A, 0x47B0},
+{0x0F12, 0x0000},	/*TNP_Regs_BUse1FrameAE		(0: off, 1: on) */
+
+
+/*=================================================================== */
+/* AF setting */
+/*=================================================================== */
+{0x0028, 0x7000},
+{0x002A, 0x01FC},
+{0x0F12, 0x0001},	/*REG_TC_IPRM_LedGpio */
+{0x002A, 0x01FE},
+{0x0F12, 0x0003},	/*REG_TC_IPRM_CM_Init_AfModeType VCM IIC */
+{0x0F12, 0x0000},	/*REG_TC_IPRM_CM_Init_PwmConfig1 */
+{0x002A, 0x0204},
+{0x0F12, 0x0061},	/*REG_TC_IPRM_CM_Init_GpioConfig1 AF Enable GPIO 6*/
+{0x002A, 0x020C},
+{0x0F12, 0x2F0C},	/*REG_TC_IPRM_CM_Init_Mi2cBits */
+{0x0F12, 0x0190},	/*REG_TC_IPRM_CM_Init_Mi2cRateKhz IIC Speed */
+{0x002A, 0x0294},
+{0x0F12, 0x0100},	/*REG_TC_AF_FstWinStartX */
+{0x0F12, 0x00E3},	/*REG_TC_AF_FstWinStartY */
+{0x0F12, 0x0200},	/*REG_TC_AF_FstWinSizeX */
+{0x0F12, 0x0238},	/*REG_TC_AF_FstWinSizeY */
+{0x0F12, 0x01C6},  /* LSI_Cho AF Window Center from_LSI */
+{0x0F12, 0x0166},	/*REG_TC_AF_ScndWinStartY */
+{0x0F12, 0x0074},  /* LSI_Cho AF Fail when Size change from_LSI */
+{0x0F12, 0x0132},	/*REG_TC_AF_ScndWinSizeY */
+{0x0F12, 0x0001},	/*REG_TC_AF_WinSizesUpdated */
+
+{0x002A, 0x070E},
+{0x0F12, 0x00C0},	/*E0->C0 skl_af_StatOvlpExpFactor SEHF_SHIN */
+{0x002A, 0x071E},
+{0x0F12, 0x0000},  /* LSI_Cho AF Fail when Size change from_LSI */
+{0x002A, 0x163C},
+{0x0F12, 0x0000},	/*af_search_usAeStable */
+{0x002A, 0x1648},
+{0x0F12, 0x9002},	/*af_search_usSingleAfFlags */
+{0x002A, 0x1652},
+{0x0F12, 0x0002},	/*af_search_usFinePeakCount */
+{0x0F12, 0x0000},	/*af_search_usFineMaxScale */
+{0x002A, 0x15E0},
+{0x0F12, 0x0902},   /* when 2nd search 1code distance 6+1 position move
+SEHF_CHECK_IT */
+
+{0x002A, 0x164C},
+{0x0F12, 0x0003},	/*af_search_usMinPeakSamples */
+{0x002A, 0x163E},
+{0x0F12, 0x00A0},	/*D5 -> A0 af_search_usPeakThr Full search (E5 90%) */
+{0x0F12, 0x0098},   /*98(60%) -> CC(80%) SEHF_CHECK_IT */
+{0x002A, 0x15D4},
+{0x0F12, 0x0000},	/*af_pos_usHomePos */
+{0x0F12, 0xD000},	/*af_pos_usLowConfPos */
+{0x002A, 0x169A},
+{0x0F12, 0xFF95},	/*af_search_usConfCheckOrder_1_ */
+{0x002A, 0x166A},
+{0x0F12, 0x0280},	/*af_search_usConfThr_4_ */
+{0x002A, 0x1676},
+{0x0F12, 0x03A0},	/*af_search_usConfThr_10_ */
+{0x0F12, 0x0320},	/*af_search_usConfThr_11_ */
+{0x002A, 0x16BC},
+{0x0F12, 0x0030},	/*af_stat_usMinStatVal */
+{0x002A, 0x16E0},
+{0x0F12, 0x0060},	/*af_scene_usSceneLowNormBrThr */
+{0x002A, 0x16D4},
+{0x0F12, 0x0010},	/*af_stat_usBpfThresh */
+{0x002A, 0x1656},
+{0x0F12, 0x0000},	/*af_search_usCapturePolicy */
+{0x002A, 0x15E6},
+{0x0F12, 0x003C},	/*af_pos_usCaptureFixedPos */
+
+{0x0F12, 0x0018},   /*af_pos_usTableLastInd SEHF_CHECK_IT */
+{0x0F12, 0x002A},
+{0x0F12, 0x0030},
+{0x0F12, 0x0036},
+{0x0F12, 0x003C},
+{0x0F12, 0x0042},
+{0x0F12, 0x0048},
+{0x0F12, 0x004E},
+{0x0F12, 0x0054},
+{0x0F12, 0x005A},
+{0x0F12, 0x0060},
+{0x0F12, 0x0066},
+{0x0F12, 0x006C},
+{0x0F12, 0x0072},
+{0x0F12, 0x0078},
+{0x0F12, 0x007E},
+{0x0F12, 0x0084},
+{0x0F12, 0x008A},
+{0x0F12, 0x0090},
+{0x0F12, 0x0096},
+{0x0F12, 0x009C},
+{0x0F12, 0x00A2},
+{0x0F12, 0x00A8},
+{0x0F12, 0x00AE},
+{0x0F12, 0x00B4},
+{0x0F12, 0x00BA},
+
+{0x002A, 0x1722},
+{0x0F12, 0x8000},	/*afd_usParam_0_ */
+{0x0F12, 0x0006},	/*afd_usParam_1_ */
+{0x0F12, 0x3FF0},	/*afd_usParam_2_ */
+{0x0F12, 0x03E8},	/*afd_usParam_3_ */
+{0x0F12, 0x0000},	/*afd_usParam_4_ */
+{0x0F12, 0x0005},   /*delay2 when threshold upper lens moving when moving
+distance 9 delay 80h 25.6ms delay SEHF_SHIN */
+{0x0F12, 0x0001},   /*threshold SEHF_CHECK_IT */
+{0x0F12, 0x000A},	/*afd_usParam_5_ */
+{0x0F12, 0x0080},	/*afd_usParam_8_ */
+{0x0F12, 0x00C0},	/*afd_usParam_9_ */
+{0x0F12, 0x00E0},	/*afd_usParam_10_ */
+{0x0F12, 0x0000},	/*afd_usParam_11_ */
+
+{0x002A, 0x028C},
+{0x0F12, 0x0003},	/*REG_TC_AF_AfCmd */
+
+/*=================================================================== */
+/* GAS setting (Shading) */
+/*=================================================================== */
+/* If OTP is used, GAS setting should be deleted. */
+
+/*=================================================================== */
+/* GAS Alpha setting */
+/*=================================================================== */
+{0x002A, 0x08B4},
+{0x0F12, 0x0001},	/*wbt_bUseOutdoorASH */
+
+/* Refer Mon_AWB_RotGain */
+{0x002A, 0x08BC},
+{0x0F12, 0x00C0},	/*TVAR_ash_AwbAshCord_0_ 2300K */
+{0x0F12, 0x00DF},	/*TVAR_ash_AwbAshCord_1_ 2750K */
+{0x0F12, 0x0100},	/*TVAR_ash_AwbAshCord_2_ 3300K */
+{0x0F12, 0x0125},	/*TVAR_ash_AwbAshCord_3_ 4150K */
+{0x0F12, 0x015F},	/*TVAR_ash_AwbAshCord_4_ 5250K */
+{0x0F12, 0x017C},	/*TVAR_ash_AwbAshCord_5_ 6400K */
+{0x0F12, 0x0194},	/*TVAR_ash_AwbAshCord_6_ 7500K */
+
+/* GAS Alpha Table */
+{0x002A, 0x08F6},
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_0__0_ R  2300K */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_0__1_ GR */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_0__2_ GB */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_0__3_ B */
+
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_1__0_ R  2750K */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_1__1_ GR */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_1__2_ GB */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_1__3_ B */
+
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_2__0_ R  3300K */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_2__1_ GR */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_2__2_ GB */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_2__3_ B */
+
+{0x0F12, 0x3800}, /*TVAR_ash_GASAlpha_3__0_ R  4150K */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_3__1_ GR */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_3__2_ GB */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_3__3_ B */
+
+{0x0F12, 0x3B00}, /*TVAR_ash_GASAlpha_4__0_ R  5250K */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_4__1_ GR */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_4__2_ GB */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_4__3_ B */
+
+{0x0F12, 0x4300}, /*TVAR_ash_GASAlpha_5__0_ R  6400K */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_5__1_ GR */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_5__2_ GB */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_5__3_ B */
+
+{0x0F12, 0x4300}, /*TVAR_ash_GASAlpha_6__0_ R  7500K */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_6__1_ GR */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_6__2_ GB */
+{0x0F12, 0x4000}, /*TVAR_ash_GASAlpha_6__3_ B */
+/* Outdoor GAS Alpha */
+{0x0F12, 0x4500}, /*TVAR_ash_GASOutdoorAlpha_0_ R */
+{0x0F12, 0x4000}, /*TVAR_ash_GASOutdoorAlpha_1_ GR */
+{0x0F12, 0x4000}, /*TVAR_ash_GASOutdoorAlpha_2_ GB */
+{0x0F12, 0x4000}, /*TVAR_ash_GASOutdoorAlpha_3_ B */
+
+{0x002A, 0x08F4},
+{0x0F12, 0x0001},   /*ash_bUseGasAlpha */
+
+/*=================================================================== */
+/* AE weight setting */
+/*=================================================================== */
+{0x002A, 0x1492},
+{0x0F12, 0x0101},
+{0x0F12, 0x0101},
+{0x0F12, 0x0101},
+{0x0F12, 0x0101},
+{0x0F12, 0x0101},
+{0x0F12, 0x0202},
+{0x0F12, 0x0202},
+{0x0F12, 0x0101},
+{0x0F12, 0x0201},
+{0x0F12, 0x0202},
+{0x0F12, 0x0202},
+{0x0F12, 0x0102},
+{0x0F12, 0x0201},
+{0x0F12, 0x0302},
+{0x0F12, 0x0203},
+{0x0F12, 0x0102},
+{0x0F12, 0x0201},
+{0x0F12, 0x0302},
+{0x0F12, 0x0203},
+{0x0F12, 0x0102},
+{0x0F12, 0x0101},
+{0x0F12, 0x0202},
+{0x0F12, 0x0202},
+{0x0F12, 0x0101},
+{0x0F12, 0x0101},
+{0x0F12, 0x0201},
+{0x0F12, 0x0102},
+{0x0F12, 0x0101},
+{0x0F12, 0x0100},
+{0x0F12, 0x0101},
+{0x0F12, 0x0101},
+{0x0F12, 0x0001},
+
+/*=================================================================== */
+/* AE setting */
+/*=================================================================== */
+{0x002A, 0x1484},
+{0x0F12, 0x003C},	/*TVAR_ae_BrAve */
+{0x002A, 0x148A},
+{0x0F12, 0x000F},	/*ae_StatMode */
+{0x002A, 0x058C},
+{0x0F12, 0x3520},
+{0x0F12, 0x0000},   /*lt_uMaxExp1 */
+{0x0F12, 0xC350},
+{0x0F12, 0x0000},   /*lt_uMaxExp2 */
+{0x0F12, 0x3520},
+{0x0F12, 0x0000},   /*lt_uCapMaxExp1 */
+{0x0F12, 0xC350},
+{0x0F12, 0x0000},   /*lt_uCapMaxExp2 */
+{0x002A, 0x059C},
+{0x0F12, 0x0470},   /*lt_uMaxAnGain1 */
+{0x0F12, 0x0C00},   /*lt_uMaxAnGain2 */
+{0x0F12, 0x0100},   /*lt_uMaxDigGain */
+{0x0F12, 0x1000},   /*lt_uMaxTotGain */
+
+{0x002A, 0x0544},
+{0x0F12, 0x0111},   /*lt_uLimitHigh */
+{0x0F12, 0x00EF},   /*lt_uLimitLow */
+{0x002A, 0x0F2A},
+{0x0F12, 0x0000},	/*lt_uInitPostToleranceCnt */
+{0x002A, 0x04E6},
+{0x0F12, 0x077F},   /*REG_TC_DBG */
+
+{0x002A, 0x0F30},
+{0x0F12, 0x0001},   /*AFC_D_ConvAccelerPower */
+
+{0x002A, 0x0608},
+{0x0F12, 0x0001},	/*lt_ExpGain_uSubsamplingmode */
+{0x0F12, 0x0001},	/*lt_ExpGain_uNonSubsampling */
+{0x0F12, 0x0800},	/*lt_ExpGain_ExpCurveGainMaxStr_0__uMaxAnGain */
+{0x0F12, 0x0100},	/*lt_ExpGain_ExpCurveGainMaxStr_0__uMaxDigGain */
+{0x0F12, 0x0001},
+{0x0F12, 0x0000},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpIn_0_ */
+{0x0F12, 0x0A3C},
+{0x0F12, 0x0000},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpIn_1_ */
+{0x0F12, 0x0D05},   /*0D05 */
+{0x0F12, 0x0000},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpIn_2_ */
+{0x0F12, 0x4008},
+{0x0F12, 0x0000},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpIn_3_ 700Lux */
+{0x0F12, 0x7000},
+{0x0F12, 0x0000},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpIn_4_ 400Lux */
+{0x0F12, 0x9C00},
+{0x0F12, 0x0000},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpIn_5_ */
+{0x0F12, 0xAD00},
+{0x0F12, 0x0001},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpIn_6_ */
+{0x0F12, 0xF1D4},
+{0x0F12, 0x0002},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpIn_7_ */
+{0x0F12, 0xDC00},
+{0x0F12, 0x0005},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpIn_8_ */
+{0x0F12, 0xDC00},
+{0x0F12, 0x0005},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpIn_9_ */
+
+{0x002A, 0x0638},
+{0x0F12, 0x0001},
+{0x0F12, 0x0000},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_0_ */
+{0x0F12, 0x0A3C},
+{0x0F12, 0x0000},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_1_ */
+{0x0F12, 0x0D05},
+{0x0F12, 0x0000},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_2_ */
+{0x0F12, 0x3408},
+{0x0F12, 0x0000},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_3_ */
+{0x0F12, 0x3408},
+{0x0F12, 0x0000},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_4_ */
+{0x0F12, 0x6810},
+{0x0F12, 0x0000},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_5_ */
+{0x0F12, 0x8214},
+{0x0F12, 0x0000},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_6_ */
+{0x0F12, 0xC350},
+{0x0F12, 0x0000},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_7_ */
+{0x0F12, 0xC350},
+{0x0F12, 0x0000},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_8_ */
+{0x0F12, 0xC350},
+{0x0F12, 0x0000},	/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_9_ */
+
+{0x002A, 0x0660},
+{0x0F12, 0x0650},   /*lt_ExpGain_ExpCurveGainMaxStr_1_ */
+{0x0F12, 0x0100},   /*lt_ExpGain_ExpCurveGainMaxStr_1__uMaxDigGain */
+{0x002A, 0x06B8},
+{0x0F12, 0x452C},	/*lt_uMaxLei */
+{0x0F12, 0x0005},   /*lt_uMaxLei */
+
+{0x002A, 0x05D0},
+{0x0F12, 0x0000},	/*lt_mbr_Peak_behind */
+
+/*=================================================================== */
+/* AWB setting */
+/*=================================================================== */
+/* AWB White Locus should be in front of REG_TC_IPRM_InitParamsUpdated */
+
+/* AWB init Start point */
+{0x002A, 0x145E},
+{0x0F12, 0x0625},	/*awbb_GainsInit_0_ */
+{0x0F12, 0x0400},	/*awbb_GainsInit_1_ */
+{0x0F12, 0x07F2},
+
+/* White Locus */
+{0x002A, 0x11F0},
+{0x0F12, 0x0120},   /*awbb_IntcR */
+{0x0F12, 0x0121},	/*awbb_IntcB */
+
+/* Indoor Zone */
+{0x002A, 0x101C},
+{0x0F12, 0x037C},
+{0x0F12, 0x038E},
+{0x0F12, 0x033C},
+{0x0F12, 0x0384},
+{0x0F12, 0x02FE},
+{0x0F12, 0x036C},	/*awbb_IndoorGrZones_m_BGrid_0__m_right */
+{0x0F12, 0x02BA},
+{0x0F12, 0x0352},
+{0x0F12, 0x028E},
+{0x0F12, 0x0300},
+{0x0F12, 0x026A},
+{0x0F12, 0x02C8},
+{0x0F12, 0x0254},
+{0x0F12, 0x02A8},
+{0x0F12, 0x0242},
+{0x0F12, 0x02A0},
+{0x0F12, 0x021A},
+{0x0F12, 0x02A0},
+{0x0F12, 0x01F4},
+{0x0F12, 0x0298},
+{0x0F12, 0x01D4},
+{0x0F12, 0x0290},
+{0x0F12, 0x01CC},
+{0x0F12, 0x0276},
+{0x0F12, 0x01D2},
+{0x0F12, 0x0260},
+{0x0F12, 0x01F6},
+{0x0F12, 0x023A},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},	/*awbb_IndoorGrZones_m_BGrid_19__m_left */
+{0x0F12, 0x0000},	/*awbb_IndoorGrZones_m_BGrid_19__m_right */
+
+{0x0F12, 0x0005},	/*awbb_IndoorGrZones_m_GridStep */
+{0x002A, 0x1070},
+{0x0F12, 0x000E},   /*awbb_IndoorGrZones_ZInfo_m_GridSz */
+{0x002A, 0x1074},
+{0x0F12, 0x0126},   /*awbb_IndoorGrZones_m_Boffs */
+
+/* Outdoor Zone */
+{0x002A, 0x1078},
+{0x0F12, 0x026A},
+{0x0F12, 0x0296},
+{0x0F12, 0x025E},	/*awbb_OutdoorGrZones_m_BGrid_0__m_right */
+{0x0F12, 0x02C2},
+{0x0F12, 0x0252},
+{0x0F12, 0x02CA},
+{0x0F12, 0x0246},
+{0x0F12, 0x02CC},
+{0x0F12, 0x0238},
+{0x0F12, 0x02CC},
+{0x0F12, 0x022C},
+{0x0F12, 0x02C0},
+{0x0F12, 0x0224},
+{0x0F12, 0x02B4},
+{0x0F12, 0x0222},
+{0x0F12, 0x02AA},
+{0x0F12, 0x0226},
+{0x0F12, 0x029E},
+{0x0F12, 0x022E},
+{0x0F12, 0x028E},
+{0x0F12, 0x0246},
+{0x0F12, 0x0276},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x0F12, 0x0004},	/*awbb_OutdoorGrZones_m_GridStep */
+{0x002A, 0x10AC},
+{0x0F12, 0x000B},	/*awbb_OutdoorGrZones_ZInfo_m_GridSz */
+{0x002A, 0x10B0},
+{0x0F12, 0x01D6},   /*awbb_OutdoorGrZones_m_Boffs */
+
+/* Low Brightness Zone */
+{0x002A, 0x10B4},
+{0x0F12, 0x0350},
+{0x0F12, 0x0422},
+{0x0F12, 0x02C4},
+{0x0F12, 0x0452},
+{0x0F12, 0x0278},
+{0x0F12, 0x041C},
+{0x0F12, 0x0230},
+{0x0F12, 0x03EE},
+{0x0F12, 0x01F0},
+{0x0F12, 0x0392},
+{0x0F12, 0x01C0},
+{0x0F12, 0x0340},
+{0x0F12, 0x0194},
+{0x0F12, 0x0302},
+{0x0F12, 0x016E},
+{0x0F12, 0x02C2},
+{0x0F12, 0x0148},
+{0x0F12, 0x0286},
+{0x0F12, 0x018A},
+{0x0F12, 0x0242},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},	/*awbb_LowBrGrZones_m_BGrid_11__m_left */
+{0x0F12, 0x0000},	/*awbb_LowBrGrZones_m_BGrid_11__m_right */
+
+{0x0F12, 0x0006},	/*awbb_LowBrGrZones_m_GridStep */
+{0x002A, 0x10E8},
+{0x0F12, 0x000A},   /*awbb_LowBrGrZones_ZInfo_m_GridSz */
+{0x002A, 0x10EC},
+{0x0F12, 0x0106},   /*awbb_LowBrGrZones_m_Boffs */
+
+/* Low Temp. Zone */
+{0x002A, 0x10F0},
+{0x0F12, 0x0380},
+{0x0F12, 0x0000},	/*awbb_CrclLowT_R_c */
+{0x0F12, 0x0168},
+{0x0F12, 0x0000},	/*awbb_CrclLowT_B_c */
+{0x0F12, 0x2D90},
+{0x0F12, 0x0000},	/*awbb_CrclLowT_Rad_c */
+
+/* AWB Convergence Speed */
+{0x002A, 0x1464},
+{0x0F12, 0x0008},	/*awbb_WpFilterMinThr */
+{0x0F12, 0x0190},	/*awbb_WpFilterMaxThr */
+{0x0F12, 0x00A0},	/*awbb_WpFilterCoef */
+
+{0x002A, 0x1228},
+{0x0F12, 0x00C0},
+{0x002A, 0x122C},
+{0x0F12, 0x0010},
+{0x002A, 0x122A},
+{0x0F12, 0x0010},
+{0x002A, 0x120A},
+{0x0F12, 0x05D5},   /*awbb_MvEq_RBthresh */
+{0x002A, 0x120E},
+{0x0F12, 0x0000},	/*awbb_MovingScale10 */
+
+{0x0F12, 0x0771},
+{0x0F12, 0x03A4},
+{0x0F12, 0x0036},
+{0x0F12, 0x002A},
+
+{0x002A, 0x1278},
+{0x0F12, 0xFEF7},	/*awbb_SCDetectionMap_SEC_StartR_B */
+{0x0F12, 0x0021},	/*awbb_SCDetectionMap_SEC_StepR_B */
+{0x0F12, 0x0AF0},   /*0E74 */
+{0x0F12, 0x0AF0},   /*0E74 */
+{0x0F12, 0x018F},
+{0x0F12, 0x0096},	/*awbb_SCDetectionMap_SEC_SunnyNBZone */
+{0x0F12, 0x000E},
+{0x002A, 0x1224},
+{0x0F12, 0x0032},	/*awbb_LowBr */
+{0x0F12, 0x001E},	/*awbb_LowBr_NBzone */
+{0x0F12, 0x00C0},
+{0x0F12, 0x0010},	/*awbb_YThreshLow_Norm */
+{0x0F12, 0x0002},	/*awbb_YThreshLow_Low */
+{0x002A, 0x2BA4},
+{0x0F12, 0x0006},   /*Mon_AWB_ByPassMode */
+
+{0x002A, 0x146C},
+{0x0F12, 0x0002},	/*awbb_GridEnable */
+
+/* Grid setting */
+{0x002A, 0x1434},
+{0x0F12, 0x02CE},   /* awbb_GridConst_1 */
+{0x0F12, 0x0347},   /* awbb_GridConst_1_1_ */
+{0x0F12, 0x03C2},   /* awbb_GridConst_1_2_ */
+{0x0F12, 0x10A0},   /* awbb_GridConst_2 */
+{0x0F12, 0x10A1},   /* awbb_GridConst_2_1_ */
+{0x0F12, 0x1185},   /* awbb_GridConst_2_2_ */
+{0x0F12, 0x1186},   /* awbb_GridConst_2_3_ */
+{0x0F12, 0x11E5},   /* awbb_GridConst_2_4_ */
+{0x0F12, 0x11E6},   /* awbb_GridConst_2_5_ */
+{0x0F12, 0x00AB},   /* awbb_GridCoeff_R_1 */
+{0x0F12, 0x00BF},   /* awbb_GridCoeff_B_1 */
+{0x0F12, 0x00D2},   /* awbb_GridCoeff_R_2 */
+{0x0F12, 0x0093},   /* awbb_GridCoeff_B_2 */
+
+	/*Indoor Grid Offset */
+{0x002A, 0x13A4},
+{0x0F12, 0x0000},  /*0000 */
+{0x0F12, 0xFFE8},  /*FFD8 */
+{0x0F12, 0xFFE8},  /*FFD8 */
+{0x0F12, 0xFFD8},  /*FFD8 */
+{0x0F12, 0xFFD8},  /*FFD8 */
+{0x0F12, 0xFFD0},  /*FFF6 B */
+
+{0x0F12, 0x0000},  /*0000 */
+{0x0F12, 0xFFE8},  /*FFD8 */
+{0x0F12, 0xFFE8},  /*FFD8 */
+{0x0F12, 0xFFD8},  /*FFD8 */
+{0x0F12, 0xFFD8},  /*FFD8 */
+{0x0F12, 0xFFD0},  /*FFF6 */
+
+{0x0F12, 0x0000},  /*0000 */
+{0x0F12, 0xFFE8},  /*FFD8 */
+{0x0F12, 0xFFE8},  /*FFD8 */
+{0x0F12, 0xFFD8},  /*FFD8 */
+{0x0F12, 0xFFD8},  /*FFD8 */
+{0x0F12, 0xFFD0},  /*FFF6 */
+
+{0x0F12, 0xFFEC},  /*FFEC */
+{0x0F12, 0x000A},  /*000A */
+{0x0F12, 0x000A},  /*000A */
+{0x0F12, 0xFFC4},  /*FFC4 */
+{0x0F12, 0xFFC4},  /*FFC4 */
+{0x0F12, 0xFF76},  /*FF56 7 */
+
+{0x0F12, 0xFFEC},  /*FFEC */
+{0x0F12, 0x000A},  /*000A */
+{0x0F12, 0x000A},  /*000A */
+{0x0F12, 0xFFC4},  /*FFC4 */
+{0x0F12, 0xFFC4},  /*FFC4 */
+{0x0F12, 0xFF76},  /*FF56 */
+
+{0x0F12, 0xFFEC},  /*FFEC */
+{0x0F12, 0x000A},  /*000A */
+{0x0F12, 0x000A},  /*000A */
+{0x0F12, 0xFFC4},  /*FFC4 */
+{0x0F12, 0xFFC4},  /*FFC4 */
+{0x0F12, 0xFF76},  /*FF56 */
+
+	/*Outdoor Grid Offset */
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x002A, 0x1410},
+{0x0F12, 0xFFA8},
+{0x0F12, 0xFFA8},
+{0x0F12, 0xFFA8},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x0F12, 0xFFA8},
+{0x0F12, 0xFFA8},
+{0x0F12, 0xFFA8},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x0F12, 0xFFA8},
+{0x0F12, 0xFFA8},
+{0x0F12, 0xFFA8},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+
+{0x002A, 0x1208},
+{0x0F12, 0x0020},
+
+{0x002A, 0x144E},
+{0x0F12, 0xFFE0},   /*awbb_RGainOff */
+{0x0F12, 0xFFE0},   /*awbb_BGainOff */
+{0x0F12, 0x0000},   /*awbb_GGainOff */
+
+/*=================================================================== */
+/* Gamma setting */
+/*=================================================================== */
+	/*RGB Indoor Gamma */
+{0x002A, 0x0734},
+{0x0F12, 0x0000},
+{0x0F12, 0x000A},
+{0x0F12, 0x0016},
+{0x0F12, 0x0030},
+{0x0F12, 0x0066},
+{0x0F12, 0x00D5},
+{0x0F12, 0x0138},
+{0x0F12, 0x0163},
+{0x0F12, 0x0189},
+{0x0F12, 0x01C6},
+{0x0F12, 0x01F8},
+{0x0F12, 0x0222},
+{0x0F12, 0x0247},
+{0x0F12, 0x0282},
+{0x0F12, 0x02B5},
+{0x0F12, 0x030F},
+{0x0F12, 0x035F},
+{0x0F12, 0x03A2},
+{0x0F12, 0x03D8},
+{0x0F12, 0x03FF},
+{0x0F12, 0x0000},
+{0x0F12, 0x000A},
+{0x0F12, 0x0016},
+{0x0F12, 0x0030},
+{0x0F12, 0x0066},
+{0x0F12, 0x00D5},
+{0x0F12, 0x0138},
+{0x0F12, 0x0163},
+{0x0F12, 0x0189},
+{0x0F12, 0x01C6},
+{0x0F12, 0x01F8},
+{0x0F12, 0x0222},
+{0x0F12, 0x0247},
+{0x0F12, 0x0282},
+{0x0F12, 0x02B5},
+{0x0F12, 0x030F},
+{0x0F12, 0x035F},
+{0x0F12, 0x03A2},
+{0x0F12, 0x03D8},
+{0x0F12, 0x03FF},
+{0x0F12, 0x0000},
+{0x0F12, 0x000A},
+{0x0F12, 0x0016},
+{0x0F12, 0x0030},
+{0x0F12, 0x0066},
+{0x0F12, 0x00D5},
+{0x0F12, 0x0138},
+{0x0F12, 0x0163},
+{0x0F12, 0x0189},
+{0x0F12, 0x01C6},
+{0x0F12, 0x01F8},
+{0x0F12, 0x0222},
+{0x0F12, 0x0247},
+{0x0F12, 0x0282},
+{0x0F12, 0x02B5},
+{0x0F12, 0x030F},
+{0x0F12, 0x035F},
+{0x0F12, 0x03A2},
+{0x0F12, 0x03D8},
+{0x0F12, 0x03FF},
+
+	/*RGB Outdoor Gamma */
+{0x0F12, 0x0000},
+{0x0F12, 0x0017},
+{0x0F12, 0x0028},
+{0x0F12, 0x0047},
+{0x0F12, 0x0080},
+{0x0F12, 0x00E0},
+{0x0F12, 0x0134},
+{0x0F12, 0x0159},
+{0x0F12, 0x017B},
+{0x0F12, 0x01B4},
+{0x0F12, 0x01E5},
+{0x0F12, 0x020F},
+{0x0F12, 0x0235},
+{0x0F12, 0x0279},
+{0x0F12, 0x02B6},
+{0x0F12, 0x0312},
+{0x0F12, 0x0358},
+{0x0F12, 0x0393},
+{0x0F12, 0x03C8},
+{0x0F12, 0x03FA},
+{0x0F12, 0x0000},
+{0x0F12, 0x0017},
+{0x0F12, 0x0028},
+{0x0F12, 0x0047},
+{0x0F12, 0x0080},
+{0x0F12, 0x00E0},
+{0x0F12, 0x0134},
+{0x0F12, 0x0159},
+{0x0F12, 0x017B},
+{0x0F12, 0x01B4},
+{0x0F12, 0x01E5},
+{0x0F12, 0x020F},
+{0x0F12, 0x0235},
+{0x0F12, 0x0279},
+{0x0F12, 0x02B6},
+{0x0F12, 0x0312},
+{0x0F12, 0x0358},
+{0x0F12, 0x0393},
+{0x0F12, 0x03C8},
+{0x0F12, 0x03FA},
+{0x0F12, 0x0000},
+{0x0F12, 0x0017},
+{0x0F12, 0x0028},
+{0x0F12, 0x0047},
+{0x0F12, 0x0080},
+{0x0F12, 0x00E0},
+{0x0F12, 0x0134},
+{0x0F12, 0x0159},
+{0x0F12, 0x017B},
+{0x0F12, 0x01B4},
+{0x0F12, 0x01E5},
+{0x0F12, 0x020F},
+{0x0F12, 0x0235},
+{0x0F12, 0x0279},
+{0x0F12, 0x02B6},
+{0x0F12, 0x0312},
+{0x0F12, 0x0358},
+{0x0F12, 0x0393},
+{0x0F12, 0x03C8},
+{0x0F12, 0x03FA},
+
+
+/*=================================================================== */
+/* CCM setting */
+/*=================================================================== */
+{0x002A, 0x08A6},
+{0x0F12, 0x00C0},
+{0x0F12, 0x0100},
+{0x0F12, 0x0125},
+{0x0F12, 0x015F},
+{0x0F12, 0x017C},
+{0x0F12, 0x0194},
+
+{0x0F12, 0x0001},	/*wbt_bUseOutdoorCCM */
+
+{0x002A, 0x0898},
+{0x0F12, 0x4800},
+{0x0F12, 0x7000},	/*TVAR_wbt_pBaseCcms */
+{0x002A, 0x08A0},
+{0x0F12, 0x48D8},
+{0x0F12, 0x7000},	/*TVAR_wbt_pOutdoorCcm */
+
+{0x002A, 0x4800},   /* Horizon */
+{0x0F12, 0x0208},
+{0x0F12, 0xFFB5},
+{0x0F12, 0xFFE8},
+{0x0F12, 0xFF20},
+{0x0F12, 0x01BF},
+{0x0F12, 0xFF53},
+{0x0F12, 0x0022},
+{0x0F12, 0xFFEA},
+{0x0F12, 0x01C2},
+{0x0F12, 0x00C6},
+{0x0F12, 0x0095},
+{0x0F12, 0xFEFD},
+{0x0F12, 0x0206},
+{0x0F12, 0xFF7F},
+{0x0F12, 0x0191},
+{0x0F12, 0xFF06},
+{0x0F12, 0x01BA},
+{0x0F12, 0x0108},
+
+{0x0F12, 0x0208},   /* inca A */
+{0x0F12, 0xFFB5},
+{0x0F12, 0xFFE8},
+{0x0F12, 0xFF20},
+{0x0F12, 0x01BF},
+{0x0F12, 0xFF53},
+{0x0F12, 0x0022},
+{0x0F12, 0xFFEA},
+{0x0F12, 0x01C2},
+{0x0F12, 0x00C6},
+{0x0F12, 0x0095},
+{0x0F12, 0xFEFD},
+{0x0F12, 0x0206},
+{0x0F12, 0xFF7F},
+{0x0F12, 0x0191},
+{0x0F12, 0xFF06},
+{0x0F12, 0x01BA},
+{0x0F12, 0x0108},
+
+{0x0F12, 0x0208},   /* WW */
+{0x0F12, 0xFFB5},
+{0x0F12, 0xFFE8},
+{0x0F12, 0xFF20},
+{0x0F12, 0x01BF},
+{0x0F12, 0xFF53},
+{0x0F12, 0x0022},
+{0x0F12, 0xFFEA},
+{0x0F12, 0x01C2},
+{0x0F12, 0x00C6},
+{0x0F12, 0x0095},
+{0x0F12, 0xFEFD},
+{0x0F12, 0x0206},
+{0x0F12, 0xFF7F},
+{0x0F12, 0x0191},
+{0x0F12, 0xFF06},
+{0x0F12, 0x01BA},
+{0x0F12, 0x0108},
+
+{0x0F12, 0x0204},	/*TVAR_wbt_pBaseCcms[54] CW */
+{0x0F12, 0xFFB2},	/*TVAR_wbt_pBaseCcms[55] */
+{0x0F12, 0xFFF5},	/*TVAR_wbt_pBaseCcms[56] */
+{0x0F12, 0xFEF1},	/*TVAR_wbt_pBaseCcms[57] */
+{0x0F12, 0x014E},	/*TVAR_wbt_pBaseCcms[58] */
+{0x0F12, 0xFF18},	/*TVAR_wbt_pBaseCcms[59] */
+{0x0F12, 0xFFE6},	/*TVAR_wbt_pBaseCcms[60] */
+{0x0F12, 0xFFDD},	/*TVAR_wbt_pBaseCcms[61] */
+{0x0F12, 0x01B2},	/*TVAR_wbt_pBaseCcms[62] */
+{0x0F12, 0x00F2},	/*TVAR_wbt_pBaseCcms[63] */
+{0x0F12, 0x00CA},	/*TVAR_wbt_pBaseCcms[64] */
+{0x0F12, 0xFF48},	/*TVAR_wbt_pBaseCcms[65] */
+{0x0F12, 0x0151},	/*TVAR_wbt_pBaseCcms[66] */
+{0x0F12, 0xFF50},	/*TVAR_wbt_pBaseCcms[67] */
+{0x0F12, 0x0147},	/*TVAR_wbt_pBaseCcms[68] */
+{0x0F12, 0xFF75},	/*TVAR_wbt_pBaseCcms[69] */
+{0x0F12, 0x0187},	/*TVAR_wbt_pBaseCcms[70] */
+{0x0F12, 0x01BF},	/*TVAR_wbt_pBaseCcms[71] */
+
+{0x0F12, 0x0204},	/*TVAR_wbt_pBaseCcms[72] D50 */
+{0x0F12, 0xFFB2},	/*TVAR_wbt_pBaseCcms[73] */
+{0x0F12, 0xFFF5},	/*TVAR_wbt_pBaseCcms[74] */
+{0x0F12, 0xFEF1},	/*TVAR_wbt_pBaseCcms[75] */
+{0x0F12, 0x014E},	/*TVAR_wbt_pBaseCcms[76] */
+{0x0F12, 0xFF18},	/*TVAR_wbt_pBaseCcms[77] */
+{0x0F12, 0xFFE6},	/*TVAR_wbt_pBaseCcms[78] */
+{0x0F12, 0xFFDD},	/*TVAR_wbt_pBaseCcms[79] */
+{0x0F12, 0x01B2},	/*TVAR_wbt_pBaseCcms[80] */
+{0x0F12, 0x00F2},	/*TVAR_wbt_pBaseCcms[81] */
+{0x0F12, 0x00CA},	/*TVAR_wbt_pBaseCcms[82] */
+{0x0F12, 0xFF48},	/*TVAR_wbt_pBaseCcms[83] */
+{0x0F12, 0x0151},	/*TVAR_wbt_pBaseCcms[84] */
+{0x0F12, 0xFF50},	/*TVAR_wbt_pBaseCcms[85] */
+{0x0F12, 0x0147},	/*TVAR_wbt_pBaseCcms[86] */
+{0x0F12, 0xFF75},	/*TVAR_wbt_pBaseCcms[87] */
+{0x0F12, 0x0187},	/*TVAR_wbt_pBaseCcms[88] */
+{0x0F12, 0x01BF},	/*TVAR_wbt_pBaseCcms[89] */
+
+{0x0F12, 0x0204},	/*TVAR_wbt_pBaseCcms[90] D65 */
+{0x0F12, 0xFFB2},	/*TVAR_wbt_pBaseCcms[91] */
+{0x0F12, 0xFFF5},	/*TVAR_wbt_pBaseCcms[92] */
+{0x0F12, 0xFEF1},	/*TVAR_wbt_pBaseCcms[93] */
+{0x0F12, 0x014E},	/*TVAR_wbt_pBaseCcms[94] */
+{0x0F12, 0xFF18},	/*TVAR_wbt_pBaseCcms[95] */
+{0x0F12, 0xFFE6},	/*TVAR_wbt_pBaseCcms[96] */
+{0x0F12, 0xFFDD},	/*TVAR_wbt_pBaseCcms[97] */
+{0x0F12, 0x01B2},	/*TVAR_wbt_pBaseCcms[98] */
+{0x0F12, 0x00F2},	/*TVAR_wbt_pBaseCcms[99] */
+{0x0F12, 0x00CA},	/*TVAR_wbt_pBaseCcms[100] */
+{0x0F12, 0xFF48},	/*TVAR_wbt_pBaseCcms[101] */
+{0x0F12, 0x0151},	/*TVAR_wbt_pBaseCcms[102] */
+{0x0F12, 0xFF50},	/*TVAR_wbt_pBaseCcms[103] */
+{0x0F12, 0x0147},	/*TVAR_wbt_pBaseCcms[104] */
+{0x0F12, 0xFF75},	/*TVAR_wbt_pBaseCcms[105] */
+{0x0F12, 0x0187},	/*TVAR_wbt_pBaseCcms[106] */
+{0x0F12, 0x01BF},	/*TVAR_wbt_pBaseCcms[107] */
+
+{0x0F12, 0x01E5},	/*TVAR_wbt_pOutdoorCcm[0] */
+{0x0F12, 0xFFA4},	/*TVAR_wbt_pOutdoorCcm[1] */
+{0x0F12, 0xFFDC},	/*TVAR_wbt_pOutdoorCcm[2] */
+{0x0F12, 0xFE90},
+{0x0F12, 0x013F},
+{0x0F12, 0xFF1B},
+{0x0F12, 0xFFD2},	/*TVAR_wbt_pOutdoorCcm[6] */
+{0x0F12, 0xFFDF},	/*TVAR_wbt_pOutdoorCcm[7] */
+{0x0F12, 0x0236},	/*TVAR_wbt_pOutdoorCcm[8] */
+{0x0F12, 0x00EC},	/*TVAR_wbt_pOutdoorCcm[9] */
+{0x0F12, 0x00F8},	/*TVAR_wbt_pOutdoorCcm[10] */
+{0x0F12, 0xFF34},	/*TVAR_wbt_pOutdoorCcm[11] */
+{0x0F12, 0x01CE},	/*TVAR_wbt_pOutdoorCcm[12] */
+{0x0F12, 0xFF83},	/*TVAR_wbt_pOutdoorCcm[13] */
+{0x0F12, 0x0195},	/*TVAR_wbt_pOutdoorCcm[14] */
+{0x0F12, 0xFEF3},	/*TVAR_wbt_pOutdoorCcm[15] */
+{0x0F12, 0x0126},	/*TVAR_wbt_pOutdoorCcm[16] */
+{0x0F12, 0x0162},	/*TVAR_wbt_pOutdoorCcm[17] */
+
+
+/*=================================================================== */
+/* AFIT setting */
+/*=================================================================== */
+/* Noise Index setting */
+{0x002A, 0x0944},
+{0x0F12, 0x004B},	/*afit_uNoiseIndInDoor_0_ */
+{0x0F12, 0x0092},	/*afit_uNoiseIndInDoor_1_ */
+{0x0F12, 0x0196},	/*afit_uNoiseIndInDoor_2_ */
+{0x0F12, 0x0217},	/*afit_uNoiseIndInDoor_3_ */
+{0x0F12, 0x02B0},	/*afit_uNoiseIndInDoor_4_ */
+
+{0x002A, 0x097A},
+{0x0F12, 0x0000},	/*afit_bUseSenBpr */
+{0x0F12, 0x01CC},	/*afit_usBprThr_0_ */
+{0x0F12, 0x01CC},	/*afit_usBprThr_1_ */
+{0x0F12, 0x01CC},	/*afit_usBprThr_2_ */
+{0x0F12, 0x01CC},	/*afit_usBprThr_3_ */
+{0x0F12, 0x01CC},	/*afit_usBprThr_4_ */
+{0x0F12, 0x0180},	/*afit_NIContrastAFITValue */
+{0x0F12, 0x0196},	/*afit_NIContrastTh */
+
+{0x002A, 0x0976},
+{0x0F12, 0x0070},	/*afit_usGamutTh */
+{0x0F12, 0x0005},	/*afit_usNeargrayOffset */
+
+/* Normal Brightness setting */
+{0x002A, 0x0938},
+{0x0F12, 0x0000},	/*afit_bUseNB_Afit */
+{0x0F12, 0x0014},	/*SARR_uNormBrInDoor_0_ */
+{0x0F12, 0x00D2},	/*SARR_uNormBrInDoor_1_ */
+{0x0F12, 0x0384},	/*SARR_uNormBrInDoor_2_ */
+{0x0F12, 0x07D0},	/*SARR_uNormBrInDoor_3_ */
+{0x0F12, 0x1388},	/*SARR_uNormBrInDoor_4_ */
+
+{0x002A, 0x098C},
+	/*AFIT 0 */
+{0x0F12, 0x0000},   /*7000098C AFIT16_BRIGHTNESS */
+{0x0F12, 0x0000},   /*7000098E AFIT16_CONTRAST */
+{0x0F12, 0x0000},   /*70000990 AFIT16_SATURATION */
+{0x0F12, 0x0000},   /*70000992 AFIT16_SHARP_BLUR */
+{0x0F12, 0x0000},   /*70000994 AFIT16_GLAMOUR */
+{0x0F12, 0x00C0},   /*70000996 AFIT16_bnr_edge_high */
+{0x0F12, 0x0064},   /*70000998 AFIT16_postdmsc_iLowBright */
+{0x0F12, 0x0384},   /*7000099A AFIT16_postdmsc_iHighBright */
+{0x0F12, 0x005F},   /*7000099C AFIT16_postdmsc_iLowSat */
+{0x0F12, 0x01F4},   /*7000099E AFIT16_postdmsc_iHighSat */
+{0x0F12, 0x0070},   /*700009A0 AFIT16_postdmsc_iTune */
+{0x0F12, 0x0040},   /*700009A2 AFIT16_yuvemix_mNegRanges_0 */
+{0x0F12, 0x00A0},   /*700009A4 AFIT16_yuvemix_mNegRanges_1 */
+{0x0F12, 0x0100},   /*700009A6 AFIT16_yuvemix_mNegRanges_2 */
+{0x0F12, 0x0010},   /*700009A8 AFIT16_yuvemix_mPosRanges_0 */
+{0x0F12, 0x0040},   /*700009AA AFIT16_yuvemix_mPosRanges_1 */
+{0x0F12, 0x00A0},   /*700009AC AFIT16_yuvemix_mPosRanges_2 */
+{0x0F12, 0x1430},   /*700009AE AFIT8_bnr_edge_low
+[7:0] AFIT8_bnr_repl_thresh */
+{0x0F12, 0x0201},   /*700009B0 AFIT8_bnr_repl_force
+[7:0] AFIT8_bnr_iHotThreshHigh */
+{0x0F12, 0x0204},   /*700009B2 AFIT8_bnr_iHotThreshLow
+[7:0] AFIT8_bnr_iColdThreshHigh */
+{0x0F12, 0x3604},   /*700009B4 AFIT8_bnr_iColdThreshLow
+[7:0] AFIT8_bnr_DispTH_Low */
+{0x0F12, 0x032A},   /*700009B6 AFIT8_bnr_DispTH_High
+[7:0] AFIT8_bnr_DISP_Limit_Low */
+{0x0F12, 0x0403},   /*700009B8 AFIT8_bnr_DISP_Limit_High
+[7:0] AFIT8_bnr_iDistSigmaMin */
+{0x0F12, 0x1B06},   /*700009BA AFIT8_bnr_iDistSigmaMax
+[7:0] AFIT8_bnr_iDiffSigmaLow */
+{0x0F12, 0x6015},   /*700009BC AFIT8_bnr_iDiffSigmaHigh
+[7:0] AFIT8_bnr_iNormalizedSTD_TH */
+{0x0F12, 0x00C0},   /*700009BE AFIT8_bnr_iNormalizedSTD_Limit
+[7:0] AFIT8_bnr_iDirNRTune */
+{0x0F12, 0x6080},   /*700009C0 AFIT8_bnr_iDirMinThres
+[7:0] AFIT8_bnr_iDirFltDiffThresHigh */
+{0x0F12, 0x4080},   /*700009C2 AFIT8_bnr_iDirFltDiffThresLow
+[7:0] AFIT8_bnr_iDirSmoothPowerHigh */
+{0x0F12, 0x0640},   /*700009C4 AFIT8_bnr_iDirSmoothPowerLow
+[7:0] AFIT8_bnr_iLowMaxSlopeAllowed */
+{0x0F12, 0x0306},   /*700009C6 AFIT8_bnr_iHighMaxSlopeAllowed
+[7:0] AFIT8_bnr_iLowSlopeThresh */
+{0x0F12, 0x2003},   /*700009C8 AFIT8_bnr_iHighSlopeThresh
+[7:0] AFIT8_bnr_iSlopenessTH */
+{0x0F12, 0xFF01},   /*700009CA AFIT8_bnr_iSlopeBlurStrength
+[7:0] AFIT8_bnr_iSlopenessLimit */
+{0x0F12, 0x0000},   /*700009CC AFIT8_bnr_AddNoisePower1
+[7:0] AFIT8_bnr_AddNoisePower2 */
+{0x0F12, 0x0400},   /*700009CE AFIT8_bnr_iRadialTune
+[7:0] AFIT8_bnr_iRadialPower */
+{0x0F12, 0x365A},   /*700009D0 AFIT8_bnr_iRadialLimit
+[7:0] AFIT8_ee_iFSMagThLow */
+{0x0F12, 0x102A},   /*700009D2 AFIT8_ee_iFSMagThHigh
+[7:0] AFIT8_ee_iFSVarThLow */
+{0x0F12, 0x000B},   /*700009D4 AFIT8_ee_iFSVarThHigh
+[7:0] AFIT8_ee_iFSThLow */
+{0x0F12, 0x0600},   /*700009D6 AFIT8_ee_iFSThHigh
+[7:0] AFIT8_ee_iFSmagPower */
+{0x0F12, 0x5A0F},   /*700009D8 AFIT8_ee_iFSVarCountTh
+[7:0] AFIT8_ee_iRadialLimit */
+{0x0F12, 0x0505},   /*700009DA AFIT8_ee_iRadialPower
+[7:0] AFIT8_ee_iSmoothEdgeSlope */
+{0x0F12, 0x1802},   /*700009DC AFIT8_ee_iROADThres
+[7:0] AFIT8_ee_iROADMaxNR */
+{0x0F12, 0x0000},   /*700009DE AFIT8_ee_iROADSubMaxNR
+[7:0] AFIT8_ee_iROADSubThres */
+{0x0F12, 0x2006},   /*700009E0 AFIT8_ee_iROADNeiThres
+[7:0] AFIT8_ee_iROADNeiMaxNR */
+{0x0F12, 0x3028},   /*700009E2 AFIT8_ee_iSmoothEdgeThres
+[7:0] AFIT8_ee_iMSharpen */
+{0x0F12, 0x0418},   /*700009E4 AFIT8_ee_iWSharpen
+[7:0] AFIT8_ee_iMShThresh */
+{0x0F12, 0x0101},   /*700009E6 AFIT8_ee_iWShThresh
+[7:0] AFIT8_ee_iReduceNegative */
+{0x0F12, 0x0800},   /*700009E8 AFIT8_ee_iEmbossCentAdd
+[7:0] AFIT8_ee_iShDespeckle */
+{0x0F12, 0x1804},   /*700009EA AFIT8_ee_iReduceEdgeThresh
+[7:0] AFIT8_dmsc_iEnhThresh */
+{0x0F12, 0x4008},   /*700009EC AFIT8_dmsc_iDesatThresh
+[7:0] AFIT8_dmsc_iDemBlurHigh */
+{0x0F12, 0x0540},   /*700009EE AFIT8_dmsc_iDemBlurLow
+[7:0] AFIT8_dmsc_iDemBlurRange */
+{0x0F12, 0x8006},   /*700009F0 AFIT8_dmsc_iDecisionThresh
+[7:0] AFIT8_dmsc_iCentGrad */
+{0x0F12, 0x0020},   /*700009F2 AFIT8_dmsc_iMonochrom
+[7:0] AFIT8_dmsc_iGBDenoiseVal */
+{0x0F12, 0x0000},   /*700009F4 AFIT8_dmsc_iGRDenoiseVal
+[7:0] AFIT8_dmsc_iEdgeDesatThrHigh */
+{0x0F12, 0x1800},   /*700009F6 AFIT8_dmsc_iEdgeDesatThrLow
+[7:0] AFIT8_dmsc_iEdgeDesat */
+{0x0F12, 0x0000},   /*700009F8 AFIT8_dmsc_iNearGrayDesat
+[7:0] AFIT8_dmsc_iEdgeDesatLimit */
+{0x0F12, 0x1E10},   /*700009FA AFIT8_postdmsc_iBCoeff
+[7:0] AFIT8_postdmsc_iGCoeff */
+{0x0F12, 0x000B},   /*700009FC AFIT8_postdmsc_iWideMult
+[7:0] AFIT8_yuvemix_mNegSlopes_0 */
+{0x0F12, 0x0607},   /*700009FE AFIT8_yuvemix_mNegSlopes_1
+[7:0] AFIT8_yuvemix_mNegSlopes_2 */
+{0x0F12, 0x0005},   /*70000A00 AFIT8_yuvemix_mNegSlopes_3
+[7:0] AFIT8_yuvemix_mPosSlopes_0 */
+{0x0F12, 0x0607},   /*70000A02 AFIT8_yuvemix_mPosSlopes_1
+[7:0] AFIT8_yuvemix_mPosSlopes_2 */
+{0x0F12, 0x0405},   /*70000A04 AFIT8_yuvemix_mPosSlopes_3
+[7:0] AFIT8_yuviirnr_iXSupportY */
+{0x0F12, 0x0205},   /*70000A06 AFIT8_yuviirnr_iXSupportUV
+[7:0] AFIT8_yuviirnr_iLowYNorm */
+{0x0F12, 0x0304},   /*70000A08 AFIT8_yuviirnr_iHighYNorm
+[7:0] AFIT8_yuviirnr_iLowUVNorm */
+{0x0F12, 0x0409},   /*70000A0A AFIT8_yuviirnr_iHighUVNorm
+[7:0] AFIT8_yuviirnr_iYNormShift */
+{0x0F12, 0x0306},   /*70000A0C AFIT8_yuviirnr_iUVNormShift
+[7:0] AFIT8_yuviirnr_iVertLength_Y */
+{0x0F12, 0x0407},   /*70000A0E AFIT8_yuviirnr_iVertLength_UV
+[7:0] AFIT8_yuviirnr_iDiffThreshL_Y */
+{0x0F12, 0x1C04},   /*70000A10 AFIT8_yuviirnr_iDiffThreshH_Y
+[7:0] AFIT8_yuviirnr_iDiffThreshL_UV */
+{0x0F12, 0x0214},   /*70000A12 AFIT8_yuviirnr_iDiffThreshH_UV
+[7:0] AFIT8_yuviirnr_iMaxThreshL_Y */
+{0x0F12, 0x1002},   /*70000A14 AFIT8_yuviirnr_iMaxThreshH_Y
+[7:0] AFIT8_yuviirnr_iMaxThreshL_UV */
+{0x0F12, 0x0610},   /*70000A16 AFIT8_yuviirnr_iMaxThreshH_UV
+[7:0] AFIT8_yuviirnr_iYNRStrengthL */
+{0x0F12, 0x1A02},   /*70000A18 AFIT8_yuviirnr_iYNRStrengthH
+[7:0] AFIT8_yuviirnr_iUVNRStrengthL */
+{0x0F12, 0x4A18},   /*70000A1A AFIT8_yuviirnr_iUVNRStrengthH
+[7:0] AFIT8_byr_gras_iShadingPower */
+{0x0F12, 0x0080},   /*70000A1C AFIT8_RGBGamma2_iLinearity
+[7:0] AFIT8_RGBGamma2_iDarkReduce */
+{0x0F12, 0x0348},   /*70000A1E AFIT8_ccm_oscar_iSaturation
+[7:0] AFIT8_RGB2YUV_iYOffset */
+{0x0F12, 0x0180},   /*70000A20 AFIT8_RGB2YUV_iRGBGain
+[7:0] AFIT8_bnr_nClustLevel_H */
+{0x0F12, 0x0A0A},   /*70000A22 AFIT8_bnr_iClustMulT_H
+[7:0] AFIT8_bnr_iClustMulT_C */
+{0x0F12, 0x0101},   /*70000A24 AFIT8_bnr_iClustThresh_H
+[7:0] AFIT8_bnr_iClustThresh_C */
+{0x0F12, 0x2028},   /*70000A26 AFIT8_bnr_iDenThreshLow
+[7:0] AFIT8_bnr_iDenThreshHigh */
+{0x0F12, 0x6024},   /*70000A28 AFIT8_ee_iLowSharpPower
+[7:0] AFIT8_ee_iHighSharpPower */
+{0x0F12, 0x2A36},   /*70000A2A AFIT8_ee_iLowShDenoise
+[7:0] AFIT8_ee_iHighShDenoise */
+{0x0F12, 0xFFFF},   /*70000A2C AFIT8_ee_iLowSharpClamp
+[7:0] AFIT8_ee_iHighSharpClamp */
+{0x0F12, 0x0808},   /*70000A2E AFIT8_ee_iReduceEdgeMinMult
+[7:0] AFIT8_ee_iReduceEdgeSlope */
+{0x0F12, 0x0A01},   /*70000A30 AFIT8_bnr_nClustLevel_H_Bin
+[7:0] AFIT8_bnr_iClustMulT_H_Bin */
+{0x0F12, 0x010A},   /*70000A32 AFIT8_bnr_iClustMulT_C_Bin
+[7:0] AFIT8_bnr_iClustThresh_H_Bin */
+{0x0F12, 0x3601},   /*70000A34 AFIT8_bnr_iClustThresh_C_Bin
+[7:0] AFIT8_bnr_iDenThreshLow_Bin */
+{0x0F12, 0x242A},   /*70000A36 AFIT8_bnr_iDenThreshHigh_Bin
+[7:0] AFIT8_ee_iLowSharpPower_Bin */
+{0x0F12, 0x3660},   /*70000A38 AFIT8_ee_iHighSharpPower_Bin
+[7:0] AFIT8_ee_iLowShDenoise_Bin */
+{0x0F12, 0xFF2A},   /*70000A3A AFIT8_ee_iHighShDenoise_Bin
+[7:0] AFIT8_ee_iLowSharpClamp_Bin */
+{0x0F12, 0x08FF},   /*70000A3C AFIT8_ee_iHighSharpClamp_Bin
+[7:0] AFIT8_ee_iReduceEdgeMinMult_Bin */
+{0x0F12, 0x0008},   /*70000A3E AFIT8_ee_iReduceEdgeSlope_Bin
+[7:0] */
+{0x0F12, 0x0001},   /*70000A40 AFITB_bnr_nClustLevel_C      [0] */
+
+	/*AFIT 1 */
+{0x0F12, 0x0000},   /*70000A42 AFIT16_BRIGHTNESS */
+{0x0F12, 0x0000},   /*70000A44 AFIT16_CONTRAST */
+{0x0F12, 0x0000},   /*70000A46 AFIT16_SATURATION */
+{0x0F12, 0x0000},   /*70000A48 AFIT16_SHARP_BLUR */
+{0x0F12, 0x0000},   /*70000A4A AFIT16_GLAMOUR */
+{0x0F12, 0x00C0},   /*70000A4C AFIT16_bnr_edge_high */
+{0x0F12, 0x0064},   /*70000A4E AFIT16_postdmsc_iLowBright */
+{0x0F12, 0x0384},   /*70000A50 AFIT16_postdmsc_iHighBright */
+{0x0F12, 0x0051},   /*70000A52 AFIT16_postdmsc_iLowSat */
+{0x0F12, 0x01F4},   /*70000A54 AFIT16_postdmsc_iHighSat */
+{0x0F12, 0x0070},   /*70000A56 AFIT16_postdmsc_iTune */
+{0x0F12, 0x0040},   /*70000A58 AFIT16_yuvemix_mNegRanges_0 */
+{0x0F12, 0x00A0},   /*70000A5A AFIT16_yuvemix_mNegRanges_1 */
+{0x0F12, 0x0100},   /*70000A5C AFIT16_yuvemix_mNegRanges_2 */
+{0x0F12, 0x0010},   /*70000A5E AFIT16_yuvemix_mPosRanges_0 */
+{0x0F12, 0x0060},   /*70000A60 AFIT16_yuvemix_mPosRanges_1 */
+{0x0F12, 0x0100},   /*70000A62 AFIT16_yuvemix_mPosRanges_2 */
+{0x0F12, 0x1430},   /*70000A64 AFIT8_bnr_edge_low
+[7:0] AFIT8_bnr_repl_thresh */
+{0x0F12, 0x0201},   /*70000A66 AFIT8_bnr_repl_force
+[7:0] AFIT8_bnr_iHotThreshHigh */
+{0x0F12, 0x0204},   /*70000A68 AFIT8_bnr_iHotThreshLow
+[7:0] AFIT8_bnr_iColdThreshHigh */
+{0x0F12, 0x2404},   /*70000A6A AFIT8_bnr_iColdThreshLow
+[7:0] AFIT8_bnr_DispTH_Low */
+{0x0F12, 0x031B},   /*70000A6C AFIT8_bnr_DispTH_High
+[7:0] AFIT8_bnr_DISP_Limit_Low */
+{0x0F12, 0x0103},   /*70000A6E AFIT8_bnr_DISP_Limit_High
+[7:0] AFIT8_bnr_iDistSigmaMin */
+{0x0F12, 0x1205},   /*70000A70 AFIT8_bnr_iDistSigmaMax
+[7:0] AFIT8_bnr_iDiffSigmaLow */
+{0x0F12, 0x400D},   /*70000A72 AFIT8_bnr_iDiffSigmaHigh
+[7:0] AFIT8_bnr_iNormalizedSTD_TH */
+{0x0F12, 0x0080},   /*70000A74 AFIT8_bnr_iNormalizedSTD_Limit
+[7:0] AFIT8_bnr_iDirNRTune */
+{0x0F12, 0x2080},   /*70000A76 AFIT8_bnr_iDirMinThres
+[7:0] AFIT8_bnr_iDirFltDiffThresHigh */
+{0x0F12, 0x3040},   /*70000A78 AFIT8_bnr_iDirFltDiffThresLow
+[7:0] AFIT8_bnr_iDirSmoothPowerHigh */
+{0x0F12, 0x0630},   /*70000A7A AFIT8_bnr_iDirSmoothPowerLow
+[7:0] AFIT8_bnr_iLowMaxSlopeAllowed */
+{0x0F12, 0x0306},   /*70000A7C AFIT8_bnr_iHighMaxSlopeAllowed
+[7:0] AFIT8_bnr_iLowSlopeThresh */
+{0x0F12, 0x2003},   /*70000A7E AFIT8_bnr_iHighSlopeThresh
+[7:0] AFIT8_bnr_iSlopenessTH */
+{0x0F12, 0xFF01},   /*70000A80 AFIT8_bnr_iSlopeBlurStrength
+[7:0] AFIT8_bnr_iSlopenessLimit */
+{0x0F12, 0x0404},   /*70000A82 AFIT8_bnr_AddNoisePower1
+[7:0] AFIT8_bnr_AddNoisePower2 */
+{0x0F12, 0x0300},   /*70000A84 AFIT8_bnr_iRadialTune
+[7:0] AFIT8_bnr_iRadialPower */
+{0x0F12, 0x245A},   /*70000A86 AFIT8_bnr_iRadialLimit
+[7:0] AFIT8_ee_iFSMagThLow */
+{0x0F12, 0x1018},   /*70000A88 AFIT8_ee_iFSMagThHigh
+[7:0] AFIT8_ee_iFSVarThLow */
+{0x0F12, 0x000B},   /*70000A8A AFIT8_ee_iFSVarThHigh
+[7:0] AFIT8_ee_iFSThLow */
+{0x0F12, 0x0B00},   /*70000A8C AFIT8_ee_iFSThHigh
+[7:0] AFIT8_ee_iFSmagPower */
+{0x0F12, 0x5A0F},   /*70000A8E AFIT8_ee_iFSVarCountTh
+[7:0] AFIT8_ee_iRadialLimit */
+{0x0F12, 0x0505},   /*70000A90 AFIT8_ee_iRadialPower
+[7:0] AFIT8_ee_iSmoothEdgeSlope */
+{0x0F12, 0x1802},   /*70000A92 AFIT8_ee_iROADThres
+[7:0] AFIT8_ee_iROADMaxNR */
+{0x0F12, 0x0000},   /*70000A94 AFIT8_ee_iROADSubMaxNR
+[7:0] AFIT8_ee_iROADSubThres */
+{0x0F12, 0x2006},   /*70000A96 AFIT8_ee_iROADNeiThres
+[7:0] AFIT8_ee_iROADNeiMaxNR */
+{0x0F12, 0x3428},   /*70000A98 AFIT8_ee_iSmoothEdgeThres
+[7:0] AFIT8_ee_iMSharpen */
+{0x0F12, 0x041C},   /*70000A9A AFIT8_ee_iWSharpen
+[7:0] AFIT8_ee_iMShThresh */
+{0x0F12, 0x0101},   /*70000A9C AFIT8_ee_iWShThresh
+[7:0] AFIT8_ee_iReduceNegative */
+{0x0F12, 0x0800},   /*70000A9E AFIT8_ee_iEmbossCentAdd
+[7:0] AFIT8_ee_iShDespeckle */
+{0x0F12, 0x1004},   /*70000AA0 AFIT8_ee_iReduceEdgeThresh
+[7:0] AFIT8_dmsc_iEnhThresh */
+{0x0F12, 0x4008},   /*70000AA2 AFIT8_dmsc_iDesatThresh
+[7:0] AFIT8_dmsc_iDemBlurHigh */
+{0x0F12, 0x0540},   /*70000AA4 AFIT8_dmsc_iDemBlurLow
+[7:0] AFIT8_dmsc_iDemBlurRange */
+{0x0F12, 0x8006},   /*70000AA6 AFIT8_dmsc_iDecisionThresh
+[7:0] AFIT8_dmsc_iCentGrad */
+{0x0F12, 0x0020},   /*70000AA8 AFIT8_dmsc_iMonochrom
+[7:0] AFIT8_dmsc_iGBDenoiseVal */
+{0x0F12, 0x0000},   /*70000AAA AFIT8_dmsc_iGRDenoiseVal
+[7:0] AFIT8_dmsc_iEdgeDesatThrHigh */
+{0x0F12, 0x1800},   /*70000AAC AFIT8_dmsc_iEdgeDesatThrLow
+[7:0] AFIT8_dmsc_iEdgeDesat */
+{0x0F12, 0x0000},   /*70000AAE AFIT8_dmsc_iNearGrayDesat
+[7:0] AFIT8_dmsc_iEdgeDesatLimit */
+{0x0F12, 0x1E10},   /*70000AB0 AFIT8_postdmsc_iBCoeff
+[7:0] AFIT8_postdmsc_iGCoeff */
+{0x0F12, 0x000B},   /*70000AB2 AFIT8_postdmsc_iWideMult
+[7:0] AFIT8_yuvemix_mNegSlopes_0 */
+{0x0F12, 0x0607},   /*70000AB4 AFIT8_yuvemix_mNegSlopes_1
+[7:0] AFIT8_yuvemix_mNegSlopes_2 */
+{0x0F12, 0x0005},   /*70000AB6 AFIT8_yuvemix_mNegSlopes_3
+[7:0] AFIT8_yuvemix_mPosSlopes_0 */
+{0x0F12, 0x0607},   /*70000AB8 AFIT8_yuvemix_mPosSlopes_1
+[7:0] AFIT8_yuvemix_mPosSlopes_2 */
+{0x0F12, 0x0405},   /*70000ABA AFIT8_yuvemix_mPosSlopes_3
+[7:0] AFIT8_yuviirnr_iXSupportY */
+{0x0F12, 0x0205},   /*70000ABC AFIT8_yuviirnr_iXSupportUV
+[7:0] AFIT8_yuviirnr_iLowYNorm */
+{0x0F12, 0x0304},   /*70000ABE AFIT8_yuviirnr_iHighYNorm
+[7:0] AFIT8_yuviirnr_iLowUVNorm */
+{0x0F12, 0x0409},   /*70000AC0 AFIT8_yuviirnr_iHighUVNorm
+[7:0] AFIT8_yuviirnr_iYNormShift */
+{0x0F12, 0x0306},   /*70000AC2 AFIT8_yuviirnr_iUVNormShift
+[7:0] AFIT8_yuviirnr_iVertLength_Y */
+{0x0F12, 0x0407},   /*70000AC4 AFIT8_yuviirnr_iVertLength_UV
+[7:0] AFIT8_yuviirnr_iDiffThreshL_Y */
+{0x0F12, 0x1F04},   /*70000AC6 AFIT8_yuviirnr_iDiffThreshH_Y
+[7:0] AFIT8_yuviirnr_iDiffThreshL_UV */
+{0x0F12, 0x0218},   /*70000AC8 AFIT8_yuviirnr_iDiffThreshH_UV
+[7:0] AFIT8_yuviirnr_iMaxThreshL_Y */
+{0x0F12, 0x1102},   /*70000ACA AFIT8_yuviirnr_iMaxThreshH_Y
+[7:0] AFIT8_yuviirnr_iMaxThreshL_UV */
+{0x0F12, 0x0611},   /*70000ACC AFIT8_yuviirnr_iMaxThreshH_UV
+[7:0] AFIT8_yuviirnr_iYNRStrengthL */
+{0x0F12, 0x1A02},   /*70000ACE AFIT8_yuviirnr_iYNRStrengthH
+[7:0] AFIT8_yuviirnr_iUVNRStrengthL */
+{0x0F12, 0x8018},   /*70000AD0 AFIT8_yuviirnr_iUVNRStrengthH
+[7:0] AFIT8_byr_gras_iShadingPower */
+{0x0F12, 0x0080},   /*70000AD2 AFIT8_RGBGamma2_iLinearity
+[7:0] AFIT8_RGBGamma2_iDarkReduce */
+{0x0F12, 0x0380},   /*70000AD4 AFIT8_ccm_oscar_iSaturation
+[7:0] AFIT8_RGB2YUV_iYOffset */
+{0x0F12, 0x0180},   /*70000AD6 AFIT8_RGB2YUV_iRGBGain
+[7:0] AFIT8_bnr_nClustLevel_H */
+{0x0F12, 0x0A0A},   /*70000AD8 AFIT8_bnr_iClustMulT_H
+[7:0] AFIT8_bnr_iClustMulT_C */
+{0x0F12, 0x0101},   /*70000ADA AFIT8_bnr_iClustThresh_H
+[7:0] AFIT8_bnr_iClustThresh_C */
+{0x0F12, 0x1B24},   /*70000ADC AFIT8_bnr_iDenThreshLow
+[7:0] AFIT8_bnr_iDenThreshHigh */
+{0x0F12, 0x6024},   /*70000ADE AFIT8_ee_iLowSharpPower
+[7:0] AFIT8_ee_iHighSharpPower */
+{0x0F12, 0x1D22},   /*70000AE0 AFIT8_ee_iLowShDenoise
+[7:0] AFIT8_ee_iHighShDenoise */
+{0x0F12, 0xFFFF},   /*70000AE2 AFIT8_ee_iLowSharpClamp
+[7:0] AFIT8_ee_iHighSharpClamp */
+{0x0F12, 0x0808},   /*70000AE4 AFIT8_ee_iReduceEdgeMinMult
+[7:0] AFIT8_ee_iReduceEdgeSlope */
+{0x0F12, 0x0A01},   /*70000AE6 AFIT8_bnr_nClustLevel_H_Bin
+[7:0] AFIT8_bnr_iClustMulT_H_Bin */
+{0x0F12, 0x010A},   /*70000AE8 AFIT8_bnr_iClustMulT_C_Bin
+[7:0] AFIT8_bnr_iClustThresh_H_Bin */
+{0x0F12, 0x2401},   /*70000AEA AFIT8_bnr_iClustThresh_C_Bin
+[7:0] AFIT8_bnr_iDenThreshLow_Bin */
+{0x0F12, 0x241B},   /*70000AEC AFIT8_bnr_iDenThreshHigh_Bin
+[7:0] AFIT8_ee_iLowSharpPower_Bin */
+{0x0F12, 0x1E60},   /*70000AEE AFIT8_ee_iHighSharpPower_Bin
+[7:0] AFIT8_ee_iLowShDenoise_Bin */
+{0x0F12, 0xFF18},   /*70000AF0 AFIT8_ee_iHighShDenoise_Bin
+[7:0] AFIT8_ee_iLowSharpClamp_Bin */
+{0x0F12, 0x08FF},   /*70000AF2 AFIT8_ee_iHighSharpClamp_Bin
+[7:0] AFIT8_ee_iReduceEdgeMinMult_Bin */
+{0x0F12, 0x0008},   /*70000AF4 AFIT8_ee_iReduceEdgeSlope_Bin
+[7:0] */
+{0x0F12, 0x0001},   /*70000AF6 AFITB_bnr_nClustLevel_C
+[0] */
+
+	/*AFIT 2 */
+{0x0F12, 0x0000},   /*70000AF8 AFIT16_BRIGHTNESS */
+{0x0F12, 0x0000},   /*70000AFA AFIT16_CONTRAST */
+{0x0F12, 0x0000},   /*70000AFC AFIT16_SATURATION */
+{0x0F12, 0x0000},   /*70000AFE AFIT16_SHARP_BLUR */
+{0x0F12, 0x0000},   /*70000B00 AFIT16_GLAMOUR */
+{0x0F12, 0x00C0},   /*70000B02 AFIT16_bnr_edge_high */
+{0x0F12, 0x0064},   /*70000B04 AFIT16_postdmsc_iLowBright */
+{0x0F12, 0x0384},   /*70000B06 AFIT16_postdmsc_iHighBright */
+{0x0F12, 0x0043},   /*70000B08 AFIT16_postdmsc_iLowSat */
+{0x0F12, 0x01F4},   /*70000B0A AFIT16_postdmsc_iHighSat */
+{0x0F12, 0x0070},   /*70000B0C AFIT16_postdmsc_iTune */
+{0x0F12, 0x0040},   /*70000B0E AFIT16_yuvemix_mNegRanges_0 */
+{0x0F12, 0x00A0},   /*70000B10 AFIT16_yuvemix_mNegRanges_1 */
+{0x0F12, 0x0100},   /*70000B12 AFIT16_yuvemix_mNegRanges_2 */
+{0x0F12, 0x0010},   /*70000B14 AFIT16_yuvemix_mPosRanges_0 */
+{0x0F12, 0x0060},   /*70000B16 AFIT16_yuvemix_mPosRanges_1 */
+{0x0F12, 0x0100},   /*70000B18 AFIT16_yuvemix_mPosRanges_2 */
+{0x0F12, 0x1430},   /*70000B1A AFIT8_bnr_edge_low
+[7:0] AFIT8_bnr_repl_thresh */
+{0x0F12, 0x0201},   /*70000B1C AFIT8_bnr_repl_force
+[7:0] AFIT8_bnr_iHotThreshHigh */
+{0x0F12, 0x0204},   /*70000B1E AFIT8_bnr_iHotThreshLow
+[7:0] AFIT8_bnr_iColdThreshHigh */
+{0x0F12, 0x1B04},   /*70000B20 AFIT8_bnr_iColdThreshLow
+[7:0] AFIT8_bnr_DispTH_Low */
+{0x0F12, 0x0312},   /*70000B22 AFIT8_bnr_DispTH_High
+[7:0] AFIT8_bnr_DISP_Limit_Low */
+{0x0F12, 0x0003},   /*70000B24 AFIT8_bnr_DISP_Limit_High
+[7:0] AFIT8_bnr_iDistSigmaMin */
+{0x0F12, 0x0C03},   /*70000B26 AFIT8_bnr_iDistSigmaMax
+[7:0] AFIT8_bnr_iDiffSigmaLow */
+{0x0F12, 0x2806},   /*70000B28 AFIT8_bnr_iDiffSigmaHigh
+[7:0] AFIT8_bnr_iNormalizedSTD_TH */
+{0x0F12, 0x0060},   /*70000B2A AFIT8_bnr_iNormalizedSTD_Limit
+[7:0] AFIT8_bnr_iDirNRTune */
+{0x0F12, 0x1580},   /*70000B2C AFIT8_bnr_iDirMinThres
+[7:0] AFIT8_bnr_iDirFltDiffThresHigh */
+{0x0F12, 0x2020},   /*70000B2E AFIT8_bnr_iDirFltDiffThresLow
+[7:0] AFIT8_bnr_iDirSmoothPowerHigh */
+{0x0F12, 0x0620},   /*70000B30 AFIT8_bnr_iDirSmoothPowerLow
+[7:0] AFIT8_bnr_iLowMaxSlopeAllowed */
+{0x0F12, 0x0306},   /*70000B32 AFIT8_bnr_iHighMaxSlopeAllowed
+[7:0] AFIT8_bnr_iLowSlopeThresh */
+{0x0F12, 0x2003},   /*70000B34 AFIT8_bnr_iHighSlopeThresh
+[7:0] AFIT8_bnr_iSlopenessTH */
+{0x0F12, 0xFF01},   /*70000B36 AFIT8_bnr_iSlopeBlurStrength
+[7:0] AFIT8_bnr_iSlopenessLimit */
+{0x0F12, 0x0404},   /*70000B38 AFIT8_bnr_AddNoisePower1
+[7:0] AFIT8_bnr_AddNoisePower2 */
+{0x0F12, 0x0300},   /*70000B3A AFIT8_bnr_iRadialTune
+[7:0] AFIT8_bnr_iRadialPower */
+{0x0F12, 0x145A},   /*70000B3C AFIT8_bnr_iRadialLimit
+[7:0] AFIT8_ee_iFSMagThLow */
+{0x0F12, 0x1010},   /*70000B3E AFIT8_ee_iFSMagThHigh
+[7:0] AFIT8_ee_iFSVarThLow */
+{0x0F12, 0x000B},   /*70000B40 AFIT8_ee_iFSVarThHigh
+[7:0] AFIT8_ee_iFSThLow */
+{0x0F12, 0x0E00},   /*70000B42 AFIT8_ee_iFSThHigh
+[7:0] AFIT8_ee_iFSmagPower */
+{0x0F12, 0x5A0F},   /*70000B44 AFIT8_ee_iFSVarCountTh
+[7:0] AFIT8_ee_iRadialLimit */
+{0x0F12, 0x0504},   /*70000B46 AFIT8_ee_iRadialPower
+[7:0] AFIT8_ee_iSmoothEdgeSlope */
+{0x0F12, 0x1802},   /*70000B48 AFIT8_ee_iROADThres
+[7:0] AFIT8_ee_iROADMaxNR */
+{0x0F12, 0x0000},   /*70000B4A AFIT8_ee_iROADSubMaxNR
+[7:0] AFIT8_ee_iROADSubThres */
+{0x0F12, 0x2006},   /*70000B4C AFIT8_ee_iROADNeiThres
+[7:0] AFIT8_ee_iROADNeiMaxNR */
+{0x0F12, 0x3828},   /*70000B4E AFIT8_ee_iSmoothEdgeThres
+[7:0] AFIT8_ee_iMSharpen */
+{0x0F12, 0x0428},   /*70000B50 AFIT8_ee_iWSharpen
+[7:0] AFIT8_ee_iMShThresh */
+{0x0F12, 0x0101},   /*70000B52 AFIT8_ee_iWShThresh
+[7:0] AFIT8_ee_iReduceNegative */
+{0x0F12, 0x8000},   /*70000B54 AFIT8_ee_iEmbossCentAdd
+[7:0] AFIT8_ee_iShDespeckle */
+{0x0F12, 0x0A04},   /*70000B56 AFIT8_ee_iReduceEdgeThresh
+[7:0] AFIT8_dmsc_iEnhThresh */
+{0x0F12, 0x4008},   /*70000B58 AFIT8_dmsc_iDesatThresh
+[7:0] AFIT8_dmsc_iDemBlurHigh */
+{0x0F12, 0x0540},   /*70000B5A AFIT8_dmsc_iDemBlurLow
+[7:0] AFIT8_dmsc_iDemBlurRange */
+{0x0F12, 0x8006},   /*70000B5C AFIT8_dmsc_iDecisionThresh
+[7:0] AFIT8_dmsc_iCentGrad */
+{0x0F12, 0x0020},   /*70000B5E AFIT8_dmsc_iMonochrom
+[7:0] AFIT8_dmsc_iGBDenoiseVal */
+{0x0F12, 0x0000},   /*70000B60 AFIT8_dmsc_iGRDenoiseVal
+[7:0] AFIT8_dmsc_iEdgeDesatThrHigh */
+{0x0F12, 0x1800},   /*70000B62 AFIT8_dmsc_iEdgeDesatThrLow
+[7:0] AFIT8_dmsc_iEdgeDesat */
+{0x0F12, 0x0000},   /*70000B64 AFIT8_dmsc_iNearGrayDesat
+[7:0] AFIT8_dmsc_iEdgeDesatLimit */
+{0x0F12, 0x1E10},   /*70000B66 AFIT8_postdmsc_iBCoeff
+[7:0] AFIT8_postdmsc_iGCoeff */
+{0x0F12, 0x000B},   /*70000B68 AFIT8_postdmsc_iWideMult
+[7:0] AFIT8_yuvemix_mNegSlopes_0 */
+{0x0F12, 0x0607},   /*70000B6A AFIT8_yuvemix_mNegSlopes_1
+[7:0] AFIT8_yuvemix_mNegSlopes_2 */
+{0x0F12, 0x0005},   /*70000B6C AFIT8_yuvemix_mNegSlopes_3
+[7:0] AFIT8_yuvemix_mPosSlopes_0 */
+{0x0F12, 0x0607},   /*70000B6E AFIT8_yuvemix_mPosSlopes_1
+[7:0] AFIT8_yuvemix_mPosSlopes_2 */
+{0x0F12, 0x0405},   /*70000B70 AFIT8_yuvemix_mPosSlopes_3
+[7:0] AFIT8_yuviirnr_iXSupportY */
+{0x0F12, 0x0207},   /*70000B72 AFIT8_yuviirnr_iXSupportUV
+[7:0] AFIT8_yuviirnr_iLowYNorm */
+{0x0F12, 0x0304},   /*70000B74 AFIT8_yuviirnr_iHighYNorm
+[7:0] AFIT8_yuviirnr_iLowUVNorm */
+{0x0F12, 0x0409},   /*70000B76 AFIT8_yuviirnr_iHighUVNorm
+[7:0] AFIT8_yuviirnr_iYNormShift */
+{0x0F12, 0x0306},   /*70000B78 AFIT8_yuviirnr_iUVNormShift
+[7:0] AFIT8_yuviirnr_iVertLength_Y */
+{0x0F12, 0x0407},   /*70000B7A AFIT8_yuviirnr_iVertLength_UV
+[7:0] AFIT8_yuviirnr_iDiffThreshL_Y */
+{0x0F12, 0x2404},   /*70000B7C AFIT8_yuviirnr_iDiffThreshH_Y
+[7:0] AFIT8_yuviirnr_iDiffThreshL_UV */
+{0x0F12, 0x0221},   /*70000B7E AFIT8_yuviirnr_iDiffThreshH_UV
+[7:0] AFIT8_yuviirnr_iMaxThreshL_Y */
+{0x0F12, 0x1202},   /*70000B80 AFIT8_yuviirnr_iMaxThreshH_Y
+[7:0] AFIT8_yuviirnr_iMaxThreshL_UV */
+{0x0F12, 0x0613},   /*70000B82 AFIT8_yuviirnr_iMaxThreshH_UV
+[7:0] AFIT8_yuviirnr_iYNRStrengthL */
+{0x0F12, 0x1A02},   /*70000B84 AFIT8_yuviirnr_iYNRStrengthH
+[7:0] AFIT8_yuviirnr_iUVNRStrengthL */
+{0x0F12, 0x8018},   /*70000B86 AFIT8_yuviirnr_iUVNRStrengthH
+[7:0] AFIT8_byr_gras_iShadingPower */
+{0x0F12, 0x0080},   /*70000B88 AFIT8_RGBGamma2_iLinearity
+[7:0] AFIT8_RGBGamma2_iDarkReduce */
+{0x0F12, 0x0080},   /*70000B8A AFIT8_ccm_oscar_iSaturation
+[7:0] AFIT8_RGB2YUV_iYOffset */
+{0x0F12, 0x0180},   /*70000B8C AFIT8_RGB2YUV_iRGBGain
+[7:0] AFIT8_bnr_nClustLevel_H */
+{0x0F12, 0x0A0A},   /*70000B8E AFIT8_bnr_iClustMulT_H
+[7:0] AFIT8_bnr_iClustMulT_C */
+{0x0F12, 0x0101},   /*70000B90 AFIT8_bnr_iClustThresh_H
+[7:0] AFIT8_bnr_iClustThresh_C */
+{0x0F12, 0x141D},   /*70000B92 AFIT8_bnr_iDenThreshLow
+[7:0] AFIT8_bnr_iDenThreshHigh */
+{0x0F12, 0x6024},   /*70000B94 AFIT8_ee_iLowSharpPower
+[7:0] AFIT8_ee_iHighSharpPower */
+{0x0F12, 0x0C0C},   /*70000B96 AFIT8_ee_iLowShDenoise
+[7:0] AFIT8_ee_iHighShDenoise */
+{0x0F12, 0xFFFF},   /*70000B98 AFIT8_ee_iLowSharpClamp
+[7:0] AFIT8_ee_iHighSharpClamp */
+{0x0F12, 0x0808},   /*70000B9A AFIT8_ee_iReduceEdgeMinMult
+[7:0] AFIT8_ee_iReduceEdgeSlope */
+{0x0F12, 0x0A01},   /*70000B9C AFIT8_bnr_nClustLevel_H_Bin
+[7:0] AFIT8_bnr_iClustMulT_H_Bin */
+{0x0F12, 0x010A},   /*70000B9E AFIT8_bnr_iClustMulT_C_Bin
+[7:0] AFIT8_bnr_iClustThresh_H_Bin */
+{0x0F12, 0x1B01},   /*70000BA0 AFIT8_bnr_iClustThresh_C_Bin
+[7:0] AFIT8_bnr_iDenThreshLow_Bin */
+{0x0F12, 0x2412},   /*70000BA2 AFIT8_bnr_iDenThreshHigh_Bin
+[7:0] AFIT8_ee_iLowSharpPower_Bin */
+{0x0F12, 0x0C60},   /*70000BA4 AFIT8_ee_iHighSharpPower_Bin
+[7:0] AFIT8_ee_iLowShDenoise_Bin */
+{0x0F12, 0xFF0C},   /*70000BA6 AFIT8_ee_iHighShDenoise_Bin
+[7:0] AFIT8_ee_iLowSharpClamp_Bin */
+{0x0F12, 0x08FF},   /*70000BA8 AFIT8_ee_iHighSharpClamp_Bin
+[7:0] AFIT8_ee_iReduceEdgeMinMult_Bin */
+{0x0F12, 0x0008},   /*70000BAA AFIT8_ee_iReduceEdgeSlope_Bin
+[7:0] */
+{0x0F12, 0x0001},   /*70000BAC AFITB_bnr_nClustLevel_C
+[0] */
+
+	/*AFIT 3 */
+{0x0F12, 0x0000},   /*70000BAE AFIT16_BRIGHTNESS */
+{0x0F12, 0x0000},   /*70000BB0 AFIT16_CONTRAST */
+{0x0F12, 0x0000},   /*70000BB2 AFIT16_SATURATION */
+{0x0F12, 0x0000},   /*70000BB4 AFIT16_SHARP_BLUR */
+{0x0F12, 0x0000},   /*70000BB6 AFIT16_GLAMOUR */
+{0x0F12, 0x00C0},   /*70000BB8 AFIT16_bnr_edge_high */
+{0x0F12, 0x0064},   /*70000BBA AFIT16_postdmsc_iLowBright */
+{0x0F12, 0x0384},   /*70000BBC AFIT16_postdmsc_iHighBright */
+{0x0F12, 0x0032},   /*70000BBE AFIT16_postdmsc_iLowSat */
+{0x0F12, 0x01F4},   /*70000BC0 AFIT16_postdmsc_iHighSat */
+{0x0F12, 0x0070},   /*70000BC2 AFIT16_postdmsc_iTune */
+{0x0F12, 0x0040},   /*70000BC4 AFIT16_yuvemix_mNegRanges_0 */
+{0x0F12, 0x00A0},   /*70000BC6 AFIT16_yuvemix_mNegRanges_1 */
+{0x0F12, 0x0100},   /*70000BC8 AFIT16_yuvemix_mNegRanges_2 */
+{0x0F12, 0x0010},   /*70000BCA AFIT16_yuvemix_mPosRanges_0 */
+{0x0F12, 0x0060},   /*70000BCC AFIT16_yuvemix_mPosRanges_1 */
+{0x0F12, 0x0100},   /*70000BCE AFIT16_yuvemix_mPosRanges_2 */
+{0x0F12, 0x1430},   /*70000BD0 AFIT8_bnr_edge_low
+[7:0] AFIT8_bnr_repl_thresh */
+{0x0F12, 0x0201},   /*70000BD2 AFIT8_bnr_repl_force
+[7:0] AFIT8_bnr_iHotThreshHigh */
+{0x0F12, 0x0204},   /*70000BD4 AFIT8_bnr_iHotThreshLow
+[7:0] AFIT8_bnr_iColdThreshHigh */
+{0x0F12, 0x1504},   /*70000BD6 AFIT8_bnr_iColdThreshLow
+[7:0] AFIT8_bnr_DispTH_Low */
+{0x0F12, 0x030F},   /*70000BD8 AFIT8_bnr_DispTH_High
+[7:0] AFIT8_bnr_DISP_Limit_Low */
+{0x0F12, 0x0003},   /*70000BDA AFIT8_bnr_DISP_Limit_High
+[7:0] AFIT8_bnr_iDistSigmaMin */
+{0x0F12, 0x0902},   /*70000BDC AFIT8_bnr_iDistSigmaMax
+[7:0] AFIT8_bnr_iDiffSigmaLow */
+{0x0F12, 0x2004},   /*70000BDE AFIT8_bnr_iDiffSigmaHigh
+[7:0] AFIT8_bnr_iNormalizedSTD_TH */
+{0x0F12, 0x0050},   /*70000BE0 AFIT8_bnr_iNormalizedSTD_Limit
+[7:0] AFIT8_bnr_iDirNRTune */
+{0x0F12, 0x1140},   /*70000BE2 AFIT8_bnr_iDirMinThres
+[7:0] AFIT8_bnr_iDirFltDiffThresHigh */
+{0x0F12, 0x201C},   /*70000BE4 AFIT8_bnr_iDirFltDiffThresLow
+[7:0] AFIT8_bnr_iDirSmoothPowerHigh */
+{0x0F12, 0x0620},   /*70000BE6 AFIT8_bnr_iDirSmoothPowerLow
+[7:0] AFIT8_bnr_iLowMaxSlopeAllowed */
+{0x0F12, 0x0306},   /*70000BE8 AFIT8_bnr_iHighMaxSlopeAllowed
+[7:0] AFIT8_bnr_iLowSlopeThresh */
+{0x0F12, 0x2003},   /*70000BEA AFIT8_bnr_iHighSlopeThresh
+[7:0] AFIT8_bnr_iSlopenessTH */
+{0x0F12, 0xFF01},   /*70000BEC AFIT8_bnr_iSlopeBlurStrength
+[7:0] AFIT8_bnr_iSlopenessLimit */
+{0x0F12, 0x0404},   /*70000BEE AFIT8_bnr_AddNoisePower1
+[7:0] AFIT8_bnr_AddNoisePower2 */
+{0x0F12, 0x0300},   /*70000BF0 AFIT8_bnr_iRadialTune
+[7:0] AFIT8_bnr_iRadialPower */
+{0x0F12, 0x145A},   /*70000BF2 AFIT8_bnr_iRadialLimit
+[7:0] AFIT8_ee_iFSMagThLow */
+{0x0F12, 0x1010},   /*70000BF4 AFIT8_ee_iFSMagThHigh
+[7:0] AFIT8_ee_iFSVarThLow */
+{0x0F12, 0x000B},   /*70000BF6 AFIT8_ee_iFSVarThHigh
+[7:0] AFIT8_ee_iFSThLow */
+{0x0F12, 0x1000},   /*70000BF8 AFIT8_ee_iFSThHigh
+[7:0] AFIT8_ee_iFSmagPower */
+{0x0F12, 0x5A0F},   /*70000BFA AFIT8_ee_iFSVarCountTh
+[7:0] AFIT8_ee_iRadialLimit */
+{0x0F12, 0x0503},   /*70000BFC AFIT8_ee_iRadialPower
+[7:0] AFIT8_ee_iSmoothEdgeSlope */
+{0x0F12, 0x1802},   /*70000BFE AFIT8_ee_iROADThres
+[7:0] AFIT8_ee_iROADMaxNR */
+{0x0F12, 0x0000},   /*70000C00 AFIT8_ee_iROADSubMaxNR
+[7:0] AFIT8_ee_iROADSubThres */
+{0x0F12, 0x2006},   /*70000C02 AFIT8_ee_iROADNeiThres
+[7:0] AFIT8_ee_iROADNeiMaxNR */
+{0x0F12, 0x3C28},   /*70000C04 AFIT8_ee_iSmoothEdgeThres
+[7:0] AFIT8_ee_iMSharpen */
+{0x0F12, 0x042C},   /*70000C06 AFIT8_ee_iWSharpen
+[7:0] AFIT8_ee_iMShThresh */
+{0x0F12, 0x0101},   /*70000C08 AFIT8_ee_iWShThresh
+[7:0] AFIT8_ee_iReduceNegative */
+{0x0F12, 0xFF00},   /*70000C0A AFIT8_ee_iEmbossCentAdd
+[7:0] AFIT8_ee_iShDespeckle */
+{0x0F12, 0x0904},   /*70000C0C AFIT8_ee_iReduceEdgeThresh
+[7:0] AFIT8_dmsc_iEnhThresh */
+{0x0F12, 0x4008},   /*70000C0E AFIT8_dmsc_iDesatThresh
+[7:0] AFIT8_dmsc_iDemBlurHigh */
+{0x0F12, 0x0540},   /*70000C10 AFIT8_dmsc_iDemBlurLow
+[7:0] AFIT8_dmsc_iDemBlurRange */
+{0x0F12, 0x8006},   /*70000C12 AFIT8_dmsc_iDecisionThresh
+[7:0] AFIT8_dmsc_iCentGrad */
+{0x0F12, 0x0020},   /*70000C14 AFIT8_dmsc_iMonochrom
+[7:0] AFIT8_dmsc_iGBDenoiseVal */
+{0x0F12, 0x0000},   /*70000C16 AFIT8_dmsc_iGRDenoiseVal
+[7:0] AFIT8_dmsc_iEdgeDesatThrHigh */
+{0x0F12, 0x1800},   /*70000C18 AFIT8_dmsc_iEdgeDesatThrLow
+[7:0] AFIT8_dmsc_iEdgeDesat */
+{0x0F12, 0x0000},   /*70000C1A AFIT8_dmsc_iNearGrayDesat
+[7:0] AFIT8_dmsc_iEdgeDesatLimit */
+{0x0F12, 0x1E10},   /*70000C1C AFIT8_postdmsc_iBCoeff
+[7:0] AFIT8_postdmsc_iGCoeff */
+{0x0F12, 0x000B},   /*70000C1E AFIT8_postdmsc_iWideMult
+[7:0] AFIT8_yuvemix_mNegSlopes_0 */
+{0x0F12, 0x0607},   /*70000C20 AFIT8_yuvemix_mNegSlopes_1
+[7:0] AFIT8_yuvemix_mNegSlopes_2 */
+{0x0F12, 0x0005},   /*70000C22 AFIT8_yuvemix_mNegSlopes_3
+[7:0] AFIT8_yuvemix_mPosSlopes_0 */
+{0x0F12, 0x0607},   /*70000C24 AFIT8_yuvemix_mPosSlopes_1
+[7:0] AFIT8_yuvemix_mPosSlopes_2 */
+{0x0F12, 0x0405},   /*70000C26 AFIT8_yuvemix_mPosSlopes_3
+[7:0] AFIT8_yuviirnr_iXSupportY */
+{0x0F12, 0x0206},   /*70000C28 AFIT8_yuviirnr_iXSupportUV
+[7:0] AFIT8_yuviirnr_iLowYNorm */
+{0x0F12, 0x0304},   /*70000C2A AFIT8_yuviirnr_iHighYNorm
+[7:0] AFIT8_yuviirnr_iLowUVNorm */
+{0x0F12, 0x0409},   /*70000C2C AFIT8_yuviirnr_iHighUVNorm
+[7:0] AFIT8_yuviirnr_iYNormShift */
+{0x0F12, 0x0305},   /*70000C2E AFIT8_yuviirnr_iUVNormShift
+[7:0] AFIT8_yuviirnr_iVertLength_Y */
+{0x0F12, 0x0406},   /*70000C30 AFIT8_yuviirnr_iVertLength_UV
+[7:0] AFIT8_yuviirnr_iDiffThreshL_Y */
+{0x0F12, 0x2804},   /*70000C32 AFIT8_yuviirnr_iDiffThreshH_Y
+[7:0] AFIT8_yuviirnr_iDiffThreshL_UV */
+{0x0F12, 0x0228},   /*70000C34 AFIT8_yuviirnr_iDiffThreshH_UV
+[7:0] AFIT8_yuviirnr_iMaxThreshL_Y */
+{0x0F12, 0x1402},   /*70000C36 AFIT8_yuviirnr_iMaxThreshH_Y
+[7:0] AFIT8_yuviirnr_iMaxThreshL_UV */
+{0x0F12, 0x0618},   /*70000C38 AFIT8_yuviirnr_iMaxThreshH_UV
+[7:0] AFIT8_yuviirnr_iYNRStrengthL */
+{0x0F12, 0x1A02},   /*70000C3A AFIT8_yuviirnr_iYNRStrengthH
+[7:0] AFIT8_yuviirnr_iUVNRStrengthL */
+{0x0F12, 0x8018},   /*70000C3C AFIT8_yuviirnr_iUVNRStrengthH
+[7:0] AFIT8_byr_gras_iShadingPower */
+{0x0F12, 0x0080},   /*70000C3E AFIT8_RGBGamma2_iLinearity
+[7:0] AFIT8_RGBGamma2_iDarkReduce */
+{0x0F12, 0x0080},   /*70000C40 AFIT8_ccm_oscar_iSaturation
+[7:0] AFIT8_RGB2YUV_iYOffset */
+{0x0F12, 0x0180},   /*70000C42 AFIT8_RGB2YUV_iRGBGain
+[7:0] AFIT8_bnr_nClustLevel_H */
+{0x0F12, 0x0A0A},   /*70000C44 AFIT8_bnr_iClustMulT_H
+[7:0] AFIT8_bnr_iClustMulT_C */
+{0x0F12, 0x0101},   /*70000C46 AFIT8_bnr_iClustThresh_H
+[7:0] AFIT8_bnr_iClustThresh_C */
+{0x0F12, 0x1117},   /*70000C48 AFIT8_bnr_iDenThreshLow
+[7:0] AFIT8_bnr_iDenThreshHigh */
+{0x0F12, 0x6024},   /*70000C4A AFIT8_ee_iLowSharpPower
+[7:0] AFIT8_ee_iHighSharpPower */
+{0x0F12, 0x0A0A},   /*70000C4C AFIT8_ee_iLowShDenoise
+[7:0] AFIT8_ee_iHighShDenoise */
+{0x0F12, 0xFFFF},   /*70000C4E AFIT8_ee_iLowSharpClamp
+[7:0] AFIT8_ee_iHighSharpClamp */
+{0x0F12, 0x0808},   /*70000C50 AFIT8_ee_iReduceEdgeMinMult
+[7:0] AFIT8_ee_iReduceEdgeSlope */
+{0x0F12, 0x0A01},   /*70000C52 AFIT8_bnr_nClustLevel_H_Bin
+[7:0] AFIT8_bnr_iClustMulT_H_Bin */
+{0x0F12, 0x010A},   /*70000C54 AFIT8_bnr_iClustMulT_C_Bin
+[7:0] AFIT8_bnr_iClustThresh_H_Bin */
+{0x0F12, 0x1501},   /*70000C56 AFIT8_bnr_iClustThresh_C_Bin
+[7:0] AFIT8_bnr_iDenThreshLow_Bin */
+{0x0F12, 0x240F},   /*70000C58 AFIT8_bnr_iDenThreshHigh_Bin
+[7:0] AFIT8_ee_iLowSharpPower_Bin */
+{0x0F12, 0x0A60},   /*70000C5A AFIT8_ee_iHighSharpPower_Bin
+[7:0] AFIT8_ee_iLowShDenoise_Bin */
+{0x0F12, 0xFF0A},   /*70000C5C AFIT8_ee_iHighShDenoise_Bin
+[7:0] AFIT8_ee_iLowSharpClamp_Bin */
+{0x0F12, 0x08FF},   /*70000C5E AFIT8_ee_iHighSharpClamp_Bin
+[7:0] AFIT8_ee_iReduceEdgeMinMult_Bin */
+{0x0F12, 0x0008},   /*70000C60 AFIT8_ee_iReduceEdgeSlope_Bin
+[7:0] */
+{0x0F12, 0x0001},   /*70000C62 AFITB_bnr_nClustLevel_C
+[0] */
+
+	/*AFIT 4 */
+{0x0F12, 0x0000},   /*70000C64 AFIT16_BRIGHTNESS */
+{0x0F12, 0x0000},   /*70000C66 AFIT16_CONTRAST */
+{0x0F12, 0x0000},   /*70000C68 AFIT16_SATURATION */
+{0x0F12, 0x0000},   /*70000C6A AFIT16_SHARP_BLUR */
+{0x0F12, 0x0000},   /*70000C6C AFIT16_GLAMOUR */
+{0x0F12, 0x00C0},   /*70000C6E AFIT16_bnr_edge_high */
+{0x0F12, 0x0064},   /*70000C70 AFIT16_postdmsc_iLowBright */
+{0x0F12, 0x0384},   /*70000C72 AFIT16_postdmsc_iHighBright */
+{0x0F12, 0x0032},   /*70000C74 AFIT16_postdmsc_iLowSat */
+{0x0F12, 0x01F4},   /*70000C76 AFIT16_postdmsc_iHighSat */
+{0x0F12, 0x0070},   /*70000C78 AFIT16_postdmsc_iTune */
+{0x0F12, 0x0040},   /*70000C7A AFIT16_yuvemix_mNegRanges_0 */
+{0x0F12, 0x00A0},   /*70000C7C AFIT16_yuvemix_mNegRanges_1 */
+{0x0F12, 0x0100},   /*70000C7E AFIT16_yuvemix_mNegRanges_2 */
+{0x0F12, 0x0010},   /*70000C80 AFIT16_yuvemix_mPosRanges_0 */
+{0x0F12, 0x0060},   /*70000C82 AFIT16_yuvemix_mPosRanges_1 */
+{0x0F12, 0x0100},   /*70000C84 AFIT16_yuvemix_mPosRanges_2 */
+{0x0F12, 0x1430},   /*70000C86 AFIT8_bnr_edge_low
+[7:0] AFIT8_bnr_repl_thresh */
+{0x0F12, 0x0201},   /*70000C88 AFIT8_bnr_repl_force
+[7:0] AFIT8_bnr_iHotThreshHigh */
+{0x0F12, 0x0204},   /*70000C8A AFIT8_bnr_iHotThreshLow
+[7:0] AFIT8_bnr_iColdThreshHigh */
+{0x0F12, 0x0F04},   /*70000C8C AFIT8_bnr_iColdThreshLow
+[7:0] AFIT8_bnr_DispTH_Low */
+{0x0F12, 0x030C},   /*70000C8E AFIT8_bnr_DispTH_High
+[7:0] AFIT8_bnr_DISP_Limit_Low */
+{0x0F12, 0x0003},   /*70000C90 AFIT8_bnr_DISP_Limit_High
+[7:0] AFIT8_bnr_iDistSigmaMin */
+{0x0F12, 0x0602},   /*70000C92 AFIT8_bnr_iDistSigmaMax
+[7:0] AFIT8_bnr_iDiffSigmaLow */
+{0x0F12, 0x1803},   /*70000C94 AFIT8_bnr_iDiffSigmaHigh
+[7:0] AFIT8_bnr_iNormalizedSTD_TH */
+{0x0F12, 0x0040},   /*70000C96 AFIT8_bnr_iNormalizedSTD_Limit
+[7:0] AFIT8_bnr_iDirNRTune */
+{0x0F12, 0x0E20},   /*70000C98 AFIT8_bnr_iDirMinThres
+[7:0] AFIT8_bnr_iDirFltDiffThresHigh */
+{0x0F12, 0x2018},   /*70000C9A AFIT8_bnr_iDirFltDiffThresLow
+[7:0] AFIT8_bnr_iDirSmoothPowerHigh */
+{0x0F12, 0x0620},   /*70000C9C AFIT8_bnr_iDirSmoothPowerLow
+[7:0] AFIT8_bnr_iLowMaxSlopeAllowed */
+{0x0F12, 0x0306},   /*70000C9E AFIT8_bnr_iHighMaxSlopeAllowed
+[7:0] AFIT8_bnr_iLowSlopeThresh */
+{0x0F12, 0x2003},   /*70000CA0 AFIT8_bnr_iHighSlopeThresh
+[7:0] AFIT8_bnr_iSlopenessTH */
+{0x0F12, 0xFF01},   /*70000CA2 AFIT8_bnr_iSlopeBlurStrength
+[7:0] AFIT8_bnr_iSlopenessLimit */
+{0x0F12, 0x0404},   /*70000CA4 AFIT8_bnr_AddNoisePower1
+[7:0] AFIT8_bnr_AddNoisePower2 */
+{0x0F12, 0x0200},   /*70000CA6 AFIT8_bnr_iRadialTune
+[7:0] AFIT8_bnr_iRadialPower */
+{0x0F12, 0x145A},   /*70000CA8 AFIT8_bnr_iRadialLimit
+[7:0] AFIT8_ee_iFSMagThLow */
+{0x0F12, 0x1010},   /*70000CAA AFIT8_ee_iFSMagThHigh
+[7:0] AFIT8_ee_iFSVarThLow */
+{0x0F12, 0x000B},   /*70000CAC AFIT8_ee_iFSVarThHigh
+[7:0] AFIT8_ee_iFSThLow */
+{0x0F12, 0x1200},   /*70000CAE AFIT8_ee_iFSThHigh
+[7:0] AFIT8_ee_iFSmagPower */
+{0x0F12, 0x5A0F},   /*70000CB0 AFIT8_ee_iFSVarCountTh
+[7:0] AFIT8_ee_iRadialLimit */
+{0x0F12, 0x0502},   /*70000CB2 AFIT8_ee_iRadialPower
+[7:0] AFIT8_ee_iSmoothEdgeSlope */
+{0x0F12, 0x1802},   /*70000CB4 AFIT8_ee_iROADThres
+[7:0] AFIT8_ee_iROADMaxNR */
+{0x0F12, 0x0000},   /*70000CB6 AFIT8_ee_iROADSubMaxNR
+[7:0] AFIT8_ee_iROADSubThres */
+{0x0F12, 0x2006},   /*70000CB8 AFIT8_ee_iROADNeiThres
+[7:0] AFIT8_ee_iROADNeiMaxNR */
+{0x0F12, 0x4028},   /*70000CBA AFIT8_ee_iSmoothEdgeThres
+[7:0] AFIT8_ee_iMSharpen */
+{0x0F12, 0x0430},   /*70000CBC AFIT8_ee_iWSharpen
+[7:0] AFIT8_ee_iMShThresh */
+{0x0F12, 0x0101},   /*70000CBE AFIT8_ee_iWShThresh
+[7:0] AFIT8_ee_iReduceNegative */
+{0x0F12, 0xFF00},   /*70000CC0 AFIT8_ee_iEmbossCentAdd
+[7:0] AFIT8_ee_iShDespeckle */
+{0x0F12, 0x0804},   /*70000CC2 AFIT8_ee_iReduceEdgeThresh
+[7:0] AFIT8_dmsc_iEnhThresh */
+{0x0F12, 0x4008},   /*70000CC4 AFIT8_dmsc_iDesatThresh
+[7:0] AFIT8_dmsc_iDemBlurHigh */
+{0x0F12, 0x0540},   /*70000CC6 AFIT8_dmsc_iDemBlurLow
+[7:0] AFIT8_dmsc_iDemBlurRange */
+{0x0F12, 0x8006},   /*70000CC8 AFIT8_dmsc_iDecisionThresh
+[7:0] AFIT8_dmsc_iCentGrad */
+{0x0F12, 0x0020},   /*70000CCA AFIT8_dmsc_iMonochrom
+[7:0] AFIT8_dmsc_iGBDenoiseVal */
+{0x0F12, 0x0000},   /*70000CCC AFIT8_dmsc_iGRDenoiseVal
+[7:0] AFIT8_dmsc_iEdgeDesatThrHigh */
+{0x0F12, 0x1800},   /*70000CCE AFIT8_dmsc_iEdgeDesatThrLow
+[7:0] AFIT8_dmsc_iEdgeDesat */
+{0x0F12, 0x0000},   /*70000CD0 AFIT8_dmsc_iNearGrayDesat
+[7:0] AFIT8_dmsc_iEdgeDesatLimit */
+{0x0F12, 0x1E10},   /*70000CD2 AFIT8_postdmsc_iBCoeff
+[7:0] AFIT8_postdmsc_iGCoeff */
+{0x0F12, 0x000B},   /*70000CD4 AFIT8_postdmsc_iWideMult
+[7:0] AFIT8_yuvemix_mNegSlopes_0 */
+{0x0F12, 0x0607},   /*70000CD6 AFIT8_yuvemix_mNegSlopes_1
+[7:0] AFIT8_yuvemix_mNegSlopes_2 */
+{0x0F12, 0x0005},   /*70000CD8 AFIT8_yuvemix_mNegSlopes_3
+[7:0] AFIT8_yuvemix_mPosSlopes_0 */
+{0x0F12, 0x0607},   /*70000CDA AFIT8_yuvemix_mPosSlopes_1
+[7:0] AFIT8_yuvemix_mPosSlopes_2 */
+{0x0F12, 0x0405},   /*70000CDC AFIT8_yuvemix_mPosSlopes_3
+[7:0] AFIT8_yuviirnr_iXSupportY */
+{0x0F12, 0x0205},   /*70000CDE AFIT8_yuviirnr_iXSupportUV
+[7:0] AFIT8_yuviirnr_iLowYNorm */
+{0x0F12, 0x0304},   /*70000CE0 AFIT8_yuviirnr_iHighYNorm
+[7:0] AFIT8_yuviirnr_iLowUVNorm */
+{0x0F12, 0x0409},   /*70000CE2 AFIT8_yuviirnr_iHighUVNorm
+[7:0] AFIT8_yuviirnr_iYNormShift */
+{0x0F12, 0x0306},   /*70000CE4 AFIT8_yuviirnr_iUVNormShift
+[7:0] AFIT8_yuviirnr_iVertLength_Y */
+{0x0F12, 0x0407},   /*70000CE6 AFIT8_yuviirnr_iVertLength_UV
+[7:0] AFIT8_yuviirnr_iDiffThreshL_Y */
+{0x0F12, 0x2C04},   /*70000CE8 AFIT8_yuviirnr_iDiffThreshH_Y
+[7:0] AFIT8_yuviirnr_iDiffThreshL_UV */
+{0x0F12, 0x022C},   /*70000CEA AFIT8_yuviirnr_iDiffThreshH_UV
+[7:0] AFIT8_yuviirnr_iMaxThreshL_Y */
+{0x0F12, 0x1402},   /*70000CEC AFIT8_yuviirnr_iMaxThreshH_Y
+[7:0] AFIT8_yuviirnr_iMaxThreshL_UV */
+{0x0F12, 0x0618},   /*70000CEE AFIT8_yuviirnr_iMaxThreshH_UV
+[7:0] AFIT8_yuviirnr_iYNRStrengthL */
+{0x0F12, 0x1A02},   /*70000CF0 AFIT8_yuviirnr_iYNRStrengthH
+[7:0] AFIT8_yuviirnr_iUVNRStrengthL */
+{0x0F12, 0x8018},   /*70000CF2 AFIT8_yuviirnr_iUVNRStrengthH
+[7:0] AFIT8_byr_gras_iShadingPower */
+{0x0F12, 0x0080},   /*70000CF4 AFIT8_RGBGamma2_iLinearity
+[7:0] AFIT8_RGBGamma2_iDarkReduce */
+{0x0F12, 0x0080},   /*70000CF6 AFIT8_ccm_oscar_iSaturation
+[7:0] AFIT8_RGB2YUV_iYOffset */
+{0x0F12, 0x0180},   /*70000CF8 AFIT8_RGB2YUV_iRGBGain
+[7:0] AFIT8_bnr_nClustLevel_H */
+{0x0F12, 0x0A0A},   /*70000CFA AFIT8_bnr_iClustMulT_H
+[7:0] AFIT8_bnr_iClustMulT_C */
+{0x0F12, 0x0101},   /*70000CFC AFIT8_bnr_iClustThresh_H
+[7:0] AFIT8_bnr_iClustThresh_C */
+{0x0F12, 0x0C0F},   /*70000CFE AFIT8_bnr_iDenThreshLow
+[7:0] AFIT8_bnr_iDenThreshHigh */
+{0x0F12, 0x6024},   /*70000D00 AFIT8_ee_iLowSharpPower
+[7:0] AFIT8_ee_iHighSharpPower */
+{0x0F12, 0x0808},   /*70000D02 AFIT8_ee_iLowShDenoise
+[7:0] AFIT8_ee_iHighShDenoise */
+{0x0F12, 0xFFFF},   /*70000D04 AFIT8_ee_iLowSharpClamp
+[7:0] AFIT8_ee_iHighSharpClamp */
+{0x0F12, 0x0808},   /*70000D06 AFIT8_ee_iReduceEdgeMinMult
+[7:0] AFIT8_ee_iReduceEdgeSlope */
+{0x0F12, 0x0A01},   /*70000D08 AFIT8_bnr_nClustLevel_H_Bin
+[7:0] AFIT8_bnr_iClustMulT_H_Bin */
+{0x0F12, 0x010A},   /*70000D0A AFIT8_bnr_iClustMulT_C_Bin
+[7:0] AFIT8_bnr_iClustThresh_H_Bin */
+{0x0F12, 0x0F01},   /*70000D0C AFIT8_bnr_iClustThresh_C_Bin
+[7:0] AFIT8_bnr_iDenThreshLow_Bin */
+{0x0F12, 0x240C},   /*70000D0E AFIT8_bnr_iDenThreshHigh_Bin
+[7:0] AFIT8_ee_iLowSharpPower_Bin */
+{0x0F12, 0x0860},   /*70000D10 AFIT8_ee_iHighSharpPower_Bin
+[7:0] AFIT8_ee_iLowShDenoise_Bin */
+{0x0F12, 0xFF08},   /*70000D12 AFIT8_ee_iHighShDenoise_Bin
+[7:0] AFIT8_ee_iLowSharpClamp_Bin */
+{0x0F12, 0x08FF},   /*70000D14 AFIT8_ee_iHighSharpClamp_Bin
+[7:0] AFIT8_ee_iReduceEdgeMinMult_Bin */
+{0x0F12, 0x0008},   /*70000D16 AFIT8_ee_iReduceEdgeSlope_Bin
+[7:0] */
+{0x0F12, 0x0001},   /*70000D18 AFITB_bnr_nClustLevel_C
+[0]   bWideWide[1] */
+
+{0x0F12, 0x23CE},	/*70000D1A	[0]CAFITB_bnr_bypass */
+{0x0F12, 0xFDC8},	/*70000D1C	[0]CAFITB_bnr_bSlopenessTune */
+{0x0F12, 0x112E},	/*70000D1E	[0]CAFITB_ee_bReduceNegMedSh */
+{0x0F12, 0x93A5},	/*70000D20	[0]CAFITB_dmsc_bDoDesat */
+{0x0F12, 0xFE67},	/*70000D22	[0]CAFITB_postdmsc_bSat */
+{0x0F12, 0x0000},	/*70000D24	[0]CAFITB_yuviirnr_bWideY */
+
+
+
+/*=================================================================== */
+/* System setting */
+/*=================================================================== */
+{0x002A, 0x01F8},
+{0x0F12, 0x5DC0},   /*REG_TC_IPRM_InClockLSBs MCLK: 24Mhz */
+{0x002A, 0x0212},
+{0x0F12, 0x0002},   /*REG_TC_IPRM_UseNPviClocks */
+{0x0F12, 0x0000},   /*REG_TC_IPRM_UseNMipiClocks */
+{0x0F12, 0x0000},   /*REG_TC_IPRM_NumberOfMipiLanes */
+{0x002A, 0x021A},
+{0x0F12, 0x3A98},   //REG_TC_IPRM_OpClk4KHz_0 SCLK: 60Mhz
+{0x0F12, 0x4F1A},   //REG_TC_IPRM_MinOutRate4KHz_0	PCLK Min : 81Mhz
+{0x0F12, 0x4F1A},   //REG_TC_IPRM_MaxOutRate4KHz_0	PCLK Max : 81Mhz
+{0x0F12, 0x4F1A},   //REG_TC_IPRM_OpClk4KHz_1	SCLK 	 : 81Mhz
+{0x0F12, 0x4F1A},   //REG_TC_IPRM_MinOutRate4KHz_1	PCLK Min : 81Mhz
+{0x0F12, 0x4F1A},   //REG_TC_IPRM_MaxOutRate4KHz_1 PCLK Max : 81Mhz
+
+{0x002A, 0x022C},
+{0x0F12, 0x0001},   /*REG_TC_IPRM_InitParamsUpdated */
+
+/*=================================================================== */
+/* JPEG setting */
+/*=================================================================== */
+/* JPEG Quality */
+{0x002A, 0x0478},
+{0x0F12, 0x005F},	/*REG_TC_BRC_usPrevQuality */
+{0x0F12, 0x005F},	/*REG_TC_BRC_usCaptureQuality */
+
+/* JPEG Thumnail */
+{0x0F12, 0x0001},	/*REG_TC_THUMB_Thumb_bActive */
+{0x0F12, 0x0280},	/*REG_TC_THUMB_Thumb_uWidth 640 */
+{0x0F12, 0x01E0},	/*REG_TC_THUMB_Thumb_uHeight 480 */
+{0x0F12, 0x0005},	/*REG_TC_THUMB_Thumb_Format YUV */
+
+/* JPEG setting */
+{0x002A, 0x17DC},
+{0x0F12, 0x0054},	/*jpeg_ManualMBCV */
+{0x002A, 0x1AE4},
+{0x0F12, 0x001C},	/*senHal_bExtraAddLine */
+{0x002A, 0x0284},
+{0x0F12, 0x0001},	/*REG_TC_GP_bBypassScalerJpg */
+{0x002A, 0x028A},
+{0x0F12, 0x0000},	/*REG_TC_GP_bUse1FrameCaptureMode 0:continus capture
+frame, 1:single capture frame */
+
+/*=================================================================== */
+/* Preview */
+/*=================================================================== */
+{0x002A, 0x02A6},
+{0x0F12, 0x0280},   /*REG_0TC_PCFG_usWidth */
+{0x0F12, 0x01E0},   /*REG_0TC_PCFG_usHeight */
+{0x0F12, 0x0005},   /*REG_0TC_PCFG_Format	5 YUV	7 Raw	9 JPG */
+{0x0F12, 0x4F1A},   /*REG_0TC_PCFG_usMaxOut4KHzRate */
+{0x0F12, 0x4F1A},   /*REG_0TC_PCFG_usMinOut4KHzRate */
+{0x0F12, 0x0100},   /*REG_0TC_PCFG_OutClkPerPix88 */
+{0x0F12, 0x0300},   /*REG_0TC_PCFG_uBpp88 */
+{0x0F12, 0x0040},   /*REG_0TC_PCFG_PVIMask UYVY falling -> YUYV rising edge */
+{0x0F12, 0x0000},   /*REG_0TC_PCFG_OIFMask */
+{0x0F12, 0x01E0},   /*REG_0TC_PCFG_usJpegPacketSize */
+{0x0F12, 0x0000},   /*REG_0TC_PCFG_usJpegTotalPackets */
+{0x0F12, 0x0000},   /*REG_0TC_PCFG_uClockInd */
+{0x0F12, 0x0000},   /*REG_0TC_PCFG_usFrTimeType */
+{0x0F12, 0x0001},   /*REG_0TC_PCFG_FrRateQualityType */
+{0x0F12, 0x03E8},   /*REG_0TC_PCFG_usMaxFrTimeMsecMult10 */
+{0x0F12, 0x014A},   /*REG_0TC_PCFG_usMinFrTimeMsecMult10 */
+{0x002A, 0x02D0},
+{0x0F12, 0x0000},   /*REG_0TC_PCFG_uPrevMirror */
+{0x0F12, 0x0000},   /*REG_0TC_PCFG_uCaptureMirror */
+{0x0F12, 0x0000},   /*REG_0TC_PCFG_uRotation */
+
+/*=================================================================== */
+/* Capture */
+/*=================================================================== */
+{0x002A, 0x0396},
+{0x0F12, 0x0000},   /*REG_0TC_CCFG_uCaptureMode */
+{0x0F12, 0x0A00},   /*REG_0TC_CCFG_usWidth */
+{0x0F12, 0x0780},   /*REG_0TC_CCFG_usHeight */
+{0x0F12, 0x0009},   /*REG_0TC_CCFG_Format */
+{0x0F12, 0x4F1A},   /*REG_0TC_CCFG_usMaxOut4KHzRate */
+{0x0F12, 0x4F1A},   /*REG_0TC_CCFG_usMinOut4KHzRate */
+{0x0F12, 0x0100},   /*REG_0TC_CCFG_OutClkPerPix88 */
+{0x0F12, 0x0300},   /*REG_0TC_CCFG_uBpp88 */
+{0x0F12, 0x0050},   /*REG_0TC_CCFG_PVIMask */
+{0x0F12, 0x0070},   /*REG_0TC_CCFG_OIFMask */
+{0x0F12, 0x0810},   /*REG_0TC_CCFG_usJpegPacketSize */
+{0x0F12, 0x0900},   /*REG_0TC_CCFG_usJpegTotalPackets */
+/*{0x0F12, 0x03C0},   REG_0TC_CCFG_usJpegPacketSize     SEHF_Check_It */
+/*{0x0F12, 0x1000},   REG_0TC_CCFG_usJpegTotalPackets   SEHF_Check_It */
+{0x0F12, 0x0001},   /*REG_0TC_CCFG_uClockInd */
+{0x0F12, 0x0000},   /*REG_0TC_CCFG_usFrTimeType */
+{0x0F12, 0x0002},   /*REG_0TC_CCFG_FrRateQualityType */
+{0x0F12, 0x0535},   /*REG_0TC_CCFG_usMaxFrTimeMsecMult10 */
+{0x0F12, 0x029A},   /*REG_0TC_CCFG_usMinFrTimeMsecMult10 */
+
+/*=================================================================== */
+/* Input Width & Height */
+/*=================================================================== */
+{0x002A, 0x0250},
+{0x0F12, 0x0A00},	/*REG_TC_GP_PrevReqInputWidth 2560 */
+{0x0F12, 0x0780},	/*REG_TC_GP_PrevReqInputHeight 1920 */
+{0x0F12, 0x0010},	/*REG_TC_GP_PrevInputWidthOfs (2592-2560)/2 */
+{0x0F12, 0x000C},	/*REG_TC_GP_PrevInputHeightOfs (1944-1920)/2 */
+{0x0F12, 0x0A00},	/*REG_TC_GP_CapReqInputWidth 2560 */
+{0x0F12, 0x0780},	/*REG_TC_GP_CapReqInputHeight 1920 */
+{0x0F12, 0x0010},	/*REG_TC_GP_CapInputWidthOfs (2592-2560)/2 */
+{0x0F12, 0x000C},	/*REG_TC_GP_CapInputHeightOfs (1944-1920)/2 */
+
+
+{0x002A, 0x0494},
+{0x0F12, 0x0A00},	/*REG_TC_PZOOM_PrevZoomReqInputWidth 2560 */
+{0x0F12, 0x0780},	/*REG_TC_PZOOM_PrevZoomReqInputHeight 1920 */
+{0x0F12, 0x0000},	/*REG_TC_PZOOM_PrevZoomReqInputWidthOfs */
+{0x0F12, 0x0000},	/*REG_TC_PZOOM_PrevZoomReqInputHeightOfs */
+{0x0F12, 0x0A00},	/*REG_TC_PZOOM_CapZoomReqInputWidth 2560 */
+{0x0F12, 0x0780},	/*REG_TC_PZOOM_CapZoomReqInputHeight 1920 */
+{0x0F12, 0x0000},	/*REG_TC_PZOOM_CapZoomReqInputWidthOfs */
+{0x0F12, 0x0000},	/*REG_TC_PZOOM_CapZoomReqInputHeightOfs */
+
+{0x002A, 0x0262},
+{0x0F12, 0x0001},   /*REG_TC_GP_bUseReqInputInPre */
+{0x0F12, 0x0001},	/*REG_TC_GP_bUseReqInputInCap */
+{0x002A, 0x1CC2},   /*DRx_uDRxWeight for AutoCont function */
+{0x0F12, 0x0100},
+{0x0F12, 0x0100},
+{0x0F12, 0x0100},
+{0x0F12, 0x0100},
+{0x002A, 0x01A8},   /*ESD Check */
+{0x0F12, 0x0A0A},
+{0x002A, 0x147C},   /*bp_uMaxBrightnessFactor */
+{0x0F12, 0x0170},
+{0x002A, 0x1482},   /*bp_uMinBrightnessFactor */
+{0x0F12, 0x01E0},
+{0x002A, 0x0266},
+{0x0F12, 0x0000},	/*REG_TC_GP_ActivePrevConfig */
+{0x002A, 0x026A},
+{0x0F12, 0x0001},	/*REG_TC_GP_PrevOpenAfterChange */
+{0x002A, 0x024E},
+{0x0F12, 0x0001},	/*REG_TC_GP_NewConfigSync */
+{0x002A, 0x0268},
+{0x0F12, 0x0001},	/*REG_TC_GP_PrevConfigChanged */
+{0x002A, 0x0270},
+{0x0F12, 0x0001},	/*REG_TC_GP_CapConfigChanged */
+{0x002A, 0x023E},
+{0x0F12, 0x0001},	/*REG_TC_GP_EnablePreview */
+{0x0F12, 0x0001},	/*REG_TC_GP_EnablePreviewChanged */
+
+
+
+};
+
+
+/* Flash Control */
+static struct register_address_value_pair Cam_Cfg_Flash_Init[] = {
+{0xFCFC, 0xD000},
+{0x0028, 0x7000},
+{0x002A, 0x0484},
+{0x0F12, 0x0002},	/*REG_TC_FLS_Mode */
+
+{0x002A, 0x183A},
+{0x0F12, 0x0001},	/*fls_afl_usCounter */
+
+{0x002A, 0x17F6},
+{0x0F12, 0x0260},	/*fls_afl_DefaultWPr */
+{0x0F12, 0x0200},	/*fls_afl_DefaultWPb */
+
+{0x002A, 0x1840},
+{0x0F12, 0x0001},	/*fls_afl_bFlsMode */
+
+{0x0F12, 0x0100},	/*fls_afl_FlsAFIn_0_ */
+{0x0F12, 0x0120},	/*fls_afl_FlsAFIn_1_ */
+{0x0F12, 0x0180},	/*fls_afl_FlsAFIn_2_ */
+{0x0F12, 0x0200},	/*fls_afl_FlsAFIn_3_ */
+{0x0F12, 0x0400},	/*fls_afl_FlsAFIn_4_ */
+{0x0F12, 0x0800},	/*fls_afl_FlsAFIn_5_ */
+{0x0F12, 0x0A00},	/*fls_afl_FlsAFIn_6_ */
+{0x0F12, 0x1000},	/*fls_afl_FlsAFIn_7_ */
+
+{0x0F12, 0x0100},	/*fls_afl_FlsAFOut_0_ */
+{0x0F12, 0x00A0},	/*fls_afl_FlsAFOut_1_ */
+{0x0F12, 0x0090},	/*fls_afl_FlsAFOut_2_ */
+{0x0F12, 0x0080},	/*fls_afl_FlsAFOut_3_ */
+{0x0F12, 0x0070},	/*fls_afl_FlsAFOut_4_ */
+{0x0F12, 0x0045},	/*fls_afl_FlsAFOut_5_ */
+{0x0F12, 0x0030},	/*fls_afl_FlsAFOut_6_ */
+{0x0F12, 0x0010},	/*fls_afl_FlsAFOut_7_ */
+
+{0x002A, 0x1884},
+{0x0F12, 0x0100},	/*fls_afl_FlsNBOut_0_ */
+{0x0F12, 0x0100},	/*fls_afl_FlsNBOut_1_ */
+{0x0F12, 0x0100},	/*fls_afl_FlsNBOut_2_ */
+{0x0F12, 0x0100},	/*fls_afl_FlsNBOut_3_ */
+{0x0F12, 0x0100},	/*fls_afl_FlsNBOut_4_ */
+{0x0F12, 0x0100},	/*fls_afl_FlsNBOut_5_ */
+{0x0F12, 0x0100},	/*fls_afl_FlsNBOut_6_ */
+{0x0F12, 0x0100},	/*fls_afl_FlsNBOut_7_ */
+
+{0x002A, 0x1826},
+{0x0F12, 0x0100},	/*fls_afl_FlashWP_Weight2_0_ */
+{0x0F12, 0x00C0},	/*fls_afl_FlashWP_Weight2_1_ */
+{0x0F12, 0x0080},	/*fls_afl_FlashWP_Weight2_2_ */
+{0x0F12, 0x000A},	/*fls_afl_FlashWP_Weight2_3_ */
+{0x0F12, 0x0000},	/*fls_afl_FlashWP_Weight2_4_ */
+
+{0x0F12, 0x0030},	/*fls_afl_FlashWP_Lei_Thres2_0_ */
+{0x0F12, 0x0040},	/*fls_afl_FlashWP_Lei_Thres2_1_ */
+{0x0F12, 0x0048},	/*fls_afl_FlashWP_Lei_Thres2_2_ */
+{0x0F12, 0x0050},	/*fls_afl_FlashWP_Lei_Thres2_3_ */
+{0x0F12, 0x0060},	/*fls_afl_FlashWP_Lei_Thres2_4_ */
+
+{0x002A, 0x4784},
+{0x0F12, 0x00A0},	/* TNP_Regs_FlsWeightRIn  weight tune start in */
+{0x0F12, 0x00C0},
+{0x0F12, 0x00D0},
+{0x0F12, 0x0100},
+{0x0F12, 0x0200},
+{0x0F12, 0x0300},
+
+{0x0F12, 0x0088},	/* TNP_Regs_FlsWeightROut  weight tune start out */
+{0x0F12, 0x00B0},
+{0x0F12, 0x00C0},
+{0x0F12, 0x0100},
+{0x0F12, 0x0200},
+{0x0F12, 0x0300},
+
+{0x002A, 0x479C},
+{0x0F12, 0x0120},	/*Fls  BRIn */
+{0x0F12, 0x0150},
+{0x0F12, 0x0200},
+
+{0x0F12, 0x003C},	/* Fls  BROut */
+{0x0F12, 0x003B},
+{0x0F12, 0x0024},	/*brightness */
+
+};
+
+
+/* Camera Config Capture Size Config */
+/* 2560 x 1920 */
+static struct register_address_value_pair Cam_Cfg_Capture_5M[] = {
+{0xFCFC, 0xD000},
+{0x0028, 0x7000},
+{0x002A, 0x0258},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0780},
+{0x0F12, 0x0010},
+{0x0F12, 0x000C},
+
+{0x002A, 0x0264},
+{0x0F12, 0x0001},
+
+{0x002A, 0x049C},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0780},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x002A, 0x047C},
+{0x0F12, 0x0001},
+{0x0F12, 0x0280},
+{0x0F12, 0x01E0},
+
+{0x002A, 0x0398},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0780},
+
+{0x002A, 0x024E},
+{0x0F12, 0x0001},
+{0x002A, 0x0270},
+{0x0F12, 0x0001},
+
+};
+
+/* 2560 x 1536 */
+static struct register_address_value_pair Cam_Cfg_Capture_W4M[] = {
+{0xFCFC, 0xD000},
+{0x0028, 0x7000},
+{0x002A, 0x0258},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0600},
+{0x0F12, 0x0010},
+{0x0F12, 0x00CC},
+
+{0x002A, 0x0264},
+{0x0F12, 0x0001},
+
+{0x002A, 0x049C},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0600},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x002A, 0x047C},
+{0x0F12, 0x0001},
+{0x0F12, 0x0320},
+{0x0F12, 0x01E0},
+
+{0x002A, 0x0398},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0600},
+
+{0x002A, 0x024E},
+{0x0F12, 0x0001},
+{0x002A, 0x0270},
+{0x0F12, 0x0001},
+
+};
+/* 2048 x 1536 */
+static struct register_address_value_pair Cam_Cfg_Capture_3M[] = {
+{0xFCFC, 0xD000},
+{0x0028, 0x7000},
+{0x002A, 0x0258},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0780},
+{0x0F12, 0x0010},
+{0x0F12, 0x000C},
+
+{0x002A, 0x0264},
+{0x0F12, 0x0001},
+
+{0x002A, 0x049C},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0780},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x002A, 0x047C},
+{0x0F12, 0x0001},
+{0x0F12, 0x0280},
+{0x0F12, 0x01E0},
+
+{0x002A, 0x0398},
+{0x0F12, 0x0800},
+{0x0F12, 0x0600},
+
+{0x002A, 0x024E},
+{0x0F12, 0x0001},
+{0x002A, 0x0270},
+{0x0F12, 0x0001},
+
+};
+
+/* 2048 x 1232 */
+static struct register_address_value_pair Cam_Cfg_Capture_W2M[] = {
+{0xFCFC, 0xD000},
+{0x0028, 0x7000},
+{0x002A, 0x0258},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0600},
+{0x0F12, 0x0010},
+{0x0F12, 0x00CC},
+
+{0x002A, 0x0264},
+{0x0F12, 0x0001},
+
+{0x002A, 0x049C},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0600},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x002A, 0x047C},
+{0x0F12, 0x0001},
+{0x0F12, 0x0320},
+{0x0F12, 0x01E0},
+
+{0x002A, 0x0398},
+{0x0F12, 0x0800},
+{0x0F12, 0x04D0},
+
+{0x002A, 0x024E},
+{0x0F12, 0x0001},
+{0x002A, 0x0270},
+{0x0F12, 0x0001},
+
+};
+/* 1600 x 1200 */
+static struct register_address_value_pair Cam_Cfg_Capture_2M[] = {
+{0xFCFC, 0xD000},
+{0x0028, 0x7000},
+{0x002A, 0x0258},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0780},
+{0x0F12, 0x0010},
+{0x0F12, 0x000C},
+
+{0x002A, 0x0264},
+{0x0F12, 0x0001},
+
+{0x002A, 0x049C},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0780},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x002A, 0x047C},
+{0x0F12, 0x0001},
+{0x0F12, 0x0280},
+{0x0F12, 0x01E0},
+
+{0x002A, 0x0398},
+{0x0F12, 0x0640},
+{0x0F12, 0x04B0},
+
+{0x002A, 0x024E},
+{0x0F12, 0x0001},
+{0x002A, 0x0270},
+{0x0F12, 0x0001},
+
+};
+
+/* 1600 x 960 */
+static struct register_address_value_pair Cam_Cfg_Capture_W1M[] = {
+{0xFCFC, 0xD000},
+{0x0028, 0x7000},
+{0x002A, 0x0258},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0600},
+{0x0F12, 0x0010},
+{0x0F12, 0x00CC},
+
+{0x002A, 0x0264},
+{0x0F12, 0x0001},
+
+{0x002A, 0x049C},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0600},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x002A, 0x047C},
+{0x0F12, 0x0001},
+{0x0F12, 0x0320},
+{0x0F12, 0x01E0},
+
+{0x002A, 0x0398},
+{0x0F12, 0x0640},
+{0x0F12, 0x03C0},
+
+{0x002A, 0x024E},
+{0x0F12, 0x0001},
+{0x002A, 0x0270},
+{0x0F12, 0x0001},
+
+};
+/* 1280 x 960 */
+static struct register_address_value_pair Cam_Cfg_Capture_1M[] = {
+{0xFCFC, 0xD000},
+{0x0028, 0x7000},
+{0x002A, 0x0258},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0780},
+{0x0F12, 0x0010},
+{0x0F12, 0x000C},
+
+{0x002A, 0x0264},
+{0x0F12, 0x0001},
+
+{0x002A, 0x049C},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0780},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x002A, 0x047C},
+{0x0F12, 0x0001},
+{0x0F12, 0x0280},
+{0x0F12, 0x01E0},
+
+{0x002A, 0x0398},
+{0x0F12, 0x0500},
+{0x0F12, 0x03C0},
+
+{0x002A, 0x024E},
+{0x0F12, 0x0001},
+{0x002A, 0x0270},
+{0x0F12, 0x0001},
+
+};
+
+static struct register_address_value_pair Cam_Cfg_Capture_WVGA[] = {
+{0xFCFC, 0xD000},
+{0x0028, 0x7000},
+{0x002A, 0x0258},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0600},
+{0x0F12, 0x0010},
+{0x0F12, 0x00CC},
+
+{0x002A, 0x0264},
+{0x0F12, 0x0001},
+
+{0x002A, 0x049C},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0600},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x002A, 0x047C},
+{0x0F12, 0x0001},
+{0x0F12, 0x0320},
+{0x0F12, 0x01E0},
+
+{0x002A, 0x0398},
+{0x0F12, 0x0320},
+{0x0F12, 0x01E0},
+
+{0x002A, 0x024E},
+{0x0F12, 0x0001},
+{0x002A, 0x0270},
+{0x0F12, 0x0001},
+
+};
+/* 640 x 480 */
+static struct register_address_value_pair Cam_Cfg_Capture_VGA[] = {
+{0xFCFC, 0xD000},
+{0x0028, 0x7000},
+{0x002A, 0x0258},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0780},
+{0x0F12, 0x0010},
+{0x0F12, 0x000C},
+
+{0x002A, 0x0264},
+{0x0F12, 0x0001},
+
+{0x002A, 0x049C},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0780},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x002A, 0x047C},
+{0x0F12, 0x0001},
+{0x0F12, 0x0280},
+{0x0F12, 0x01E0},
+
+{0x002A, 0x0398},
+{0x0F12, 0x0280},
+{0x0F12, 0x01E0},
+
+{0x002A, 0x024E},
+{0x0F12, 0x0001},
+{0x002A, 0x0270},
+{0x0F12, 0x0001},
+
+};
+
+
+static struct register_address_value_pair Cam_Cfg_Preview_1280x960[] = {
+{0xFCFC, 0xD000},
+{0x0028, 0x7000},
+{0x002A, 0x0250},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0780},
+{0x0F12, 0x0010},
+{0x0F12, 0x000C},
+
+{0x002A, 0x0262},
+{0x0F12, 0x0001},
+
+{0x002A, 0x0494},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0780},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x002A, 0x02A6},
+{0x0F12, 0x0500},
+{0x0F12, 0x03C0},
+
+{0x002A, 0x0266},
+{0x0F12, 0x0000},
+{0x002A, 0x026A},
+{0x0F12, 0x0001},
+{0x002A, 0x024E},
+{0x0F12, 0x0001},
+{0x002A, 0x0268},
+{0x0F12, 0x0001},
+
+};
+
+static struct register_address_value_pair Cam_Cfg_Preview_1280x720[] = {
+{0xFCFC, 0xD000},
+{0x0028, 0x7000},
+{0x002A, 0x0250},
+{0x0F12, 0x0A00},
+{0x0F12, 0x05A0},
+{0x0F12, 0x0010},
+{0x0F12, 0x00FC},
+
+{0x002A, 0x0262},
+{0x0F12, 0x0001},
+
+{0x002A, 0x0494},
+{0x0F12, 0x0A00},
+{0x0F12, 0x05A0},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x002A, 0x02A6},
+{0x0F12, 0x0500},
+{0x0F12, 0x02D0},
+
+{0x002A, 0x0266},
+{0x0F12, 0x0000},
+{0x002A, 0x026A},
+{0x0F12, 0x0001},
+{0x002A, 0x024E},
+{0x0F12, 0x0001},
+{0x002A, 0x0268},
+{0x0F12, 0x0001},
+};
+
+static struct register_address_value_pair Cam_Cfg_Preview_720x480[] = {
+{0xFCFC, 0xD000},
+{0x0028, 0x7000},
+{0x002A, 0x0250},
+{0x0F12, 0x0A00},
+{0x0F12, 0x06A8},
+{0x0F12, 0x0010},
+{0x0F12, 0x0078},
+
+{0x002A, 0x0262},
+{0x0F12, 0x0001},
+
+{0x002A, 0x0494},
+{0x0F12, 0x0A00},
+{0x0F12, 0x06A8},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x002A, 0x02A6},
+{0x0F12, 0x02D0},
+{0x0F12, 0x01E0},
+
+{0x002A, 0x0266},
+{0x0F12, 0x0000},
+{0x002A, 0x026A},
+{0x0F12, 0x0001},
+{0x002A, 0x024E},
+{0x0F12, 0x0001},
+{0x002A, 0x0268},
+{0x0F12, 0x0001},
+};
+
+static struct register_address_value_pair Cam_Cfg_Preview_800x480[] = {
+{0xFCFC, 0xD000},
+{0x0028, 0x7000},
+{0x002A, 0x0250},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0600},
+{0x0F12, 0x0010},
+{0x0F12, 0x00CC},
+
+{0x002A, 0x0262},
+{0x0F12, 0x0001},
+
+{0x002A, 0x0494},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0600},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x002A, 0x02A6},
+{0x0F12, 0x0320},
+{0x0F12, 0x01E0},
+
+{0x002A, 0x0266},
+{0x0F12, 0x0000},
+{0x002A, 0x026A},
+{0x0F12, 0x0001},
+{0x002A, 0x024E},
+{0x0F12, 0x0001},
+{0x002A, 0x0268},
+{0x0F12, 0x0001},
+};
+/* 640 x 480 */
+static struct register_address_value_pair Cam_Cfg_Preview_640x480[] = {
+{0xFCFC, 0xD000},
+{0x0028, 0x7000},
+
+{0x002A, 0x0250},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0780},
+{0x0F12, 0x0010},
+{0x0F12, 0x000C},
+
+{0x002A, 0x0262},
+{0x0F12, 0x0001},
+
+{0x002A, 0x0494},
+{0x0F12, 0x0A00},
+{0x0F12, 0x0780},
+{0x0F12, 0x0000},
+{0x0F12, 0x0000},
+
+{0x002A, 0x02A6},
+{0x0F12, 0x0280},
+{0x0F12, 0x01E0},
+
+{0x002A, 0x0266},
+{0x0F12, 0x0000},
+{0x002A, 0x026A},
+{0x0F12, 0x0001},
+{0x002A, 0x024E},
+{0x0F12, 0x0001},
+{0x002A, 0x0268},
+{0x0F12, 0x0001},
+};
+
+static struct register_address_value_pair Cam_Cfg_Capture_Start[] = {
+	{0x0028, 0x7000},
+	{0x002A, 0x0242},
+	{0x0F12, 0x0001},
+	{0x002A, 0x024E},
+	{0x0F12, 0x0001},
+	{0x002A, 0x0244},
+	{0x0F12, 0x0001},
+};
+
+static struct register_address_value_pair Cam_Cfg_Get_Capture_Status[] = {
+{0x002C, 0x7000},
+{0x002E, 0x0244},
+};
+
+static struct register_address_value_pair Cam_Cfg_Get_Preview_Status[] = {
+{0x002C, 0x7000},
+{0x002E, 0x0240},
+};
+
+/* Preview Return */
+static struct register_address_value_pair Cam_Cfg_Preview_Return[] = {
+{0xFCFC, 0xD000},
+{0x0028, 0x7000},
+{0x002A, 0x05D0},
+{0x0F12, 0x0000},
+{0x002A, 0x0972},
+{0x0F12, 0x0000},
+{0x002A, 0x0242},
+{0x0F12, 0x0000},
+{0x002A, 0x024E},
+{0x0F12, 0x0001},
+{0x002A, 0x0244},
+{0x0F12, 0x0001},
+{0x002A, 0x023E},
+{0x0F12, 0x0001},
+{0x0F12, 0x0001},
+};
+
+struct s5k4ecgx_reg s5k4ecgx_regs = {
+	.s5k4ecgx_init_settings = &Cam_Cfg_Init_Table[0],
+	.s5k4ecgx_init_settings_size = ARRAY_SIZE(Cam_Cfg_Init_Table),
+	.s5k4ecgx_Capture = {
+		.s5k4ecgx_5M_Capture = &Cam_Cfg_Capture_5M[0],
+		.s5k4ecgx_5M_Capture_size = ARRAY_SIZE(Cam_Cfg_Capture_5M),
+		.s5k4ecgx_W4M_Capture = &Cam_Cfg_Capture_W4M[0],
+		.s5k4ecgx_W4M_Capture_size = ARRAY_SIZE(Cam_Cfg_Capture_W4M),
+		.s5k4ecgx_3M_Capture = &Cam_Cfg_Capture_3M[0],
+		.s5k4ecgx_3M_Capture_size = ARRAY_SIZE(Cam_Cfg_Capture_3M),
+		.s5k4ecgx_2M_Capture = &Cam_Cfg_Capture_2M[0],
+		.s5k4ecgx_2M_Capture_size = ARRAY_SIZE(Cam_Cfg_Capture_2M),
+		.s5k4ecgx_W2M_Capture = &Cam_Cfg_Capture_W2M[0],
+		.s5k4ecgx_W2M_Capture_size = ARRAY_SIZE(Cam_Cfg_Capture_W2M),
+		.s5k4ecgx_1M_Capture = &Cam_Cfg_Capture_1M[0],
+		.s5k4ecgx_1M_Capture_size = ARRAY_SIZE(Cam_Cfg_Capture_1M),
+		.s5k4ecgx_W1M_Capture = &Cam_Cfg_Capture_W1M[0],
+		.s5k4ecgx_W1M_Capture_size = ARRAY_SIZE(Cam_Cfg_Capture_W1M),
+		.s5k4ecgx_WVGA_Capture = &Cam_Cfg_Capture_WVGA[0],
+		.s5k4ecgx_WVGA_Capture_size = ARRAY_SIZE(Cam_Cfg_Capture_WVGA),
+		.s5k4ecgx_VGA_Capture = &Cam_Cfg_Capture_VGA[0],
+		.s5k4ecgx_VGA_Capture_size = ARRAY_SIZE(Cam_Cfg_Capture_VGA),
+	},
+	.s5k4ecgx_Preview = {
+		.s5k4ecgx_Preview_1280x960 = &Cam_Cfg_Preview_1280x960[0],
+		.s5k4ecgx_Preview_1280x960_size =
+		ARRAY_SIZE(Cam_Cfg_Preview_1280x960),
+		.s5k4ecgx_Preview_1280x720 = &Cam_Cfg_Preview_1280x720[0],
+		.s5k4ecgx_Preview_1280x720_size =
+		ARRAY_SIZE(Cam_Cfg_Preview_1280x720),
+		.s5k4ecgx_Preview_720x480 = &Cam_Cfg_Preview_720x480[0],
+		.s5k4ecgx_Preview_720x480_size =
+		ARRAY_SIZE(Cam_Cfg_Preview_720x480),
+		.s5k4ecgx_Preview_800x480 = &Cam_Cfg_Preview_800x480[0],
+		.s5k4ecgx_Preview_800x480_size =
+		ARRAY_SIZE(Cam_Cfg_Preview_800x480),
+		.s5k4ecgx_Preview_640x480 = &Cam_Cfg_Preview_640x480[0],
+		.s5k4ecgx_Preview_640x480_size =
+		ARRAY_SIZE(Cam_Cfg_Preview_640x480),
+	},
+	.s5k4ecgx_Flash_init = &Cam_Cfg_Flash_Init[0],
+	.s5k4ecgx_Flash_init_size = ARRAY_SIZE(Cam_Cfg_Flash_Init),
+	.s5k4ecgx_Get_Preview_Status = &Cam_Cfg_Get_Preview_Status[0],
+	.s5k4ecgx_Get_Preview_Status_size =
+	ARRAY_SIZE(Cam_Cfg_Get_Preview_Status),
+	.s5k4ecgx_Get_Capture_Status = &Cam_Cfg_Get_Capture_Status[0],
+	.s5k4ecgx_Get_Capture_Status_size =
+	ARRAY_SIZE(Cam_Cfg_Get_Capture_Status),
+	.s5k4ecgx_Capture_Start = &Cam_Cfg_Capture_Start[0],
+	.s5k4ecgx_Capture_Start_size =
+	ARRAY_SIZE(Cam_Cfg_Capture_Start),
+	.s5k4ecgx_Preview_Return = &Cam_Cfg_Preview_Return[0],
+	.s5k4ecgx_Preview_Return_size =
+	ARRAY_SIZE(Cam_Cfg_Preview_Return),
+};
+
diff --git a/drivers/media/video/msm/sensors/vx6953.c b/drivers/media/video/msm/sensors/vx6953.c
new file mode 100644
index 0000000..efdf8eb
--- /dev/null
+++ b/drivers/media/video/msm/sensors/vx6953.c
@@ -0,0 +1,3721 @@
+/* Copyright (c) 2010-2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#include <media/msm_camera.h>
+#include <mach/gpio.h>
+#include <mach/camera.h>
+#include <linux/slab.h>
+#include <media/v4l2-subdev.h>
+#include "msm.h"
+#include "msm_sensor.h"
+#include "vx6953.h"
+
+/*=============================================================
+	SENSOR REGISTER DEFINES
+==============================================================*/
+
+#define REG_GROUPED_PARAMETER_HOLD			0x0104
+#define GROUPED_PARAMETER_HOLD_OFF			0x00
+#define GROUPED_PARAMETER_HOLD				0x01
+#define REG_MODE_SELECT					0x0100
+#define MODE_SELECT_STANDBY_MODE			0x00
+#define MODE_SELECT_STREAM				0x01
+/* Integration Time */
+#define REG_COARSE_INTEGRATION_TIME_HI			0x0202
+#define REG_COARSE_INTEGRATION_TIME_LO			0x0203
+/* Gain */
+#define REG_ANALOGUE_GAIN_CODE_GLOBAL_HI		0x0204
+#define REG_ANALOGUE_GAIN_CODE_GLOBAL_LO		0x0205
+/* Digital Gain */
+#define REG_DIGITAL_GAIN_GREEN_R_HI			0x020E
+#define REG_DIGITAL_GAIN_GREEN_R_LO			0x020F
+#define REG_DIGITAL_GAIN_RED_HI				0x0210
+#define REG_DIGITAL_GAIN_RED_LO				0x0211
+#define REG_DIGITAL_GAIN_BLUE_HI			0x0212
+#define REG_DIGITAL_GAIN_BLUE_LO			0x0213
+#define REG_DIGITAL_GAIN_GREEN_B_HI			0x0214
+#define REG_DIGITAL_GAIN_GREEN_B_LO			0x0215
+/* output bits setting */
+#define REG_0x0112					0x0112
+#define REG_0x0113					0x0113
+/* PLL registers */
+#define REG_VT_PIX_CLK_DIV				0x0301
+#define REG_PRE_PLL_CLK_DIV				0x0305
+#define REG_PLL_MULTIPLIER				0x0307
+#define REG_OP_PIX_CLK_DIV				0x0309
+#define REG_0x034c					0x034c
+#define REG_0x034d					0x034d
+#define REG_0x034e					0x034e
+#define REG_0x034f					0x034f
+#define REG_0x0387					0x0387
+#define REG_0x0383					0x0383
+#define REG_FRAME_LENGTH_LINES_HI			0x0340
+#define REG_FRAME_LENGTH_LINES_LO			0x0341
+#define REG_LINE_LENGTH_PCK_HI				0x0342
+#define REG_LINE_LENGTH_PCK_LO				0x0343
+#define REG_0x3030					0x3030
+#define REG_0x0111					0x0111
+#define REG_0x0136					0x0136
+#define REG_0x0137					0x0137
+#define REG_0x0b00					0x0b00
+#define REG_0x3001					0x3001
+#define REG_0x3004					0x3004
+#define REG_0x3007					0x3007
+#define REG_0x301a					0x301a
+#define REG_0x3101					0x3101
+#define REG_0x3364					0x3364
+#define REG_0x3365					0x3365
+#define REG_0x0b83					0x0b83
+#define REG_0x0b84					0x0b84
+#define REG_0x0b85					0x0b85
+#define REG_0x0b88					0x0b88
+#define REG_0x0b89					0x0b89
+#define REG_0x0b8a					0x0b8a
+#define REG_0x3005					0x3005
+#define REG_0x3010					0x3010
+#define REG_0x3036					0x3036
+#define REG_0x3041					0x3041
+#define REG_0x0b80					0x0b80
+#define REG_0x0900					0x0900
+#define REG_0x0901					0x0901
+#define REG_0x0902					0x0902
+#define REG_0x3016					0x3016
+#define REG_0x301d					0x301d
+#define REG_0x317e					0x317e
+#define REG_0x317f					0x317f
+#define REG_0x3400					0x3400
+#define REG_0x303a					0x303a
+#define REG_0x1716					0x1716
+#define REG_0x1717					0x1717
+#define REG_0x1718					0x1718
+#define REG_0x1719					0x1719
+#define REG_0x3006					0x3006
+#define REG_0x301b					0x301b
+#define REG_0x3098					0x3098
+#define REG_0x309d					0x309d
+#define REG_0x3011					0x3011
+#define REG_0x3035					0x3035
+#define REG_0x3045					0x3045
+#define REG_0x3210					0x3210
+#define	REG_0x0111					0x0111
+#define REG_0x3410					0x3410
+#define REG_0x0b06					0x0b06
+#define REG_0x0b07					0x0b07
+#define REG_0x0b08					0x0b08
+#define REG_0x0b09					0x0b09
+#define REG_0x3640					0x3640
+/* Test Pattern */
+#define REG_TEST_PATTERN_MODE				0x0601
+
+/*============================================================================
+							 TYPE DECLARATIONS
+============================================================================*/
+
+/* 16bit address - 8 bit context register structure */
+#define	VX6953_STM5M0EDOF_OFFSET	9
+#define	Q8		0x00000100
+#define	Q10		0x00000400
+#define	VX6953_STM5M0EDOF_MAX_SNAPSHOT_EXPOSURE_LINE_COUNT	2922
+#define	VX6953_STM5M0EDOF_DEFAULT_MASTER_CLK_RATE	24000000
+#define	VX6953_STM5M0EDOF_OP_PIXEL_CLOCK_RATE	79800000
+#define	VX6953_STM5M0EDOF_VT_PIXEL_CLOCK_RATE	88670000
+/* Full	Size */
+#define	VX6953_FULL_SIZE_WIDTH	2608
+#define	VX6953_FULL_SIZE_HEIGHT		1960
+#define	VX6953_FULL_SIZE_DUMMY_PIXELS	1
+#define	VX6953_FULL_SIZE_DUMMY_LINES	0
+/* Quarter Size	*/
+#define	VX6953_QTR_SIZE_WIDTH	1304
+#define	VX6953_QTR_SIZE_HEIGHT		980
+#define	VX6953_QTR_SIZE_DUMMY_PIXELS	1
+#define	VX6953_QTR_SIZE_DUMMY_LINES		0
+/* Blanking	as measured	on the scope */
+/* Full	Size */
+#define	VX6953_HRZ_FULL_BLK_PIXELS	348
+#define	VX6953_VER_FULL_BLK_LINES	40
+/* Quarter Size	*/
+#define	VX6953_HRZ_QTR_BLK_PIXELS	1628
+#define	VX6953_VER_QTR_BLK_LINES	28
+#define	MAX_LINE_LENGTH_PCK		8190
+#define	MAX_FRAME_LENGTH_LINES	16383
+#define	VX6953_REVISION_NUMBER_CUT2	0x10/*revision number	for	Cut2.0*/
+#define	VX6953_REVISION_NUMBER_CUT3	0x20/*revision number	for	Cut3.0*/
+/* FIXME: Changes from here */
+struct vx6953_work_t {
+	struct work_struct work;
+};
+
+static struct vx6953_work_t *vx6953_sensorw;
+static struct i2c_client *vx6953_client;
+
+struct vx6953_ctrl_t {
+	const struct  msm_camera_sensor_info *sensordata;
+
+	uint32_t sensormode;
+	uint32_t fps_divider;   	/* init to 1 * 0x00000400 */
+	uint32_t pict_fps_divider;  /* init to 1 * 0x00000400 */
+	uint16_t fps;
+
+	int16_t curr_lens_pos;
+	uint16_t curr_step_pos;
+	uint16_t my_reg_gain;
+	uint32_t my_reg_line_count;
+	uint16_t total_lines_per_frame;
+
+	enum vx6953_resolution_t prev_res;
+	enum vx6953_resolution_t pict_res;
+	enum vx6953_resolution_t curr_res;
+	enum vx6953_test_mode_t  set_test;
+	enum sensor_revision_t sensor_type;
+
+	enum edof_mode_t edof_mode;
+
+	unsigned short imgaddr;
+	struct vx6953_format *fmt;
+};
+
+static struct v4l2_subdev *vx6953_sdev;
+
+static uint8_t vx6953_stm5m0edof_delay_msecs_stdby;
+static uint16_t vx6953_stm5m0edof_delay_msecs_stream = 20;
+static uint8_t count;
+static struct vx6953_ctrl_t *vx6953_ctrl;
+static DECLARE_WAIT_QUEUE_HEAD(vx6953_wait_queue);
+DEFINE_MUTEX(vx6953_mut);
+static struct vx6953_i2c_reg_conf patch_tbl_cut2[] = {
+	{0xFB94, 0},	/*intialise Data Xfer Status reg*/
+	{0xFB95, 0},	/*gain 1	  (0x00)*/
+	{0xFB96, 0},	/*gain 1.07   (0x10)*/
+	{0xFB97, 0},	/*gain 1.14   (0x20)*/
+	{0xFB98, 0},	/*gain 1.23   (0x30)*/
+	{0xFB99, 0},	/*gain 1.33   (0x40)*/
+	{0xFB9A, 0},	/*gain 1.45   (0x50)*/
+	{0xFB9B, 0},	/*gain 1.6    (0x60)*/
+	{0xFB9C, 0},	/*gain 1.78   (0x70)*/
+	{0xFB9D, 2},	/*gain 2	  (0x80)*/
+	{0xFB9E, 2},	/*gain 2.29   (0x90)*/
+	{0xFB9F, 3},	/*gain 2.67   (0xA0)*/
+	{0xFBA0, 3},	/*gain 3.2    (0xB0)*/
+	{0xFBA1, 4},	/*gain 4	  (0xC0)*/
+	{0xFBA2, 7},	/*gain 5.33   (0xD0)*/
+	{0xFBA3, 10},	/*gain 8	  (0xE0)*/
+	{0xFBA4, 11},	/*gain 9.14   (0xE4)*/
+	{0xFBA5, 13},	/*gain 10.67  (0xE8)*/
+	{0xFBA6, 15},	/*gain 12.8   (0xEC)*/
+	{0xFBA7, 19},	/*gain 16     (0xF0)*/
+	{0xF800, 0x12},
+	{0xF801, 0x06},
+	{0xF802, 0xf7},
+	{0xF803, 0x90},
+	{0xF804, 0x02},
+	{0xF805, 0x05},
+	{0xF806, 0xe0},
+	{0xF807, 0xff},
+	{0xF808, 0x65},
+	{0xF809, 0x7d},
+	{0xF80A, 0x70},
+	{0xF80B, 0x03},
+	{0xF80C, 0x02},
+	{0xF80D, 0xf9},
+	{0xF80E, 0x1c},
+	{0xF80F, 0x8f},
+	{0xF810, 0x7d},
+	{0xF811, 0xe4},
+	{0xF812, 0xf5},
+	{0xF813, 0x7a},
+	{0xF814, 0x75},
+	{0xF815, 0x78},
+	{0xF816, 0x30},
+	{0xF817, 0x75},
+	{0xF818, 0x79},
+	{0xF819, 0x53},
+	{0xF81A, 0x85},
+	{0xF81B, 0x79},
+	{0xF81C, 0x82},
+	{0xF81D, 0x85},
+	{0xF81E, 0x78},
+	{0xF81F, 0x83},
+	{0xF820, 0xe0},
+	{0xF821, 0xc3},
+	{0xF822, 0x95},
+	{0xF823, 0x7b},
+	{0xF824, 0xf0},
+	{0xF825, 0x74},
+	{0xF826, 0x02},
+	{0xF827, 0x25},
+	{0xF828, 0x79},
+	{0xF829, 0xf5},
+	{0xF82A, 0x79},
+	{0xF82B, 0xe4},
+	{0xF82C, 0x35},
+	{0xF82D, 0x78},
+	{0xF82E, 0xf5},
+	{0xF82F, 0x78},
+	{0xF830, 0x05},
+	{0xF831, 0x7a},
+	{0xF832, 0xe5},
+	{0xF833, 0x7a},
+	{0xF834, 0xb4},
+	{0xF835, 0x08},
+	{0xF836, 0xe3},
+	{0xF837, 0xe5},
+	{0xF838, 0x7d},
+	{0xF839, 0x70},
+	{0xF83A, 0x04},
+	{0xF83B, 0xff},
+	{0xF83C, 0x02},
+	{0xF83D, 0xf8},
+	{0xF83E, 0xe4},
+	{0xF83F, 0xe5},
+	{0xF840, 0x7d},
+	{0xF841, 0xb4},
+	{0xF842, 0x10},
+	{0xF843, 0x05},
+	{0xF844, 0x7f},
+	{0xF845, 0x01},
+	{0xF846, 0x02},
+	{0xF847, 0xf8},
+	{0xF848, 0xe4},
+	{0xF849, 0xe5},
+	{0xF84A, 0x7d},
+	{0xF84B, 0xb4},
+	{0xF84C, 0x20},
+	{0xF84D, 0x05},
+	{0xF84E, 0x7f},
+	{0xF84F, 0x02},
+	{0xF850, 0x02},
+	{0xF851, 0xf8},
+	{0xF852, 0xe4},
+	{0xF853, 0xe5},
+	{0xF854, 0x7d},
+	{0xF855, 0xb4},
+	{0xF856, 0x30},
+	{0xF857, 0x05},
+	{0xF858, 0x7f},
+	{0xF859, 0x03},
+	{0xF85A, 0x02},
+	{0xF85B, 0xf8},
+	{0xF85C, 0xe4},
+	{0xF85D, 0xe5},
+	{0xF85E, 0x7d},
+	{0xF85F, 0xb4},
+	{0xF860, 0x40},
+	{0xF861, 0x04},
+	{0xF862, 0x7f},
+	{0xF863, 0x04},
+	{0xF864, 0x80},
+	{0xF865, 0x7e},
+	{0xF866, 0xe5},
+	{0xF867, 0x7d},
+	{0xF868, 0xb4},
+	{0xF869, 0x50},
+	{0xF86A, 0x04},
+	{0xF86B, 0x7f},
+	{0xF86C, 0x05},
+	{0xF86D, 0x80},
+	{0xF86E, 0x75},
+	{0xF86F, 0xe5},
+	{0xF870, 0x7d},
+	{0xF871, 0xb4},
+	{0xF872, 0x60},
+	{0xF873, 0x04},
+	{0xF874, 0x7f},
+	{0xF875, 0x06},
+	{0xF876, 0x80},
+	{0xF877, 0x6c},
+	{0xF878, 0xe5},
+	{0xF879, 0x7d},
+	{0xF87A, 0xb4},
+	{0xF87B, 0x70},
+	{0xF87C, 0x04},
+	{0xF87D, 0x7f},
+	{0xF87E, 0x07},
+	{0xF87F, 0x80},
+	{0xF880, 0x63},
+	{0xF881, 0xe5},
+	{0xF882, 0x7d},
+	{0xF883, 0xb4},
+	{0xF884, 0x80},
+	{0xF885, 0x04},
+	{0xF886, 0x7f},
+	{0xF887, 0x08},
+	{0xF888, 0x80},
+	{0xF889, 0x5a},
+	{0xF88A, 0xe5},
+	{0xF88B, 0x7d},
+	{0xF88C, 0xb4},
+	{0xF88D, 0x90},
+	{0xF88E, 0x04},
+	{0xF88F, 0x7f},
+	{0xF890, 0x09},
+	{0xF891, 0x80},
+	{0xF892, 0x51},
+	{0xF893, 0xe5},
+	{0xF894, 0x7d},
+	{0xF895, 0xb4},
+	{0xF896, 0xa0},
+	{0xF897, 0x04},
+	{0xF898, 0x7f},
+	{0xF899, 0x0a},
+	{0xF89A, 0x80},
+	{0xF89B, 0x48},
+	{0xF89C, 0xe5},
+	{0xF89D, 0x7d},
+	{0xF89E, 0xb4},
+	{0xF89F, 0xb0},
+	{0xF8A0, 0x04},
+	{0xF8A1, 0x7f},
+	{0xF8A2, 0x0b},
+	{0xF8A3, 0x80},
+	{0xF8A4, 0x3f},
+	{0xF8A5, 0xe5},
+	{0xF8A6, 0x7d},
+	{0xF8A7, 0xb4},
+	{0xF8A8, 0xc0},
+	{0xF8A9, 0x04},
+	{0xF8AA, 0x7f},
+	{0xF8AB, 0x0c},
+	{0xF8AC, 0x80},
+	{0xF8AD, 0x36},
+	{0xF8AE, 0xe5},
+	{0xF8AF, 0x7d},
+	{0xF8B0, 0xb4},
+	{0xF8B1, 0xd0},
+	{0xF8B2, 0x04},
+	{0xF8B3, 0x7f},
+	{0xF8B4, 0x0d},
+	{0xF8B5, 0x80},
+	{0xF8B6, 0x2d},
+	{0xF8B7, 0xe5},
+	{0xF8B8, 0x7d},
+	{0xF8B9, 0xb4},
+	{0xF8BA, 0xe0},
+	{0xF8BB, 0x04},
+	{0xF8BC, 0x7f},
+	{0xF8BD, 0x0e},
+	{0xF8BE, 0x80},
+	{0xF8BF, 0x24},
+	{0xF8C0, 0xe5},
+	{0xF8C1, 0x7d},
+	{0xF8C2, 0xb4},
+	{0xF8C3, 0xe4},
+	{0xF8C4, 0x04},
+	{0xF8C5, 0x7f},
+	{0xF8C6, 0x0f},
+	{0xF8C7, 0x80},
+	{0xF8C8, 0x1b},
+	{0xF8C9, 0xe5},
+	{0xF8CA, 0x7d},
+	{0xF8CB, 0xb4},
+	{0xF8CC, 0xe8},
+	{0xF8CD, 0x04},
+	{0xF8CE, 0x7f},
+	{0xF8CF, 0x10},
+	{0xF8D0, 0x80},
+	{0xF8D1, 0x12},
+	{0xF8D2, 0xe5},
+	{0xF8D3, 0x7d},
+	{0xF8D4, 0xb4},
+	{0xF8D5, 0xec},
+	{0xF8D6, 0x04},
+	{0xF8D7, 0x7f},
+	{0xF8D8, 0x11},
+	{0xF8D9, 0x80},
+	{0xF8DA, 0x09},
+	{0xF8DB, 0xe5},
+	{0xF8DC, 0x7d},
+	{0xF8DD, 0x7f},
+	{0xF8DE, 0x00},
+	{0xF8DF, 0xb4},
+	{0xF8E0, 0xf0},
+	{0xF8E1, 0x02},
+	{0xF8E2, 0x7f},
+	{0xF8E3, 0x12},
+	{0xF8E4, 0x8f},
+	{0xF8E5, 0x7c},
+	{0xF8E6, 0xef},
+	{0xF8E7, 0x24},
+	{0xF8E8, 0x95},
+	{0xF8E9, 0xff},
+	{0xF8EA, 0xe4},
+	{0xF8EB, 0x34},
+	{0xF8EC, 0xfb},
+	{0xF8ED, 0x8f},
+	{0xF8EE, 0x82},
+	{0xF8EF, 0xf5},
+	{0xF8F0, 0x83},
+	{0xF8F1, 0xe4},
+	{0xF8F2, 0x93},
+	{0xF8F3, 0xf5},
+	{0xF8F4, 0x7c},
+	{0xF8F5, 0xf5},
+	{0xF8F6, 0x7b},
+	{0xF8F7, 0xe4},
+	{0xF8F8, 0xf5},
+	{0xF8F9, 0x7a},
+	{0xF8FA, 0x75},
+	{0xF8FB, 0x78},
+	{0xF8FC, 0x30},
+	{0xF8FD, 0x75},
+	{0xF8FE, 0x79},
+	{0xF8FF, 0x53},
+	{0xF900, 0x85},
+	{0xF901, 0x79},
+	{0xF902, 0x82},
+	{0xF903, 0x85},
+	{0xF904, 0x78},
+	{0xF905, 0x83},
+	{0xF906, 0xe0},
+	{0xF907, 0x25},
+	{0xF908, 0x7c},
+	{0xF909, 0xf0},
+	{0xF90A, 0x74},
+	{0xF90B, 0x02},
+	{0xF90C, 0x25},
+	{0xF90D, 0x79},
+	{0xF90E, 0xf5},
+	{0xF90F, 0x79},
+	{0xF910, 0xe4},
+	{0xF911, 0x35},
+	{0xF912, 0x78},
+	{0xF913, 0xf5},
+	{0xF914, 0x78},
+	{0xF915, 0x05},
+	{0xF916, 0x7a},
+	{0xF917, 0xe5},
+	{0xF918, 0x7a},
+	{0xF919, 0xb4},
+	{0xF91A, 0x08},
+	{0xF91B, 0xe4},
+	{0xF91C, 0x02},
+	{0xF91D, 0x18},
+	{0xF91E, 0x32},
+	{0xF91F, 0x22},
+	{0xF920, 0xf0},
+	{0xF921, 0x90},
+	{0xF922, 0xa0},
+	{0xF923, 0xf8},
+	{0xF924, 0xe0},
+	{0xF925, 0x70},
+	{0xF926, 0x02},
+	{0xF927, 0xa3},
+	{0xF928, 0xe0},
+	{0xF929, 0x70},
+	{0xF92A, 0x0a},
+	{0xF92B, 0x90},
+	{0xF92C, 0xa1},
+	{0xF92D, 0x10},
+	{0xF92E, 0xe0},
+	{0xF92F, 0xfe},
+	{0xF930, 0xa3},
+	{0xF931, 0xe0},
+	{0xF932, 0xff},
+	{0xF933, 0x80},
+	{0xF934, 0x04},
+	{0xF935, 0x7e},
+	{0xF936, 0x00},
+	{0xF937, 0x7f},
+	{0xF938, 0x00},
+	{0xF939, 0x8e},
+	{0xF93A, 0x7e},
+	{0xF93B, 0x8f},
+	{0xF93C, 0x7f},
+	{0xF93D, 0x90},
+	{0xF93E, 0x36},
+	{0xF93F, 0x0d},
+	{0xF940, 0xe0},
+	{0xF941, 0x44},
+	{0xF942, 0x02},
+	{0xF943, 0xf0},
+	{0xF944, 0x90},
+	{0xF945, 0x36},
+	{0xF946, 0x0e},
+	{0xF947, 0xe5},
+	{0xF948, 0x7e},
+	{0xF949, 0xf0},
+	{0xF94A, 0xa3},
+	{0xF94B, 0xe5},
+	{0xF94C, 0x7f},
+	{0xF94D, 0xf0},
+	{0xF94E, 0xe5},
+	{0xF94F, 0x3a},
+	{0xF950, 0x60},
+	{0xF951, 0x0c},
+	{0xF952, 0x90},
+	{0xF953, 0x36},
+	{0xF954, 0x09},
+	{0xF955, 0xe0},
+	{0xF956, 0x70},
+	{0xF957, 0x06},
+	{0xF958, 0x90},
+	{0xF959, 0x36},
+	{0xF95A, 0x08},
+	{0xF95B, 0xf0},
+	{0xF95C, 0xf5},
+	{0xF95D, 0x3a},
+	{0xF95E, 0x02},
+	{0xF95F, 0x03},
+	{0xF960, 0x94},
+	{0xF961, 0x22},
+	{0xF962, 0x78},
+	{0xF963, 0x07},
+	{0xF964, 0xe6},
+	{0xF965, 0xd3},
+	{0xF966, 0x94},
+	{0xF967, 0x00},
+	{0xF968, 0x40},
+	{0xF969, 0x16},
+	{0xF96A, 0x16},
+	{0xF96B, 0xe6},
+	{0xF96C, 0x90},
+	{0xF96D, 0x30},
+	{0xF96E, 0xa1},
+	{0xF96F, 0xf0},
+	{0xF970, 0x90},
+	{0xF971, 0x43},
+	{0xF972, 0x83},
+	{0xF973, 0xe0},
+	{0xF974, 0xb4},
+	{0xF975, 0x01},
+	{0xF976, 0x0f},
+	{0xF977, 0x90},
+	{0xF978, 0x43},
+	{0xF979, 0x87},
+	{0xF97A, 0xe0},
+	{0xF97B, 0xb4},
+	{0xF97C, 0x01},
+	{0xF97D, 0x08},
+	{0xF97E, 0x80},
+	{0xF97F, 0x00},
+	{0xF980, 0x90},
+	{0xF981, 0x30},
+	{0xF982, 0xa0},
+	{0xF983, 0x74},
+	{0xF984, 0x01},
+	{0xF985, 0xf0},
+	{0xF986, 0x22},
+	{0xF987, 0xf0},
+	{0xF988, 0x90},
+	{0xF989, 0x35},
+	{0xF98A, 0xba},
+	{0xF98B, 0xe0},
+	{0xF98C, 0xb4},
+	{0xF98D, 0x0a},
+	{0xF98E, 0x0d},
+	{0xF98F, 0xa3},
+	{0xF990, 0xe0},
+	{0xF991, 0xb4},
+	{0xF992, 0x01},
+	{0xF993, 0x08},
+	{0xF994, 0x90},
+	{0xF995, 0xfb},
+	{0xF996, 0x94},
+	{0xF997, 0xe0},
+	{0xF998, 0x90},
+	{0xF999, 0x35},
+	{0xF99A, 0xb8},
+	{0xF99B, 0xf0},
+	{0xF99C, 0xd0},
+	{0xF99D, 0xd0},
+	{0xF99E, 0xd0},
+	{0xF99F, 0x82},
+	{0xF9A0, 0xd0},
+	{0xF9A1, 0x83},
+	{0xF9A2, 0xd0},
+	{0xF9A3, 0xe0},
+	{0xF9A4, 0x32},
+	{0xF9A5, 0x22},
+	{0xF9A6, 0xe5},
+	{0xF9A7, 0x7f},
+	{0xF9A8, 0x45},
+	{0xF9A9, 0x7e},
+	{0xF9AA, 0x60},
+	{0xF9AB, 0x15},
+	{0xF9AC, 0x90},
+	{0xF9AD, 0x01},
+	{0xF9AE, 0x00},
+	{0xF9AF, 0xe0},
+	{0xF9B0, 0x70},
+	{0xF9B1, 0x0f},
+	{0xF9B2, 0x90},
+	{0xF9B3, 0xa0},
+	{0xF9B4, 0xf8},
+	{0xF9B5, 0xe5},
+	{0xF9B6, 0x7e},
+	{0xF9B7, 0xf0},
+	{0xF9B8, 0xa3},
+	{0xF9B9, 0xe5},
+	{0xF9BA, 0x7f},
+	{0xF9BB, 0xf0},
+	{0xF9BC, 0xe4},
+	{0xF9BD, 0xf5},
+	{0xF9BE, 0x7e},
+	{0xF9BF, 0xf5},
+	{0xF9C0, 0x7f},
+	{0xF9C1, 0x22},
+	{0xF9C2, 0x02},
+	{0xF9C3, 0x0e},
+	{0xF9C4, 0x79},
+	{0xF9C5, 0x22},
+	/* Offsets:*/
+	{0x35C6, 0x00},/* FIDDLEDARKCAL*/
+	{0x35C7, 0x00},
+	{0x35C8, 0x01},/*STOREDISTANCEATSTOPSTREAMING*/
+	{0x35C9, 0x20},
+	{0x35CA, 0x01},/*BRUCEFIX*/
+	{0x35CB, 0x62},
+	{0x35CC, 0x01},/*FIXDATAXFERSTATUSREG*/
+	{0x35CD, 0x87},
+	{0x35CE, 0x01},/*FOCUSDISTANCEUPDATE*/
+	{0x35CF, 0xA6},
+	{0x35D0, 0x01},/*SKIPEDOFRESET*/
+	{0x35D1, 0xC2},
+	{0x35D2, 0x00},
+	{0x35D3, 0xFB},
+	{0x35D4, 0x00},
+	{0x35D5, 0x94},
+	{0x35D6, 0x00},
+	{0x35D7, 0xFB},
+	{0x35D8, 0x00},
+	{0x35D9, 0x94},
+	{0x35DA, 0x00},
+	{0x35DB, 0xFB},
+	{0x35DC, 0x00},
+	{0x35DD, 0x94},
+	{0x35DE, 0x00},
+	{0x35DF, 0xFB},
+	{0x35E0, 0x00},
+	{0x35E1, 0x94},
+	{0x35E6, 0x18},/* FIDDLEDARKCAL*/
+	{0x35E7, 0x2F},
+	{0x35E8, 0x03},/* STOREDISTANCEATSTOPSTREAMING*/
+	{0x35E9, 0x93},
+	{0x35EA, 0x18},/* BRUCEFIX*/
+	{0x35EB, 0x99},
+	{0x35EC, 0x00},/* FIXDATAXFERSTATUSREG*/
+	{0x35ED, 0xA3},
+	{0x35EE, 0x21},/* FOCUSDISTANCEUPDATE*/
+	{0x35EF, 0x5B},
+	{0x35F0, 0x0E},/* SKIPEDOFRESET*/
+	{0x35F1, 0x74},
+	{0x35F2, 0x04},
+	{0x35F3, 0x64},
+	{0x35F4, 0x04},
+	{0x35F5, 0x65},
+	{0x35F6, 0x04},
+	{0x35F7, 0x7B},
+	{0x35F8, 0x04},
+	{0x35F9, 0x7C},
+	{0x35FA, 0x04},
+	{0x35FB, 0xDD},
+	{0x35FC, 0x04},
+	{0x35FD, 0xDE},
+	{0x35FE, 0x04},
+	{0x35FF, 0xEF},
+	{0x3600, 0x04},
+	{0x3601, 0xF0},
+	/*Jump/Data:*/
+	{0x35C2, 0x3F},/* Jump Reg*/
+	{0x35C3, 0xFF},/* Jump Reg*/
+	{0x35C4, 0x3F},/* Data Reg*/
+	{0x35C5, 0xC0},/* Data Reg*/
+	{0x35C0, 0x01},/* Enable*/
+
+};
+
+static struct vx6953_i2c_reg_conf cut3_cali_data[] = {
+		{0x360A, 0x07 },
+		{0x3530, 0x07 },
+		{0x35B5, 0x00 },
+		{0x35BC, 0x00 },
+		{0xAFF8, 0x00 },
+		{0xAFF9, 0x01 },
+		{0xF800, 0x90 },
+		{0xF801, 0x30 },
+		{0xF802, 0x31 },
+		{0xF803, 0xe0 },
+		{0xF804, 0xf5 },
+		{0xF805, 0x7d },
+		{0xF806, 0xb4 },
+		{0xF807, 0x01 },
+		{0xF808, 0x06 },
+		{0xF809, 0x75 },
+		{0xF80A, 0x7d },
+		{0xF80B, 0x03 },
+		{0xF80C, 0x74 },
+		{0xF80D, 0x03 },
+		{0xF80E, 0xf0 },
+		{0xF80F, 0x90 },
+		{0xF810, 0x30 },
+		{0xF811, 0x04 },
+		{0xF812, 0x74 },
+		{0xF813, 0x33 },
+		{0xF814, 0xf0 },
+		{0xF815, 0x90 },
+		{0xF816, 0x30 },
+		{0xF817, 0x06 },
+		{0xF818, 0xe4 },
+		{0xF819, 0xf0 },
+		{0xF81A, 0xa3 },
+		{0xF81B, 0x74 },
+		{0xF81C, 0x08 },
+		{0xF81D, 0xf0 },
+		{0xF81E, 0x90 },
+		{0xF81F, 0x30 },
+		{0xF820, 0x10 },
+		{0xF821, 0xe4 },
+		{0xF822, 0xf0 },
+		{0xF823, 0xa3 },
+		{0xF824, 0xf0 },
+		{0xF825, 0x90 },
+		{0xF826, 0x30 },
+		{0xF827, 0x16 },
+		{0xF828, 0x74 },
+		{0xF829, 0x1e },
+		{0xF82A, 0xf0 },
+		{0xF82B, 0x90 },
+		{0xF82C, 0x30 },
+		{0xF82D, 0x1a },
+		{0xF82E, 0x74 },
+		{0xF82F, 0x6a },
+		{0xF830, 0xf0 },
+		{0xF831, 0x90 },
+		{0xF832, 0x30 },
+		{0xF833, 0x30 },
+		{0xF834, 0x74 },
+		{0xF835, 0x08 },
+		{0xF836, 0xf0 },
+		{0xF837, 0x90 },
+		{0xF838, 0x30 },
+		{0xF839, 0x36 },
+		{0xF83A, 0x74 },
+		{0xF83B, 0x2c },
+		{0xF83C, 0xf0 },
+		{0xF83D, 0x90 },
+		{0xF83E, 0x30 },
+		{0xF83F, 0x41 },
+		{0xF840, 0xe4 },
+		{0xF841, 0xf0 },
+		{0xF842, 0xa3 },
+		{0xF843, 0x74 },
+		{0xF844, 0x24 },
+		{0xF845, 0xf0 },
+		{0xF846, 0x90 },
+		{0xF847, 0x30 },
+		{0xF848, 0x45 },
+		{0xF849, 0x74 },
+		{0xF84A, 0x81 },
+		{0xF84B, 0xf0 },
+		{0xF84C, 0x90 },
+		{0xF84D, 0x30 },
+		{0xF84E, 0x98 },
+		{0xF84F, 0x74 },
+		{0xF850, 0x01 },
+		{0xF851, 0xf0 },
+		{0xF852, 0x90 },
+		{0xF853, 0x30 },
+		{0xF854, 0x9d },
+		{0xF855, 0x74 },
+		{0xF856, 0x05 },
+		{0xF857, 0xf0 },
+		{0xF858, 0xe5 },
+		{0xF859, 0x7d },
+		{0xF85A, 0x70 },
+		{0xF85B, 0x22 },
+		{0xF85C, 0x90 },
+		{0xF85D, 0x02 },
+		{0xF85E, 0x00 },
+		{0xF85F, 0x74 },
+		{0xF860, 0x02 },
+		{0xF861, 0xf0 },
+		{0xF862, 0xa3 },
+		{0xF863, 0x74 },
+		{0xF864, 0x54 },
+		{0xF865, 0xf0 },
+		{0xF866, 0x90 },
+		{0xF867, 0x30 },
+		{0xF868, 0x05 },
+		{0xF869, 0x74 },
+		{0xF86A, 0x01 },
+		{0xF86B, 0xf0 },
+		{0xF86C, 0x90 },
+		{0xF86D, 0x30 },
+		{0xF86E, 0x1b },
+		{0xF86F, 0x74 },
+		{0xF870, 0x29 },
+		{0xF871, 0xf0 },
+		{0xF872, 0x90 },
+		{0xF873, 0x30 },
+		{0xF874, 0x30 },
+		{0xF875, 0xe4 },
+		{0xF876, 0xf0 },
+		{0xF877, 0x90 },
+		{0xF878, 0x30 },
+		{0xF879, 0x35 },
+		{0xF87A, 0x04 },
+		{0xF87B, 0xf0 },
+		{0xF87C, 0x80 },
+		{0xF87D, 0x69 },
+		{0xF87E, 0xe5 },
+		{0xF87F, 0x7d },
+		{0xF880, 0x64 },
+		{0xF881, 0x02 },
+		{0xF882, 0x70 },
+		{0xF883, 0x3c },
+		{0xF884, 0x90 },
+		{0xF885, 0x02 },
+		{0xF886, 0x00 },
+		{0xF887, 0x74 },
+		{0xF888, 0x04 },
+		{0xF889, 0xf0 },
+		{0xF88A, 0xa3 },
+		{0xF88B, 0x74 },
+		{0xF88C, 0x10 },
+		{0xF88D, 0xf0 },
+		{0xF88E, 0x90 },
+		{0xF88F, 0x30 },
+		{0xF890, 0x04 },
+		{0xF891, 0x74 },
+		{0xF892, 0x34 },
+		{0xF893, 0xf0 },
+		{0xF894, 0xa3 },
+		{0xF895, 0x74 },
+		{0xF896, 0x07 },
+		{0xF897, 0xf0 },
+		{0xF898, 0x90 },
+		{0xF899, 0x30 },
+		{0xF89A, 0x10 },
+		{0xF89B, 0x74 },
+		{0xF89C, 0x10 },
+		{0xF89D, 0xf0 },
+		{0xF89E, 0x90 },
+		{0xF89F, 0x30 },
+		{0xF8A0, 0x16 },
+		{0xF8A1, 0x74 },
+		{0xF8A2, 0x1f },
+		{0xF8A3, 0xf0 },
+		{0xF8A4, 0x90 },
+		{0xF8A5, 0x30 },
+		{0xF8A6, 0x1a },
+		{0xF8A7, 0x74 },
+		{0xF8A8, 0x62 },
+		{0xF8A9, 0xf0 },
+		{0xF8AA, 0xa3 },
+		{0xF8AB, 0x74 },
+		{0xF8AC, 0x2a },
+		{0xF8AD, 0xf0 },
+		{0xF8AE, 0x90 },
+		{0xF8AF, 0x30 },
+		{0xF8B0, 0x35 },
+		{0xF8B1, 0x74 },
+		{0xF8B2, 0x04 },
+		{0xF8B3, 0xf0 },
+		{0xF8B4, 0x90 },
+		{0xF8B5, 0x30 },
+		{0xF8B6, 0x41 },
+		{0xF8B7, 0x74 },
+		{0xF8B8, 0x60 },
+		{0xF8B9, 0xf0 },
+		{0xF8BA, 0xa3 },
+		{0xF8BB, 0x74 },
+		{0xF8BC, 0x64 },
+		{0xF8BD, 0xf0 },
+		{0xF8BE, 0x80 },
+		{0xF8BF, 0x27 },
+		{0xF8C0, 0xe5 },
+		{0xF8C1, 0x7d },
+		{0xF8C2, 0xb4 },
+		{0xF8C3, 0x03 },
+		{0xF8C4, 0x22 },
+		{0xF8C5, 0x90 },
+		{0xF8C6, 0x02 },
+		{0xF8C7, 0x00 },
+		{0xF8C8, 0x74 },
+		{0xF8C9, 0x02 },
+		{0xF8CA, 0xf0 },
+		{0xF8CB, 0xa3 },
+		{0xF8CC, 0x74 },
+		{0xF8CD, 0x26 },
+		{0xF8CE, 0xf0 },
+		{0xF8CF, 0x90 },
+		{0xF8D0, 0x30 },
+		{0xF8D1, 0x05 },
+		{0xF8D2, 0x74 },
+		{0xF8D3, 0x03 },
+		{0xF8D4, 0xf0 },
+		{0xF8D5, 0x90 },
+		{0xF8D6, 0x30 },
+		{0xF8D7, 0x11 },
+		{0xF8D8, 0x74 },
+		{0xF8D9, 0x01 },
+		{0xF8DA, 0xf0 },
+		{0xF8DB, 0x90 },
+		{0xF8DC, 0x30 },
+		{0xF8DD, 0x1b },
+		{0xF8DE, 0x74 },
+		{0xF8DF, 0x2a },
+		{0xF8E0, 0xf0 },
+		{0xF8E1, 0x90 },
+		{0xF8E2, 0x30 },
+		{0xF8E3, 0x35 },
+		{0xF8E4, 0x74 },
+		{0xF8E5, 0x03 },
+		{0xF8E6, 0xf0 },
+		{0xF8E7, 0x90 },
+		{0xF8E8, 0x41 },
+		{0xF8E9, 0x01 },
+		{0xF8EA, 0xe0 },
+		{0xF8EB, 0xf5 },
+		{0xF8EC, 0x79 },
+		{0xF8ED, 0x90 },
+		{0xF8EE, 0x43 },
+		{0xF8EF, 0x87 },
+		{0xF8F0, 0xe0 },
+		{0xF8F1, 0xf5 },
+		{0xF8F2, 0x7a },
+		{0xF8F3, 0x90 },
+		{0xF8F4, 0x42 },
+		{0xF8F5, 0x05 },
+		{0xF8F6, 0xe0 },
+		{0xF8F7, 0xf5 },
+		{0xF8F8, 0x7b },
+		{0xF8F9, 0x22 },
+		{0xF8FA, 0x78 },
+		{0xF8FB, 0x07 },
+		{0xF8FC, 0xe6 },
+		{0xF8FD, 0xf5 },
+		{0xF8FE, 0x7c },
+		{0xF8FF, 0xe5 },
+		{0xF900, 0x7c },
+		{0xF901, 0x60 },
+		{0xF902, 0x1e },
+		{0xF903, 0x90 },
+		{0xF904, 0x43 },
+		{0xF905, 0x83 },
+		{0xF906, 0xe0 },
+		{0xF907, 0xb4 },
+		{0xF908, 0x01 },
+		{0xF909, 0x17 },
+		{0xF90A, 0x90 },
+		{0xF90B, 0x43 },
+		{0xF90C, 0x87 },
+		{0xF90D, 0xe0 },
+		{0xF90E, 0xb4 },
+		{0xF90F, 0x01 },
+		{0xF910, 0x10 },
+		{0xF911, 0x15 },
+		{0xF912, 0x7c },
+		{0xF913, 0x90 },
+		{0xF914, 0x30 },
+		{0xF915, 0xa1 },
+		{0xF916, 0xe5 },
+		{0xF917, 0x7c },
+		{0xF918, 0xf0 },
+		{0xF919, 0x90 },
+		{0xF91A, 0x30 },
+		{0xF91B, 0xa0 },
+		{0xF91C, 0x74 },
+		{0xF91D, 0x01 },
+		{0xF91E, 0xf0 },
+		{0xF91F, 0x80 },
+		{0xF920, 0x05 },
+		{0xF921, 0xe4 },
+		{0xF922, 0x90 },
+		{0xF923, 0x30 },
+		{0xF924, 0xa0 },
+		{0xF925, 0xf0 },
+		{0xF926, 0x90 },
+		{0xF927, 0x41 },
+		{0xF928, 0x01 },
+		{0xF929, 0xe0 },
+		{0xF92A, 0xfc },
+		{0xF92B, 0x54 },
+		{0xF92C, 0x02 },
+		{0xF92D, 0xfe },
+		{0xF92E, 0xe5 },
+		{0xF92F, 0x79 },
+		{0xF930, 0x54 },
+		{0xF931, 0x02 },
+		{0xF932, 0xb5 },
+		{0xF933, 0x06 },
+		{0xF934, 0x0f },
+		{0xF935, 0x90 },
+		{0xF936, 0x43 },
+		{0xF937, 0x87 },
+		{0xF938, 0xe0 },
+		{0xF939, 0xb5 },
+		{0xF93A, 0x7a },
+		{0xF93B, 0x08 },
+		{0xF93C, 0x90 },
+		{0xF93D, 0x42 },
+		{0xF93E, 0x05 },
+		{0xF93F, 0xe0 },
+		{0xF940, 0x65 },
+		{0xF941, 0x7b },
+		{0xF942, 0x60 },
+		{0xF943, 0x0b },
+		{0xF944, 0x90 },
+		{0xF945, 0x30 },
+		{0xF946, 0x50 },
+		{0xF947, 0xe0 },
+		{0xF948, 0x54 },
+		{0xF949, 0xf9 },
+		{0xF94A, 0x44 },
+		{0xF94B, 0x02 },
+		{0xF94C, 0xf0 },
+		{0xF94D, 0x80 },
+		{0xF94E, 0x09 },
+		{0xF94F, 0x90 },
+		{0xF950, 0x30 },
+		{0xF951, 0x50 },
+		{0xF952, 0xe0 },
+		{0xF953, 0x54 },
+		{0xF954, 0xf9 },
+		{0xF955, 0x44 },
+		{0xF956, 0x04 },
+		{0xF957, 0xf0 },
+		{0xF958, 0x8c },
+		{0xF959, 0x79 },
+		{0xF95A, 0x90 },
+		{0xF95B, 0x43 },
+		{0xF95C, 0x87 },
+		{0xF95D, 0xe0 },
+		{0xF95E, 0xf5 },
+		{0xF95F, 0x7a },
+		{0xF960, 0x90 },
+		{0xF961, 0x42 },
+		{0xF962, 0x05 },
+		{0xF963, 0xe0 },
+		{0xF964, 0xf5 },
+		{0xF965, 0x7b },
+		{0xF966, 0x22 },
+		{0xF967, 0xc3 },
+		{0xF968, 0x90 },
+		{0xF969, 0x0b },
+		{0xF96A, 0x89 },
+		{0xF96B, 0xe0 },
+		{0xF96C, 0x94 },
+		{0xF96D, 0x1e },
+		{0xF96E, 0x90 },
+		{0xF96F, 0x0b },
+		{0xF970, 0x88 },
+		{0xF971, 0xe0 },
+		{0xF972, 0x94 },
+		{0xF973, 0x00 },
+		{0xF974, 0x50 },
+		{0xF975, 0x06 },
+		{0xF976, 0x7e },
+		{0xF977, 0x00 },
+		{0xF978, 0x7f },
+		{0xF979, 0x01 },
+		{0xF97A, 0x80 },
+		{0xF97B, 0x3d },
+		{0xF97C, 0xc3 },
+		{0xF97D, 0x90 },
+		{0xF97E, 0x0b },
+		{0xF97F, 0x89 },
+		{0xF980, 0xe0 },
+		{0xF981, 0x94 },
+		{0xF982, 0x3c },
+		{0xF983, 0x90 },
+		{0xF984, 0x0b },
+		{0xF985, 0x88 },
+		{0xF986, 0xe0 },
+		{0xF987, 0x94 },
+		{0xF988, 0x00 },
+		{0xF989, 0x50 },
+		{0xF98A, 0x06 },
+		{0xF98B, 0x7e },
+		{0xF98C, 0x00 },
+		{0xF98D, 0x7f },
+		{0xF98E, 0x02 },
+		{0xF98F, 0x80 },
+		{0xF990, 0x28 },
+		{0xF991, 0xc3 },
+		{0xF992, 0x90 },
+		{0xF993, 0x0b },
+		{0xF994, 0x89 },
+		{0xF995, 0xe0 },
+		{0xF996, 0x94 },
+		{0xF997, 0xfa },
+		{0xF998, 0x90 },
+		{0xF999, 0x0b },
+		{0xF99A, 0x88 },
+		{0xF99B, 0xe0 },
+		{0xF99C, 0x94 },
+		{0xF99D, 0x00 },
+		{0xF99E, 0x50 },
+		{0xF99F, 0x06 },
+		{0xF9A0, 0x7e },
+		{0xF9A1, 0x00 },
+		{0xF9A2, 0x7f },
+		{0xF9A3, 0x03 },
+		{0xF9A4, 0x80 },
+		{0xF9A5, 0x13 },
+		{0xF9A6, 0xc3 },
+		{0xF9A7, 0x90 },
+		{0xF9A8, 0x0b },
+		{0xF9A9, 0x88 },
+		{0xF9AA, 0xe0 },
+		{0xF9AB, 0x94 },
+		{0xF9AC, 0x80 },
+		{0xF9AD, 0x50 },
+		{0xF9AE, 0x06 },
+		{0xF9AF, 0x7e },
+		{0xF9B0, 0x00 },
+		{0xF9B1, 0x7f },
+		{0xF9B2, 0x04 },
+		{0xF9B3, 0x80 },
+		{0xF9B4, 0x04 },
+		{0xF9B5, 0xae },
+		{0xF9B6, 0x7e },
+		{0xF9B7, 0xaf },
+		{0xF9B8, 0x7f },
+		{0xF9B9, 0x90 },
+		{0xF9BA, 0xa0 },
+		{0xF9BB, 0xf8 },
+		{0xF9BC, 0xee },
+		{0xF9BD, 0xf0 },
+		{0xF9BE, 0xa3 },
+		{0xF9BF, 0xef },
+		{0xF9C0, 0xf0 },
+		{0xF9C1, 0x22 },
+		{0xF9C2, 0x90 },
+		{0xF9C3, 0x33 },
+		{0xF9C4, 0x82 },
+		{0xF9C5, 0xe0 },
+		{0xF9C6, 0xff },
+		{0xF9C7, 0x64 },
+		{0xF9C8, 0x01 },
+		{0xF9C9, 0x70 },
+		{0xF9CA, 0x30 },
+		{0xF9CB, 0xe5 },
+		{0xF9CC, 0x7f },
+		{0xF9CD, 0x64 },
+		{0xF9CE, 0x02 },
+		{0xF9CF, 0x45 },
+		{0xF9D0, 0x7e },
+		{0xF9D1, 0x70 },
+		{0xF9D2, 0x04 },
+		{0xF9D3, 0x7d },
+		{0xF9D4, 0x1e },
+		{0xF9D5, 0x80 },
+		{0xF9D6, 0x1d },
+		{0xF9D7, 0xe5 },
+		{0xF9D8, 0x7f },
+		{0xF9D9, 0x64 },
+		{0xF9DA, 0x03 },
+		{0xF9DB, 0x45 },
+		{0xF9DC, 0x7e },
+		{0xF9DD, 0x70 },
+		{0xF9DE, 0x04 },
+		{0xF9DF, 0x7d },
+		{0xF9E0, 0x3c },
+		{0xF9E1, 0x80 },
+		{0xF9E2, 0x11 },
+		{0xF9E3, 0xe5 },
+		{0xF9E4, 0x7f },
+		{0xF9E5, 0x64 },
+		{0xF9E6, 0x04 },
+		{0xF9E7, 0x45 },
+		{0xF9E8, 0x7e },
+		{0xF9E9, 0x70 },
+		{0xF9EA, 0x04 },
+		{0xF9EB, 0x7d },
+		{0xF9EC, 0xfa },
+		{0xF9ED, 0x80 },
+		{0xF9EE, 0x05 },
+		{0xF9EF, 0x90 },
+		{0xF9F0, 0x33 },
+		{0xF9F1, 0x81 },
+		{0xF9F2, 0xe0 },
+		{0xF9F3, 0xfd },
+		{0xF9F4, 0xae },
+		{0xF9F5, 0x05 },
+		{0xF9F6, 0x90 },
+		{0xF9F7, 0x33 },
+		{0xF9F8, 0x81 },
+		{0xF9F9, 0xed },
+		{0xF9FA, 0xf0 },
+		{0xF9FB, 0xef },
+		{0xF9FC, 0xb4 },
+		{0xF9FD, 0x01 },
+		{0xF9FE, 0x10 },
+		{0xF9FF, 0x90 },
+		{0xFA00, 0x01 },
+		{0xFA01, 0x00 },
+		{0xFA02, 0xe0 },
+		{0xFA03, 0x60 },
+		{0xFA04, 0x0a },
+		{0xFA05, 0x90 },
+		{0xFA06, 0xa1 },
+		{0xFA07, 0x10 },
+		{0xFA08, 0xe0 },
+		{0xFA09, 0xf5 },
+		{0xFA0A, 0x7e },
+		{0xFA0B, 0xa3 },
+		{0xFA0C, 0xe0 },
+		{0xFA0D, 0xf5 },
+		{0xFA0E, 0x7f },
+		{0xFA0F, 0x22 },
+		{0xFA10, 0x12 },
+		{0xFA11, 0x2f },
+		{0xFA12, 0x4d },
+		{0xFA13, 0x90 },
+		{0xFA14, 0x35 },
+		{0xFA15, 0x38 },
+		{0xFA16, 0xe0 },
+		{0xFA17, 0x70 },
+		{0xFA18, 0x05 },
+		{0xFA19, 0x12 },
+		{0xFA1A, 0x00 },
+		{0xFA1B, 0x0e },
+		{0xFA1C, 0x80 },
+		{0xFA1D, 0x03 },
+		{0xFA1E, 0x12 },
+		{0xFA1F, 0x07 },
+		{0xFA20, 0xc9 },
+		{0xFA21, 0x90 },
+		{0xFA22, 0x40 },
+		{0xFA23, 0x06 },
+		{0xFA24, 0xe0 },
+		{0xFA25, 0xf4 },
+		{0xFA26, 0x54 },
+		{0xFA27, 0x02 },
+		{0xFA28, 0xff },
+		{0xFA29, 0xe0 },
+		{0xFA2A, 0x54 },
+		{0xFA2B, 0x01 },
+		{0xFA2C, 0x4f },
+		{0xFA2D, 0x90 },
+		{0xFA2E, 0x31 },
+		{0xFA2F, 0x32 },
+		{0xFA30, 0xf0 },
+		{0xFA31, 0x90 },
+		{0xFA32, 0xfa },
+		{0xFA33, 0x9d },
+		{0xFA34, 0xe0 },
+		{0xFA35, 0x70 },
+		{0xFA36, 0x03 },
+		{0xFA37, 0x12 },
+		{0xFA38, 0x27 },
+		{0xFA39, 0x27 },
+		{0xFA3A, 0x02 },
+		{0xFA3B, 0x05 },
+		{0xFA3C, 0xac },
+		{0xFA3D, 0x22 },
+		{0xFA3E, 0xf0 },
+		{0xFA3F, 0xe5 },
+		{0xFA40, 0x3a },
+		{0xFA41, 0xb4 },
+		{0xFA42, 0x06 },
+		{0xFA43, 0x06 },
+		{0xFA44, 0x63 },
+		{0xFA45, 0x3e },
+		{0xFA46, 0x02 },
+		{0xFA47, 0x12 },
+		{0xFA48, 0x03 },
+		{0xFA49, 0xea },
+		{0xFA4A, 0x02 },
+		{0xFA4B, 0x17 },
+		{0xFA4C, 0x4a },
+		{0xFA4D, 0x22 },
+		{0x35C9, 0xFA },
+		{0x35CA, 0x01 },
+		{0x35CB, 0x67 },
+		{0x35CC, 0x01 },
+		{0x35CD, 0xC2 },
+		{0x35CE, 0x02 },
+		{0x35CF, 0x10 },
+		{0x35D0, 0x02 },
+		{0x35D1, 0x3E },
+		{0x35D3, 0xF6 },
+		{0x35D5, 0x07 },
+		{0x35D7, 0xA3 },
+		{0x35DB, 0x02 },
+		{0x35DD, 0x06 },
+		{0x35DF, 0x27 },
+		{0x35E6, 0x28 },
+		{0x35E7, 0x76 },
+		{0x35E8, 0x2A },
+		{0x35E9, 0x15 },
+		{0x35EA, 0x2D },
+		{0x35EB, 0x07 },
+		{0x35EC, 0x04 },
+		{0x35ED, 0x43 },
+		{0x35EE, 0x05 },
+		{0x35EF, 0xA9 },
+		{0x35F0, 0x17 },
+		{0x35F1, 0x41 },
+		{0x35F2, 0x24 },
+		{0x35F3, 0x88 },
+		{0x35F4, 0x01 },
+		{0x35F5, 0x54 },
+		{0x35F6, 0x01 },
+		{0x35F7, 0x55 },
+		{0x35F8, 0x2E },
+		{0x35F9, 0xF2 },
+		{0x35FA, 0x06 },
+		{0x35FB, 0x02 },
+		{0x35FC, 0x06 },
+		{0x35FD, 0x03 },
+		{0x35FE, 0x06 },
+		{0x35FF, 0x04 },
+		{0x3600, 0x0F },
+		{0x3601, 0x48 },
+		{0x3602, 0x0F },
+		{0x3603, 0x49 },
+		{0x3604, 0x0F },
+		{0x3605, 0x4A },
+		{0x35C2, 0xFF },
+		{0x35C3, 0xFF },
+		{0x35C4, 0xFF },
+		{0x35C5, 0xC0 },
+		{0x35C0, 0x01 },
+
+
+		{0xa098, 0x02 },
+		{0xa099, 0x87 },
+		{0xa09c, 0x00 },
+		{0xa09d, 0xc5 },
+		{0xa4ec, 0x05 },
+		{0xa4ed, 0x05 },
+		{0xa4f0, 0x04 },
+		{0xa4f1, 0x04 },
+		{0xa4f4, 0x04 },
+		{0xa4f5, 0x05 },
+		{0xa4f8, 0x05 },
+		{0xa4f9, 0x07 },
+		{0xa4fc, 0x07 },
+		{0xa4fd, 0x07 },
+		{0xa500, 0x07 },
+		{0xa501, 0x07 },
+		{0xa504, 0x08 },
+		{0xa505, 0x08 },
+		{0xa518, 0x01 },
+		{0xa519, 0x02 },
+		{0xa51c, 0x01 },
+		{0xa51d, 0x00 },
+		{0xa534, 0x00 },
+		{0xa535, 0x04 },
+		{0xa538, 0x04 },
+		{0xa539, 0x03 },
+		{0xa53c, 0x05 },
+		{0xa53d, 0x07 },
+		{0xa540, 0x07 },
+		{0xa541, 0x06 },
+		{0xa544, 0x07 },
+		{0xa545, 0x06 },
+		{0xa548, 0x05 },
+		{0xa549, 0x06 },
+		{0xa54c, 0x06 },
+		{0xa54d, 0x07 },
+		{0xa550, 0x07 },
+		{0xa551, 0x04 },
+		{0xa554, 0x04 },
+		{0xa555, 0x04 },
+		{0xa558, 0x05 },
+		{0xa559, 0x06 },
+		{0xa55c, 0x07 },
+		{0xa55d, 0x07 },
+		{0xa56c, 0x00 },
+		{0xa56d, 0x0a },
+		{0xa570, 0x08 },
+		{0xa571, 0x05 },
+		{0xa574, 0x04 },
+		{0xa575, 0x03 },
+		{0xa578, 0x04 },
+		{0xa579, 0x04 },
+		{0xa58c, 0x1f },
+		{0xa58d, 0x1b },
+		{0xa590, 0x17 },
+		{0xa591, 0x13 },
+		{0xa594, 0x10 },
+		{0xa595, 0x0d },
+		{0xa598, 0x0f },
+		{0xa599, 0x11 },
+		{0xa59c, 0x03 },
+		{0xa59d, 0x03 },
+		{0xa5a0, 0x03 },
+		{0xa5a1, 0x03 },
+		{0xa5a4, 0x03 },
+		{0xa5a5, 0x04 },
+		{0xa5a8, 0x05 },
+		{0xa5a9, 0x00 },
+		{0xa5ac, 0x00 },
+		{0xa5ad, 0x00 },
+		{0xa5b0, 0x00 },
+		{0xa5b1, 0x00 },
+		{0xa5b4, 0x00 },
+		{0xa5b5, 0x00 },
+		{0xa5c4, 0x1f },
+		{0xa5c5, 0x13 },
+		{0xa5c8, 0x14 },
+		{0xa5c9, 0x14 },
+		{0xa5cc, 0x14 },
+		{0xa5cd, 0x13 },
+		{0xa5d0, 0x17 },
+		{0xa5d1, 0x1a },
+		{0xa5f4, 0x05 },
+		{0xa5f5, 0x05 },
+		{0xa5f8, 0x05 },
+		{0xa5f9, 0x06 },
+		{0xa5fc, 0x06 },
+		{0xa5fd, 0x06 },
+		{0xa600, 0x06 },
+		{0xa601, 0x06 },
+		{0xa608, 0x07 },
+		{0xa609, 0x08 },
+		{0xa60c, 0x08 },
+		{0xa60d, 0x07 },
+		{0xa63c, 0x00 },
+		{0xa63d, 0x02 },
+		{0xa640, 0x02 },
+		{0xa641, 0x02 },
+		{0xa644, 0x02 },
+		{0xa645, 0x02 },
+		{0xa648, 0x03 },
+		{0xa649, 0x04 },
+		{0xa64c, 0x0a },
+		{0xa64d, 0x09 },
+		{0xa650, 0x08 },
+		{0xa651, 0x09 },
+		{0xa654, 0x09 },
+		{0xa655, 0x0a },
+		{0xa658, 0x0a },
+		{0xa659, 0x0a },
+		{0xa65c, 0x0a },
+		{0xa65d, 0x09 },
+		{0xa660, 0x09 },
+		{0xa661, 0x09 },
+		{0xa664, 0x09 },
+		{0xa665, 0x08 },
+		{0xa680, 0x01 },
+		{0xa681, 0x02 },
+		{0xa694, 0x1f },
+		{0xa695, 0x10 },
+		{0xa698, 0x0e },
+		{0xa699, 0x0c },
+		{0xa69c, 0x0d },
+		{0xa69d, 0x0d },
+		{0xa6a0, 0x0f },
+		{0xa6a1, 0x11 },
+		{0xa6a4, 0x00 },
+		{0xa6a5, 0x00 },
+		{0xa6a8, 0x00 },
+		{0xa6a9, 0x00 },
+		{0xa6ac, 0x00 },
+		{0xa6ad, 0x00 },
+		{0xa6b0, 0x00 },
+		{0xa6b1, 0x04 },
+		{0xa6b4, 0x04 },
+		{0xa6b5, 0x04 },
+		{0xa6b8, 0x04 },
+		{0xa6b9, 0x04 },
+		{0xa6bc, 0x05 },
+		{0xa6bd, 0x05 },
+		{0xa6c0, 0x1f },
+		{0xa6c1, 0x1f },
+		{0xa6c4, 0x1f },
+		{0xa6c5, 0x1f },
+		{0xa6c8, 0x1f },
+		{0xa6c9, 0x1f },
+		{0xa6cc, 0x1f },
+		{0xa6cd, 0x0b },
+		{0xa6d0, 0x0c },
+		{0xa6d1, 0x0d },
+		{0xa6d4, 0x0d },
+		{0xa6d5, 0x0d },
+		{0xa6d8, 0x11 },
+		{0xa6d9, 0x14 },
+		{0xa6fc, 0x02 },
+		{0xa6fd, 0x03 },
+		{0xa700, 0x03 },
+		{0xa701, 0x03 },
+		{0xa704, 0x03 },
+		{0xa705, 0x04 },
+		{0xa708, 0x05 },
+		{0xa709, 0x02 },
+		{0xa70c, 0x02 },
+		{0xa70d, 0x02 },
+		{0xa710, 0x03 },
+		{0xa711, 0x04 },
+		{0xa714, 0x04 },
+		{0xa715, 0x04 },
+		{0xa744, 0x00 },
+		{0xa745, 0x03 },
+		{0xa748, 0x04 },
+		{0xa749, 0x04 },
+		{0xa74c, 0x05 },
+		{0xa74d, 0x06 },
+		{0xa750, 0x07 },
+		{0xa751, 0x07 },
+		{0xa754, 0x05 },
+		{0xa755, 0x05 },
+		{0xa758, 0x05 },
+		{0xa759, 0x05 },
+		{0xa75c, 0x05 },
+		{0xa75d, 0x06 },
+		{0xa760, 0x07 },
+		{0xa761, 0x07 },
+		{0xa764, 0x06 },
+		{0xa765, 0x05 },
+		{0xa768, 0x05 },
+		{0xa769, 0x05 },
+		{0xa76c, 0x06 },
+		{0xa76d, 0x07 },
+		{0xa77c, 0x00 },
+		{0xa77d, 0x05 },
+		{0xa780, 0x05 },
+		{0xa781, 0x05 },
+		{0xa784, 0x05 },
+		{0xa785, 0x04 },
+		{0xa788, 0x05 },
+		{0xa789, 0x06 },
+		{0xa79c, 0x1f },
+		{0xa79d, 0x15 },
+		{0xa7a0, 0x13 },
+		{0xa7a1, 0x10 },
+		{0xa7a4, 0x0f },
+		{0xa7a5, 0x0d },
+		{0xa7a8, 0x11 },
+		{0xa7a9, 0x14 },
+		{0xa7ac, 0x02 },
+		{0xa7ad, 0x02 },
+		{0xa7b0, 0x02 },
+		{0xa7b1, 0x02 },
+		{0xa7b4, 0x02 },
+		{0xa7b5, 0x03 },
+		{0xa7b8, 0x03 },
+		{0xa7b9, 0x00 },
+		{0xa7bc, 0x00 },
+		{0xa7bd, 0x00 },
+		{0xa7c0, 0x00 },
+		{0xa7c1, 0x00 },
+		{0xa7c4, 0x00 },
+		{0xa7c5, 0x00 },
+		{0xa7d4, 0x1f },
+		{0xa7d5, 0x0d },
+		{0xa7d8, 0x0f },
+		{0xa7d9, 0x10 },
+		{0xa7dc, 0x10 },
+		{0xa7dd, 0x10 },
+		{0xa7e0, 0x13 },
+		{0xa7e1, 0x16 },
+		{0xa7f4, 0x00 },
+		{0xa7f5, 0x03 },
+		{0xa7f8, 0x04 },
+		{0xa7f9, 0x04 },
+		{0xa7fc, 0x04 },
+		{0xa7fd, 0x03 },
+		{0xa800, 0x03 },
+		{0xa801, 0x03 },
+		{0xa804, 0x03 },
+		{0xa805, 0x03 },
+		{0xa808, 0x03 },
+		{0xa809, 0x03 },
+		{0xa80c, 0x03 },
+		{0xa80d, 0x04 },
+		{0xa810, 0x04 },
+		{0xa811, 0x0a },
+		{0xa814, 0x0a },
+		{0xa815, 0x0a },
+		{0xa818, 0x0f },
+		{0xa819, 0x14 },
+		{0xa81c, 0x14 },
+		{0xa81d, 0x14 },
+		{0xa82c, 0x00 },
+		{0xa82d, 0x04 },
+		{0xa830, 0x02 },
+		{0xa831, 0x00 },
+		{0xa834, 0x00 },
+		{0xa835, 0x00 },
+		{0xa838, 0x00 },
+		{0xa839, 0x00 },
+		{0xa840, 0x1f },
+		{0xa841, 0x1f },
+		{0xa848, 0x1f },
+		{0xa849, 0x1f },
+		{0xa84c, 0x1f },
+		{0xa84d, 0x0c },
+		{0xa850, 0x0c },
+		{0xa851, 0x0c },
+		{0xa854, 0x0c },
+		{0xa855, 0x0c },
+		{0xa858, 0x0c },
+		{0xa859, 0x0c },
+		{0xa85c, 0x0c },
+		{0xa85d, 0x0c },
+		{0xa860, 0x0c },
+		{0xa861, 0x0c },
+		{0xa864, 0x0c },
+		{0xa865, 0x0c },
+		{0xa868, 0x0c },
+		{0xa869, 0x0c },
+		{0xa86c, 0x0c },
+		{0xa86d, 0x0c },
+		{0xa870, 0x0c },
+		{0xa871, 0x0c },
+		{0xa874, 0x0c },
+		{0xa875, 0x0c },
+		{0xa878, 0x1f },
+		{0xa879, 0x1f },
+		{0xa87c, 0x1f },
+		{0xa87d, 0x1f },
+		{0xa880, 0x1f },
+		{0xa881, 0x1f },
+		{0xa884, 0x1f },
+		{0xa885, 0x0c },
+		{0xa888, 0x0c },
+		{0xa889, 0x0c },
+		{0xa88c, 0x0c },
+		{0xa88d, 0x0c },
+		{0xa890, 0x0c },
+		{0xa891, 0x0c },
+		{0xa898, 0x1f },
+		{0xa899, 0x1f },
+		{0xa8a0, 0x1f },
+		{0xa8a1, 0x1f },
+		{0xa8a4, 0x1f },
+		{0xa8a5, 0x0c },
+		{0xa8a8, 0x0c },
+		{0xa8a9, 0x0c },
+		{0xa8ac, 0x0c },
+		{0xa8ad, 0x0c },
+		{0xa8b0, 0x0c },
+		{0xa8b1, 0x0c },
+		{0xa8b4, 0x0c },
+		{0xa8b5, 0x0c },
+		{0xa8b8, 0x0c },
+		{0xa8b9, 0x0c },
+		{0xa8bc, 0x0c },
+		{0xa8bd, 0x0c },
+		{0xa8c0, 0x0c },
+		{0xa8c1, 0x0c },
+		{0xa8c4, 0x0c },
+		{0xa8c5, 0x0c },
+		{0xa8c8, 0x0c },
+		{0xa8c9, 0x0c },
+		{0xa8cc, 0x0c },
+		{0xa8cd, 0x0c },
+		{0xa8d0, 0x1f },
+		{0xa8d1, 0x1f },
+		{0xa8d4, 0x1f },
+		{0xa8d5, 0x1f },
+		{0xa8d8, 0x1f },
+		{0xa8d9, 0x1f },
+		{0xa8dc, 0x1f },
+		{0xa8dd, 0x0c },
+		{0xa8e0, 0x0c },
+		{0xa8e1, 0x0c },
+		{0xa8e4, 0x0c },
+		{0xa8e5, 0x0c },
+		{0xa8e8, 0x0c },
+		{0xa8e9, 0x0c },
+		{0xa8f0, 0x1f },
+		{0xa8f1, 0x1f },
+		{0xa8f8, 0x1f },
+		{0xa8f9, 0x1f },
+		{0xa8fc, 0x1f },
+		{0xa8fd, 0x0c },
+		{0xa900, 0x0c },
+		{0xa901, 0x0c },
+		{0xa904, 0x0c },
+		{0xa905, 0x0c },
+		{0xa908, 0x0c },
+		{0xa909, 0x0c },
+		{0xa90c, 0x0c },
+		{0xa90d, 0x0c },
+		{0xa910, 0x0c },
+		{0xa911, 0x0c },
+		{0xa914, 0x0c },
+		{0xa915, 0x0c },
+		{0xa918, 0x0c },
+		{0xa919, 0x0c },
+		{0xa91c, 0x0c },
+		{0xa91d, 0x0c },
+		{0xa920, 0x0c },
+		{0xa921, 0x0c },
+		{0xa924, 0x0c },
+		{0xa925, 0x0c },
+		{0xa928, 0x1f },
+		{0xa929, 0x1f },
+		{0xa92c, 0x1f },
+		{0xa92d, 0x1f },
+		{0xa930, 0x1f },
+		{0xa931, 0x1f },
+		{0xa934, 0x1f },
+		{0xa935, 0x0c },
+		{0xa938, 0x0c },
+		{0xa939, 0x0c },
+		{0xa93c, 0x0c },
+		{0xa93d, 0x0c },
+		{0xa940, 0x0c },
+		{0xa941, 0x0c },
+		{0xa96c, 0x0d },
+		{0xa96d, 0x16 },
+		{0xa970, 0x19 },
+		{0xa971, 0x0e },
+		{0xa974, 0x16 },
+		{0xa975, 0x1a },
+		{0xa978, 0x0d },
+		{0xa979, 0x15 },
+		{0xa97c, 0x19 },
+		{0xa97d, 0x0d },
+		{0xa980, 0x15 },
+		{0xa981, 0x1a },
+		{0xa984, 0x0d },
+		{0xa985, 0x15 },
+		{0xa988, 0x1a },
+		{0xa989, 0x0d },
+		{0xa98c, 0x15 },
+		{0xa98d, 0x1a },
+		{0xa990, 0x0b },
+		{0xa991, 0x11 },
+		{0xa994, 0x02 },
+		{0xa995, 0x0e },
+		{0xa998, 0x16 },
+		{0xa999, 0x02 },
+		{0xa99c, 0x0c },
+		{0xa99d, 0x13 },
+		{0xa9a0, 0x02 },
+		{0xa9a1, 0x0c },
+		{0xa9a4, 0x12 },
+		{0xa9a5, 0x02 },
+		{0xa9a8, 0x0c },
+		{0xa9a9, 0x12 },
+		{0xa9ac, 0x02 },
+		{0xa9ad, 0x0c },
+		{0xa9b0, 0x12 },
+		{0xa9b1, 0x02 },
+		{0xa9b4, 0x10 },
+		{0xa9b5, 0x1e },
+		{0xa9b8, 0x0f },
+		{0xa9b9, 0x13 },
+		{0xa9bc, 0x20 },
+		{0xa9bd, 0x10 },
+		{0xa9c0, 0x11 },
+		{0xa9c1, 0x1e },
+		{0xa9c4, 0x10 },
+		{0xa9c5, 0x11 },
+		{0xa9c8, 0x1e },
+		{0xa9c9, 0x10 },
+		{0xa9cc, 0x11 },
+		{0xa9cd, 0x20 },
+		{0xa9d0, 0x10 },
+		{0xa9d1, 0x13 },
+		{0xa9d4, 0x24 },
+		{0xa9d5, 0x10 },
+		{0xa9f0, 0x02 },
+		{0xa9f1, 0x01 },
+		{0xa9f8, 0x19 },
+		{0xa9f9, 0x0b },
+		{0xa9fc, 0x0a },
+		{0xa9fd, 0x07 },
+		{0xaa00, 0x0c },
+		{0xaa01, 0x0e },
+		{0xaa08, 0x0c },
+		{0xaa09, 0x06 },
+		{0xaa0c, 0x0c },
+		{0xaa0d, 0x0a },
+		{0xaa24, 0x10 },
+		{0xaa25, 0x12 },
+		{0xaa28, 0x0b },
+		{0xaa29, 0x07 },
+		{0xaa2c, 0x10 },
+		{0xaa2d, 0x14 },
+		{0xaa34, 0x0e },
+		{0xaa35, 0x0e },
+		{0xaa38, 0x07 },
+		{0xaa39, 0x07 },
+		{0xaa3c, 0x0e },
+		{0xaa3d, 0x0c },
+		{0xaa48, 0x09 },
+		{0xaa49, 0x0c },
+		{0xaa4c, 0x0c },
+		{0xaa4d, 0x07 },
+		{0xaa54, 0x08 },
+		{0xaa55, 0x06 },
+		{0xaa58, 0x04 },
+		{0xaa59, 0x05 },
+		{0xaa5c, 0x06 },
+		{0xaa5d, 0x06 },
+		{0xaa68, 0x05 },
+		{0xaa69, 0x05 },
+		{0xaa6c, 0x04 },
+		{0xaa6d, 0x05 },
+		{0xaa74, 0x06 },
+		{0xaa75, 0x04 },
+		{0xaa78, 0x05 },
+		{0xaa79, 0x05 },
+		{0xaa7c, 0x04 },
+		{0xaa7d, 0x06 },
+		{0xac18, 0x14 },
+		{0xac19, 0x00 },
+		{0xac1c, 0x14 },
+		{0xac1d, 0x00 },
+		{0xac20, 0x14 },
+		{0xac21, 0x00 },
+		{0xac24, 0x14 },
+		{0xac25, 0x00 },
+		{0xac28, 0x14 },
+		{0xac29, 0x00 },
+		{0xac2c, 0x14 },
+		{0xac2d, 0x00 },
+		{0xac34, 0x16 },
+		{0xac35, 0x00 },
+		{0xac38, 0x16 },
+		{0xac39, 0x00 },
+		{0xac3c, 0x16 },
+		{0xac3d, 0x00 },
+		{0xac40, 0x16 },
+		{0xac41, 0x00 },
+		{0xac44, 0x16 },
+		{0xac45, 0x00 },
+		{0xac48, 0x16 },
+		{0xac49, 0x00 },
+		{0xac50, 0x1b },
+		{0xac51, 0x00 },
+		{0xac54, 0x1b },
+		{0xac55, 0x00 },
+		{0xac58, 0x1b },
+		{0xac59, 0x00 },
+		{0xac5c, 0x1b },
+		{0xac5d, 0x00 },
+		{0xac60, 0x1b },
+		{0xac61, 0x00 },
+		{0xac64, 0x1b },
+		{0xac65, 0x00 },
+		{0xac74, 0x09 },
+		{0xac75, 0x0c },
+		{0xac78, 0x0f },
+		{0xac79, 0x11 },
+		{0xac7c, 0x12 },
+		{0xac7d, 0x14 },
+		{0xac80, 0x09 },
+		{0xac81, 0x0c },
+		{0xac84, 0x0f },
+		{0xac85, 0x11 },
+		{0xac88, 0x12 },
+		{0xac89, 0x14 },
+		{0xac8c, 0x09 },
+		{0xac8d, 0x0c },
+		{0xac90, 0x0f },
+		{0xac91, 0x11 },
+		{0xac94, 0x12 },
+		{0xac95, 0x14 },
+		{0xac98, 0x09 },
+		{0xac99, 0x0c },
+		{0xac9c, 0x0f },
+		{0xac9d, 0x11 },
+		{0xaca0, 0x12 },
+		{0xaca1, 0x14 },
+		{0xaca4, 0x09 },
+		{0xaca5, 0x0c },
+		{0xaca8, 0x0f },
+		{0xaca9, 0x11 },
+		{0xacac, 0x12 },
+		{0xacad, 0x14 },
+		{0xacb0, 0x07 },
+		{0xacb1, 0x09 },
+		{0xacb4, 0x0c },
+		{0xacb5, 0x0d },
+		{0xacb8, 0x0d },
+		{0xacb9, 0x0e },
+		{0xacbc, 0x05 },
+		{0xacbd, 0x07 },
+		{0xacc0, 0x0a },
+		{0xacc1, 0x0b },
+		{0xacc4, 0x0b },
+		{0xacc5, 0x0c },
+		{0xacc8, 0x03 },
+		{0xacc9, 0x04 },
+		{0xaccc, 0x07 },
+		{0xaccd, 0x08 },
+		{0xacd0, 0x09 },
+		{0xacd1, 0x09 },
+		{0x35B5, 0x01 },
+		{0x35BC, 0x01 },
+		{0x360A, 0x02 },
+		{0xFA9B, 0x01 },
+};
+
+#define NUM_LSC_CAST_REGS      33
+
+enum LSC_Cast_t{
+	cast_H = 0,
+	cast_U30,
+	cast_CW,
+	cast_D,
+	cast_MAX
+};
+
+static short int LSC_CorrectionForCast[cast_MAX][NUM_LSC_CAST_REGS] = {
+	{-30, -20,  8, 11, -16, -26, -35, -53, -9, -10, 44, 57, -39,
+		-14, 50, -173, -38, -32, -1, 9, 39, 51, -33, -49, -28,
+		-22, 7, 11, -21, 17, -62, -56, 0},
+	{-29, -18,  6,  1,  17, -35, -77, 0, 5, -17, -6, -22, -41, -1,
+		-37, 83, -38, -32, 1, -2, 15, 25, -67, 19, -28, -22, 5,
+		2, -18, 21, -86, 0, 0},
+	{-10, -15, -4, -6,  -8,  -3, -63, 8, 25, -9, -39, -51, -9,
+		0, -21, 112, -10, -23, -7, -9, 10, 18, -11, 23, -10,
+		-15, -4, -6, -10, -3, -52, 7, 0},
+	{  5,   3, -4, -5,  -1,   3,   4, 8, 12, 3, -22, -21, 7, 17,
+		2, 35, 8, 2, -3, -2, -9, -5, 10, 4, 9, 2, -4, -5,
+		-2, 0, -6, 9, 0}
+};
+
+static unsigned short LSC_CastRegs[] = {
+	0xFB7E,			/* H   */
+	0xFB3C,			/* U30 */
+	0xFAFA,			/* CW  */
+	0xFAB8			/* D65 */
+};
+
+/*=============================================================*/
+
+static int vx6953_i2c_rxdata(unsigned short saddr,
+	unsigned char *rxdata, int length)
+{
+	struct i2c_msg msgs[] = {
+		{
+			.addr  = saddr,
+			.flags = 0,
+			.len   = 2,
+			.buf   = rxdata,
+		},
+		{
+			.addr  = saddr,
+			.flags = I2C_M_RD,
+			.len   = 2,
+			.buf   = rxdata,
+		},
+	};
+	if (i2c_transfer(vx6953_client->adapter, msgs, 2) < 0) {
+		CDBG("vx6953_i2c_rxdata failed!\n");
+		return -EIO;
+	}
+	return 0;
+}
+static int32_t vx6953_i2c_txdata(unsigned short saddr,
+				unsigned char *txdata, int length)
+{
+	struct i2c_msg msg[] = {
+		{
+			.addr = saddr,
+			.flags = 0,
+			.len = length,
+			.buf = txdata,
+		 },
+	};
+	if (i2c_transfer(vx6953_client->adapter, msg, 1) < 0) {
+		CDBG("vx6953_i2c_txdata faild 0x%x\n", vx6953_client->addr);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+
+static int32_t vx6953_i2c_read(unsigned short raddr,
+	unsigned short *rdata, int rlen)
+{
+	int32_t rc = 0;
+	unsigned char buf[2];
+	if (!rdata)
+		return -EIO;
+	memset(buf, 0, sizeof(buf));
+	buf[0] = (raddr & 0xFF00) >> 8;
+	buf[1] = (raddr & 0x00FF);
+	rc = vx6953_i2c_rxdata(vx6953_client->addr>>1, buf, rlen);
+	if (rc < 0) {
+		CDBG("vx6953_i2c_read 0x%x failed!\n", raddr);
+		return rc;
+	}
+	*rdata = (rlen == 2 ? buf[0] << 8 | buf[1] : buf[0]);
+	return rc;
+}
+static int32_t vx6953_i2c_write_b_sensor(unsigned short waddr, uint8_t bdata)
+{
+	int32_t rc = -EFAULT;
+	unsigned char buf[3];
+	memset(buf, 0, sizeof(buf));
+	buf[0] = (waddr & 0xFF00) >> 8;
+	buf[1] = (waddr & 0x00FF);
+	buf[2] = bdata;
+	CDBG("i2c_write_b addr = 0x%x, val = 0x%x\n", waddr, bdata);
+	rc = vx6953_i2c_txdata(vx6953_client->addr>>1, buf, 3);
+	if (rc < 0) {
+		CDBG("i2c_write_b failed, addr = 0x%x, val = 0x%x!\n",
+			waddr, bdata);
+	}
+	return rc;
+}
+static int32_t vx6953_i2c_write_w_sensor(unsigned short waddr, uint16_t wdata)
+{
+	int32_t rc = -EFAULT;
+	unsigned char buf[4];
+	memset(buf, 0, sizeof(buf));
+	buf[0] = (waddr & 0xFF00) >> 8;
+	buf[1] = (waddr & 0x00FF);
+	buf[2] = (wdata & 0xFF00) >> 8;
+	buf[3] = (wdata & 0x00FF);
+	CDBG("i2c_write_b addr = 0x%x, val = 0x%x\n", waddr, wdata);
+	rc = vx6953_i2c_txdata(vx6953_client->addr>>1, buf, 4);
+	if (rc < 0) {
+		CDBG("i2c_write_b failed, addr = 0x%x, val = 0x%x!\n",
+			waddr, wdata);
+	}
+	return rc;
+}
+static int32_t vx6953_i2c_write_seq_sensor(unsigned short waddr,
+	uint8_t *bdata, uint16_t len)
+{
+	int32_t rc = -EFAULT;
+	unsigned char buf[len+2];
+	int i;
+	memset(buf, 0, sizeof(buf));
+	buf[0] = (waddr & 0xFF00) >> 8;
+	buf[1] = (waddr & 0x00FF);
+	for (i = 2; i < len+2; i++)
+		buf[i] = *bdata++;
+	rc = vx6953_i2c_txdata(vx6953_client->addr>>1, buf, len+2);
+	if (rc < 0) {
+		CDBG("i2c_write_b failed, addr = 0x%x, val = 0x%x!\n",
+			 waddr, bdata[0]);
+	}
+	return rc;
+}
+
+static int32_t vx6953_i2c_write_w_table(struct vx6953_i2c_reg_conf const
+					 *reg_conf_tbl, int num)
+{
+	int i;
+	int32_t rc = -EIO;
+	for (i = 0; i < num; i++) {
+		rc = vx6953_i2c_write_b_sensor(reg_conf_tbl->waddr,
+			reg_conf_tbl->wdata);
+		if (rc < 0)
+			break;
+		reg_conf_tbl++;
+	}
+	return rc;
+}
+
+static void vx6953_get_pict_fps(uint16_t fps, uint16_t *pfps)
+{
+	/* input fps is preview fps in Q8 format */
+	uint16_t preview_frame_length_lines, snapshot_frame_length_lines;
+	uint16_t preview_line_length_pck, snapshot_line_length_pck;
+	uint32_t divider, d1, d2;
+	/* Total frame_length_lines and line_length_pck for preview */
+	preview_frame_length_lines = VX6953_QTR_SIZE_HEIGHT +
+		VX6953_VER_QTR_BLK_LINES;
+	preview_line_length_pck = VX6953_QTR_SIZE_WIDTH +
+		VX6953_HRZ_QTR_BLK_PIXELS;
+	/* Total frame_length_lines and line_length_pck for snapshot */
+	snapshot_frame_length_lines = VX6953_FULL_SIZE_HEIGHT +
+		VX6953_VER_FULL_BLK_LINES;
+	snapshot_line_length_pck = VX6953_FULL_SIZE_WIDTH +
+		VX6953_HRZ_FULL_BLK_PIXELS;
+	d1 = preview_frame_length_lines * 0x00000400/
+		snapshot_frame_length_lines;
+	d2 = preview_line_length_pck * 0x00000400/
+		snapshot_line_length_pck;
+	divider = d1 * d2 / 0x400;
+	/*Verify PCLK settings and frame sizes.*/
+	*pfps = (uint16_t) (fps * divider / 0x400);
+	/* 2 is the ratio of no.of snapshot channels
+	to number of preview channels */
+
+}
+
+static uint16_t vx6953_get_prev_lines_pf(void)
+{
+	if (vx6953_ctrl->prev_res == QTR_SIZE)
+		return VX6953_QTR_SIZE_HEIGHT + VX6953_VER_QTR_BLK_LINES;
+	else
+		return VX6953_FULL_SIZE_HEIGHT + VX6953_VER_FULL_BLK_LINES;
+
+}
+
+static uint16_t vx6953_get_prev_pixels_pl(void)
+{
+	if (vx6953_ctrl->prev_res == QTR_SIZE)
+		return VX6953_QTR_SIZE_WIDTH + VX6953_HRZ_QTR_BLK_PIXELS;
+	else
+		return VX6953_FULL_SIZE_WIDTH + VX6953_HRZ_FULL_BLK_PIXELS;
+}
+
+static uint16_t vx6953_get_pict_lines_pf(void)
+{
+		if (vx6953_ctrl->pict_res == QTR_SIZE)
+			return VX6953_QTR_SIZE_HEIGHT +
+				VX6953_VER_QTR_BLK_LINES;
+		else
+			return VX6953_FULL_SIZE_HEIGHT +
+				VX6953_VER_FULL_BLK_LINES;
+}
+
+static uint16_t vx6953_get_pict_pixels_pl(void)
+{
+	if (vx6953_ctrl->pict_res == QTR_SIZE)
+		return VX6953_QTR_SIZE_WIDTH +
+			VX6953_HRZ_QTR_BLK_PIXELS;
+	else
+		return VX6953_FULL_SIZE_WIDTH +
+			VX6953_HRZ_FULL_BLK_PIXELS;
+}
+
+static uint32_t vx6953_get_pict_max_exp_lc(void)
+{
+	if (vx6953_ctrl->pict_res == QTR_SIZE)
+		return (VX6953_QTR_SIZE_HEIGHT +
+			VX6953_VER_QTR_BLK_LINES)*24;
+	else
+		return (VX6953_FULL_SIZE_HEIGHT +
+			VX6953_VER_FULL_BLK_LINES)*24;
+}
+
+static int32_t vx6953_set_fps(struct fps_cfg	*fps)
+{
+	uint16_t total_lines_per_frame;
+	int32_t rc = 0;
+	total_lines_per_frame = (uint16_t)((VX6953_QTR_SIZE_HEIGHT +
+		VX6953_VER_QTR_BLK_LINES) * vx6953_ctrl->fps_divider/0x400);
+
+	vx6953_i2c_write_b_sensor(REG_GROUPED_PARAMETER_HOLD,
+		GROUPED_PARAMETER_HOLD);
+	if (vx6953_i2c_write_b_sensor(REG_FRAME_LENGTH_LINES_HI,
+		((total_lines_per_frame & 0xFF00) >> 8)) < 0)
+		return rc;
+	if (vx6953_i2c_write_b_sensor(REG_FRAME_LENGTH_LINES_LO,
+		(total_lines_per_frame & 0x00FF)) < 0)
+		return rc;
+	vx6953_i2c_write_b_sensor(REG_GROUPED_PARAMETER_HOLD,
+		GROUPED_PARAMETER_HOLD_OFF);
+	return rc;
+}
+
+static int32_t vx6953_write_exp_gain(uint16_t gain, uint32_t line)
+{
+	uint16_t line_length_pck, frame_length_lines;
+	uint8_t gain_hi, gain_lo;
+	uint8_t intg_time_hi, intg_time_lo;
+	uint8_t frame_length_lines_hi = 0, frame_length_lines_lo = 0;
+	int32_t rc = 0;
+	if (vx6953_ctrl->sensormode != SENSOR_SNAPSHOT_MODE) {
+		frame_length_lines = VX6953_QTR_SIZE_HEIGHT +
+		VX6953_VER_QTR_BLK_LINES;
+		line_length_pck = VX6953_QTR_SIZE_WIDTH +
+			VX6953_HRZ_QTR_BLK_PIXELS;
+		if (line > (frame_length_lines -
+			VX6953_STM5M0EDOF_OFFSET)) {
+			vx6953_ctrl->fps = (uint16_t) (30 * Q8 *
+			(frame_length_lines - VX6953_STM5M0EDOF_OFFSET)/
+			line);
+		} else {
+			vx6953_ctrl->fps = (uint16_t) (30 * Q8);
+		}
+	} else {
+		frame_length_lines = VX6953_FULL_SIZE_HEIGHT +
+				VX6953_VER_FULL_BLK_LINES;
+		line_length_pck = VX6953_FULL_SIZE_WIDTH +
+				VX6953_HRZ_FULL_BLK_PIXELS;
+	}
+
+	vx6953_i2c_write_b_sensor(REG_GROUPED_PARAMETER_HOLD,
+		GROUPED_PARAMETER_HOLD);
+	if ((line + VX6953_STM5M0EDOF_OFFSET) > MAX_FRAME_LENGTH_LINES) {
+		frame_length_lines = MAX_FRAME_LENGTH_LINES;
+		line = MAX_FRAME_LENGTH_LINES - VX6953_STM5M0EDOF_OFFSET;
+	} else if ((line + VX6953_STM5M0EDOF_OFFSET) > frame_length_lines) {
+		frame_length_lines = line + VX6953_STM5M0EDOF_OFFSET;
+		line = frame_length_lines;
+	}
+
+	frame_length_lines_hi = (uint8_t) ((frame_length_lines &
+		0xFF00) >> 8);
+	frame_length_lines_lo = (uint8_t) (frame_length_lines &
+		0x00FF);
+	vx6953_i2c_write_b_sensor(REG_FRAME_LENGTH_LINES_HI,
+		frame_length_lines_hi);
+	vx6953_i2c_write_b_sensor(REG_FRAME_LENGTH_LINES_LO,
+		frame_length_lines_lo);
+
+	/* update analogue gain registers */
+	gain_hi = (uint8_t) ((gain & 0xFF00) >> 8);
+	gain_lo = (uint8_t) (gain & 0x00FF);
+	vx6953_i2c_write_b_sensor(REG_ANALOGUE_GAIN_CODE_GLOBAL_LO,
+		gain_lo);
+	vx6953_i2c_write_b_sensor(REG_DIGITAL_GAIN_GREEN_R_LO, gain_hi);
+	vx6953_i2c_write_b_sensor(REG_DIGITAL_GAIN_RED_LO, gain_hi);
+	vx6953_i2c_write_b_sensor(REG_DIGITAL_GAIN_BLUE_LO, gain_hi);
+	vx6953_i2c_write_b_sensor(REG_DIGITAL_GAIN_GREEN_B_LO, gain_hi);
+	CDBG("%s, gain_hi 0x%x, gain_lo 0x%x\n", __func__,
+		gain_hi, gain_lo);
+	/* update line count registers */
+	intg_time_hi = (uint8_t) (((uint16_t)line & 0xFF00) >> 8);
+	intg_time_lo = (uint8_t) ((uint16_t)line & 0x00FF);
+	vx6953_i2c_write_b_sensor(REG_COARSE_INTEGRATION_TIME_HI,
+		intg_time_hi);
+	vx6953_i2c_write_b_sensor(REG_COARSE_INTEGRATION_TIME_LO,
+		intg_time_lo);
+	vx6953_i2c_write_b_sensor(REG_GROUPED_PARAMETER_HOLD,
+		GROUPED_PARAMETER_HOLD_OFF);
+
+	return rc;
+}
+
+static int32_t vx6953_set_pict_exp_gain(uint16_t gain, uint32_t line)
+{
+	int32_t rc = 0;
+	rc = vx6953_write_exp_gain(gain, line);
+	return rc;
+} /* endof vx6953_set_pict_exp_gain*/
+
+static int32_t vx6953_move_focus(int direction,
+	int32_t num_steps)
+{
+	return 0;
+}
+
+
+static int32_t vx6953_set_default_focus(uint8_t af_step)
+{
+	return 0;
+}
+
+static int32_t vx6953_test(enum vx6953_test_mode_t mo)
+{
+	int32_t rc = 0;
+	if (mo == TEST_OFF)
+		return rc;
+	else {
+		/* REG_0x30D8[4] is TESBYPEN: 0: Normal Operation,
+		1: Bypass Signal Processing
+		REG_0x30D8[5] is EBDMASK: 0:
+		Output Embedded data, 1: No output embedded data */
+		if (vx6953_i2c_write_b_sensor(REG_TEST_PATTERN_MODE,
+			(uint8_t) mo) < 0) {
+			return rc;
+		}
+	}
+	return rc;
+}
+
+static int vx6953_enable_edof(enum edof_mode_t edof_mode)
+{
+	int rc = 0;
+	if (edof_mode == VX6953_EDOF_ESTIMATION) {
+		/* EDof Estimation mode for preview */
+		if (vx6953_i2c_write_b_sensor(REG_0x0b80, 0x02) < 0)
+			return rc;
+		CDBG("VX6953_EDOF_ESTIMATION");
+	} else if (edof_mode == VX6953_EDOF_APPLICATION) {
+		/* EDof Application mode for Capture */
+		if (vx6953_i2c_write_b_sensor(REG_0x0b80, 0x01) < 0)
+			return rc;
+		CDBG("VX6953_EDOF_APPLICATION");
+	} else {
+		/* EDOF disabled */
+		if (vx6953_i2c_write_b_sensor(REG_0x0b80, 0x00) < 0)
+			return rc;
+		CDBG("VX6953_EDOF_DISABLE");
+	}
+	return rc;
+}
+
+static int32_t vx6953_patch_for_cut2(void)
+{
+	int32_t rc = 0;
+	rc = vx6953_i2c_write_w_table(patch_tbl_cut2,
+		ARRAY_SIZE(patch_tbl_cut2));
+	if (rc < 0)
+		return rc;
+
+	return rc;
+}
+
+static int32_t vx6953_lsc_patch(void)
+{
+	int32_t rc = 0;
+	int i, j;
+	short int  v;
+	unsigned short version = 0;
+	unsigned short LSC_Raw[NUM_LSC_CAST_REGS];
+	unsigned short LSC_Fixed[NUM_LSC_CAST_REGS];
+
+	vx6953_i2c_read(0x10, &version, 1);
+	CDBG("Cut 3 Version %d\n", version);
+	if (version != 1)
+		return 0;
+
+	vx6953_i2c_write_b_sensor(0x3640, 0x00);
+	for (j = cast_H; j < cast_MAX; j++) {
+		for (i = 0; i < NUM_LSC_CAST_REGS; i++) {
+			rc = vx6953_i2c_read(LSC_CastRegs[cast_D]+(2*i),
+								&LSC_Raw[i], 2);
+			if (rc < 0)
+				return rc;
+			v = LSC_Raw[i];
+			v +=  LSC_CorrectionForCast[j][i];
+			LSC_Fixed[i] = (unsigned short) v;
+		}
+		for (i = 0; i < NUM_LSC_CAST_REGS; i++) {
+			rc = vx6953_i2c_write_w_sensor(LSC_CastRegs[j]+(2*i),
+								LSC_Fixed[i]);
+			if (rc < 0)
+				return rc;
+		}
+	}
+	CDBG("vx6953_lsc_patch done\n");
+	return rc;
+}
+
+static int32_t vx6953_sensor_setting(int update_type, int rt)
+{
+
+	int32_t rc = 0;
+	unsigned short frame_cnt;
+	struct msm_camera_csi_params vx6953_csi_params;
+	if (vx6953_ctrl->sensor_type != VX6953_STM5M0EDOF_CUT_2) {
+		switch (update_type) {
+		case REG_INIT:
+		if (rt == RES_PREVIEW || rt == RES_CAPTURE) {
+			struct vx6953_i2c_reg_conf init_tbl[] = {
+				{REG_0x0112,
+					vx6953_regs.reg_pat_init[0].
+					reg_0x0112},
+				{REG_0x0113,
+					vx6953_regs.reg_pat_init[0].
+					reg_0x0113},
+				{REG_VT_PIX_CLK_DIV,
+					vx6953_regs.reg_pat_init[0].
+					vt_pix_clk_div},
+				{0x303, 0x01},
+				{0x30b, 0x01},
+				{REG_PRE_PLL_CLK_DIV,
+					vx6953_regs.reg_pat_init[0].
+					pre_pll_clk_div},
+				{REG_PLL_MULTIPLIER,
+					vx6953_regs.reg_pat_init[0].
+					pll_multiplier},
+				{REG_OP_PIX_CLK_DIV,
+					vx6953_regs.reg_pat_init[0].
+					op_pix_clk_div},
+				{REG_0x3210, 0x01},
+				{REG_0x0111,
+					vx6953_regs.reg_pat_init[0].
+					reg_0x0111},
+				{REG_0x0b00,
+					vx6953_regs.reg_pat_init[0].
+					reg_0x0b00},
+				{REG_0x0136,
+					vx6953_regs.reg_pat_init[0].
+					reg_0x0136},
+				{REG_0x0137,
+					vx6953_regs.reg_pat_init[0].
+					reg_0x0137},
+				{REG_0x0b06,
+					vx6953_regs.reg_pat_init[0].
+					reg_0x0b06},
+				{REG_0x0b07,
+					vx6953_regs.reg_pat_init[0].
+					reg_0x0b07},
+				{REG_0x0b08,
+					vx6953_regs.reg_pat_init[0].
+					reg_0x0b08},
+				{REG_0x0b09,
+					vx6953_regs.reg_pat_init[0].
+					reg_0x0b09},
+				{REG_0x0b83,
+					vx6953_regs.reg_pat_init[0].
+					reg_0x0b83},
+				{REG_0x0b84,
+					vx6953_regs.reg_pat_init[0].
+					reg_0x0b84},
+				{REG_0x0b85,
+					vx6953_regs.reg_pat_init[0].
+					reg_0x0b85},
+				{REG_0x0b88,
+					vx6953_regs.reg_pat_init[0].
+					reg_0x0b88},
+				{REG_0x0b89,
+					vx6953_regs.reg_pat_init[0].
+					reg_0x0b89},
+				{REG_0x0b8a,
+					vx6953_regs.reg_pat_init[0].
+					reg_0x0b8a},
+				{0x3393, 0x06},
+				{0x3394, 0x07},
+				{0x338d, 0x08},
+				{0x338e, 0x08},
+				{0x338f, 0x00},
+			};
+			/* reset fps_divider */
+			vx6953_ctrl->fps = 30 * Q8;
+			/* stop streaming */
+
+			count = 0;
+			CDBG("Init vx6953_sensor_setting standby\n");
+			if (vx6953_i2c_write_b_sensor(REG_MODE_SELECT,
+				MODE_SELECT_STANDBY_MODE) < 0)
+				return rc;
+			msleep(vx6953_stm5m0edof_delay_msecs_stdby);
+			vx6953_i2c_write_b_sensor(REG_GROUPED_PARAMETER_HOLD,
+			GROUPED_PARAMETER_HOLD);
+
+			rc = vx6953_i2c_write_w_table(cut3_cali_data,
+				ARRAY_SIZE(cut3_cali_data));
+
+			vx6953_lsc_patch();
+
+			vx6953_i2c_write_w_sensor(0x100A, 0x07A3);
+			vx6953_i2c_write_w_sensor(0x114A, 0x002A);
+			vx6953_i2c_write_w_sensor(0x1716, 0x0204);
+			vx6953_i2c_write_w_sensor(0x1718, 0x0880);
+
+			rc = vx6953_i2c_write_w_table(&init_tbl[0],
+				ARRAY_SIZE(init_tbl));
+			if (rc < 0)
+				return rc;
+
+			msleep(10);
+
+		}
+		return rc;
+		case UPDATE_PERIODIC:
+		if (rt == RES_PREVIEW || rt == RES_CAPTURE) {
+			struct vx6953_i2c_reg_conf preview_mode_tbl[] = {
+				{0x200, 0x02},
+				{0x201, 0x26},
+				{REG_COARSE_INTEGRATION_TIME_HI,
+					vx6953_regs.reg_pat[rt].
+					coarse_integration_time_hi},
+				{REG_COARSE_INTEGRATION_TIME_LO,
+					vx6953_regs.reg_pat[rt].
+					coarse_integration_time_lo},
+				{REG_ANALOGUE_GAIN_CODE_GLOBAL_LO,
+					vx6953_regs.reg_pat[rt].
+					analogue_gain_code_global},
+				{REG_FRAME_LENGTH_LINES_HI,
+					vx6953_regs.reg_pat[rt].
+					frame_length_lines_hi},
+				{REG_FRAME_LENGTH_LINES_LO,
+					vx6953_regs.reg_pat[rt].
+					frame_length_lines_lo},
+				{REG_LINE_LENGTH_PCK_HI,
+					vx6953_regs.reg_pat[rt].
+					line_length_pck_hi},
+				{REG_LINE_LENGTH_PCK_LO,
+					vx6953_regs.reg_pat[rt].
+					line_length_pck_lo},
+				{REG_0x0b80,
+					vx6953_regs.reg_pat[rt].
+					reg_0x0b80},
+				{REG_0x0900,
+					vx6953_regs.reg_pat[rt].
+					reg_0x0900},
+				{REG_0x0901,
+					vx6953_regs.reg_pat[rt].
+					reg_0x0901},
+				{REG_0x0902,
+					vx6953_regs.reg_pat[rt].
+					reg_0x0902},
+				{REG_0x0383,
+					vx6953_regs.reg_pat[rt].
+					reg_0x0383},
+				{REG_0x0387,
+					vx6953_regs.reg_pat[rt].
+					reg_0x0387},
+				{REG_0x034c,
+					vx6953_regs.reg_pat[rt].
+					reg_0x034c},
+				{REG_0x034d,
+					vx6953_regs.reg_pat[rt].
+					reg_0x034d},
+				{REG_0x034e,
+					vx6953_regs.reg_pat[rt].
+					reg_0x034e},
+				{REG_0x034f,
+					vx6953_regs.reg_pat[rt].
+					reg_0x034f},
+				{REG_0x3640, 0x00},
+			};
+
+			struct vx6953_i2c_reg_conf snapshot_mode_tbl[] = {
+				{0x0200, 0x02},
+				{0x0201, 0x54},
+				{REG_COARSE_INTEGRATION_TIME_HI,
+					vx6953_regs.reg_pat[rt].
+					coarse_integration_time_hi},
+				{REG_COARSE_INTEGRATION_TIME_LO,
+					vx6953_regs.reg_pat[rt].
+					coarse_integration_time_lo},
+				{REG_ANALOGUE_GAIN_CODE_GLOBAL_LO,
+					vx6953_regs.reg_pat[rt].
+					analogue_gain_code_global},
+				{REG_FRAME_LENGTH_LINES_HI,
+					vx6953_regs.reg_pat[rt].
+					frame_length_lines_hi},
+				{REG_FRAME_LENGTH_LINES_LO,
+					vx6953_regs.reg_pat[rt].
+					frame_length_lines_lo},
+				{REG_LINE_LENGTH_PCK_HI,
+					vx6953_regs.reg_pat[rt].
+					line_length_pck_hi},
+				{REG_LINE_LENGTH_PCK_LO,
+					vx6953_regs.reg_pat[rt].
+					line_length_pck_lo},
+				{REG_0x0b80,
+					vx6953_regs.reg_pat[rt].
+					reg_0x0b80},
+				{REG_0x0900,
+					vx6953_regs.reg_pat[rt].
+					reg_0x0900},
+				{REG_0x0901,
+					vx6953_regs.reg_pat[rt].
+					reg_0x0901},
+				{REG_0x0902,
+					vx6953_regs.reg_pat[rt].
+					reg_0x0902},
+				{REG_0x0383,
+					vx6953_regs.reg_pat[rt].
+					reg_0x0383},
+				{REG_0x0387,
+					vx6953_regs.reg_pat[rt].
+					reg_0x0387},
+				{REG_0x034c,
+					vx6953_regs.reg_pat[rt].
+					reg_0x034c},
+				{REG_0x034d,
+					vx6953_regs.reg_pat[rt].
+					reg_0x034d},
+				{REG_0x034e,
+					vx6953_regs.reg_pat[rt].
+					reg_0x034e},
+				{REG_0x034f,
+					vx6953_regs.reg_pat[rt].
+					reg_0x034f},
+				{0x3140, 0x01},
+				{REG_0x3640, 0x00},
+			};
+			/* stop streaming */
+
+			if (vx6953_i2c_write_b_sensor(REG_MODE_SELECT,
+				MODE_SELECT_STANDBY_MODE) < 0)
+				return rc;
+			msleep(vx6953_stm5m0edof_delay_msecs_stdby);
+
+			if (count == 0) {
+				vx6953_csi_params.data_format = CSI_8BIT;
+				vx6953_csi_params.lane_cnt = 1;
+				vx6953_csi_params.lane_assign = 0xe4;
+				vx6953_csi_params.dpcm_scheme = 0;
+				vx6953_csi_params.settle_cnt = 7;
+				rc = msm_camio_csi_config(&vx6953_csi_params);
+				if (rc < 0)
+					CDBG("config csi controller failed\n");
+
+				msleep(20);
+				count = 1;
+			}
+
+			vx6953_i2c_write_b_sensor(REG_GROUPED_PARAMETER_HOLD,
+			GROUPED_PARAMETER_HOLD);
+
+			if (rt == RES_PREVIEW) {
+				rc = vx6953_i2c_write_w_table(
+					&preview_mode_tbl[0],
+					ARRAY_SIZE(preview_mode_tbl));
+				if (rc < 0)
+					return rc;
+			}
+			if (rt == RES_CAPTURE) {
+				rc = vx6953_i2c_write_w_table(
+					&snapshot_mode_tbl[0],
+					ARRAY_SIZE(snapshot_mode_tbl));
+				if (rc < 0)
+					return rc;
+			}
+
+			vx6953_i2c_write_b_sensor(REG_GROUPED_PARAMETER_HOLD,
+			GROUPED_PARAMETER_HOLD_OFF);
+
+			/* Start sensor streaming */
+			if (vx6953_i2c_write_b_sensor(REG_MODE_SELECT,
+				MODE_SELECT_STREAM) < 0)
+				return rc;
+			msleep(10);
+
+			if (vx6953_i2c_read(0x0005, &frame_cnt, 1) < 0)
+				return rc;
+
+			while (frame_cnt == 0xFF) {
+				if (vx6953_i2c_read(0x0005, &frame_cnt, 1) < 0)
+					return rc;
+				CDBG("frame_cnt=%d\n", frame_cnt);
+				msleep(2);
+			}
+		}
+		return rc;
+		default:
+			return rc;
+		}
+	} else {
+		switch (update_type) {
+		case REG_INIT:
+		if (rt == RES_PREVIEW || rt == RES_CAPTURE) {
+			struct vx6953_i2c_reg_conf init_tbl[] = {
+			{REG_0x0112,
+				vx6953_regs.reg_pat_init[0].reg_0x0112},
+			{REG_0x0113,
+				vx6953_regs.reg_pat_init[0].reg_0x0113},
+			{REG_VT_PIX_CLK_DIV,
+				vx6953_regs.reg_pat_init[0].
+				vt_pix_clk_div},
+			{REG_PRE_PLL_CLK_DIV,
+				vx6953_regs.reg_pat_init[0].
+				pre_pll_clk_div},
+			{REG_PLL_MULTIPLIER,
+				vx6953_regs.reg_pat_init[0].
+				pll_multiplier},
+			{REG_OP_PIX_CLK_DIV,
+				vx6953_regs.reg_pat_init[0].
+				op_pix_clk_div},
+			{REG_COARSE_INTEGRATION_TIME_HI,
+				vx6953_regs.reg_pat[rt].
+				coarse_integration_time_hi},
+			{REG_COARSE_INTEGRATION_TIME_LO,
+				vx6953_regs.reg_pat[rt].
+				coarse_integration_time_lo},
+			{REG_ANALOGUE_GAIN_CODE_GLOBAL_LO,
+				vx6953_regs.reg_pat[rt].
+				analogue_gain_code_global},
+			{REG_0x3030,
+				vx6953_regs.reg_pat_init[0].reg_0x3030},
+			/* 953 specific registers */
+			{REG_0x0111,
+				vx6953_regs.reg_pat_init[0].reg_0x0111},
+			{REG_0x0b00,
+				vx6953_regs.reg_pat_init[0].reg_0x0b00},
+			{REG_0x3001,
+				vx6953_regs.reg_pat_init[0].reg_0x3001},
+			{REG_0x3004,
+				vx6953_regs.reg_pat_init[0].reg_0x3004},
+			{REG_0x3007,
+				vx6953_regs.reg_pat_init[0].reg_0x3007},
+			{REG_0x3016,
+				vx6953_regs.reg_pat_init[0].reg_0x3016},
+			{REG_0x301d,
+				vx6953_regs.reg_pat_init[0].reg_0x301d},
+			{REG_0x317e,
+				vx6953_regs.reg_pat_init[0].reg_0x317e},
+			{REG_0x317f,
+				vx6953_regs.reg_pat_init[0].reg_0x317f},
+			{REG_0x3400,
+				vx6953_regs.reg_pat_init[0].reg_0x3400},
+			/* DEFCOR settings */
+			/*Single Defect Correction Weight DISABLE*/
+			{0x0b06,
+				vx6953_regs.reg_pat_init[0].reg_0x0b06},
+			/*Single_defect_correct_weight = auto*/
+			{0x0b07,
+				vx6953_regs.reg_pat_init[0].reg_0x0b07},
+			/*Dynamic couplet correction ENABLED*/
+			{0x0b08,
+				vx6953_regs.reg_pat_init[0].reg_0x0b08},
+			/*Dynamic couplet correction weight*/
+			{0x0b09,
+				vx6953_regs.reg_pat_init[0].reg_0x0b09},
+			/* Clock Setup */
+			/* Tell sensor ext clk is 24MHz*/
+			{0x0136,
+				vx6953_regs.reg_pat_init[0].reg_0x0136},
+			{0x0137,
+				vx6953_regs.reg_pat_init[0].reg_0x0137},
+			/* The white balance gains must be written
+			to the sensor every frame. */
+			/* Edof */
+			{REG_0x0b83,
+				vx6953_regs.reg_pat_init[0].reg_0x0b83},
+			{REG_0x0b84,
+				vx6953_regs.reg_pat_init[0].reg_0x0b84},
+			{0x0b85,
+				vx6953_regs.reg_pat_init[0].reg_0x0b85},
+			{0x0b88,
+				vx6953_regs.reg_pat_init[0].reg_0x0b88},
+			{0x0b89,
+				vx6953_regs.reg_pat_init[0].reg_0x0b89},
+			{REG_0x0b8a,
+				vx6953_regs.reg_pat_init[0].reg_0x0b8a},
+			/* Mode specific regieters */
+			{REG_FRAME_LENGTH_LINES_HI,
+				vx6953_regs.reg_pat[rt].
+				frame_length_lines_hi},
+			{REG_FRAME_LENGTH_LINES_LO,
+				vx6953_regs.reg_pat[rt].
+				frame_length_lines_lo},
+			{REG_LINE_LENGTH_PCK_HI,
+				vx6953_regs.reg_pat[rt].
+				line_length_pck_hi},
+			{REG_LINE_LENGTH_PCK_LO,
+				vx6953_regs.reg_pat[rt].
+				line_length_pck_lo},
+			{REG_0x3005,
+				vx6953_regs.reg_pat[rt].reg_0x3005},
+			{0x3010,
+				vx6953_regs.reg_pat[rt].reg_0x3010},
+			{REG_0x3011,
+				vx6953_regs.reg_pat[rt].reg_0x3011},
+			{REG_0x301a,
+				vx6953_regs.reg_pat[rt].reg_0x301a},
+			{REG_0x3035,
+				vx6953_regs.reg_pat[rt].reg_0x3035},
+			{REG_0x3036,
+				vx6953_regs.reg_pat[rt].reg_0x3036},
+			{REG_0x3041,
+				vx6953_regs.reg_pat[rt].reg_0x3041},
+			{0x3042,
+				vx6953_regs.reg_pat[rt].reg_0x3042},
+			{REG_0x3045,
+				vx6953_regs.reg_pat[rt].reg_0x3045},
+			/*EDOF: Estimation settings for Preview mode
+			Application settings for capture mode
+			(standard settings - Not tuned) */
+			{REG_0x0b80,
+				vx6953_regs.reg_pat[rt].reg_0x0b80},
+			{REG_0x0900,
+				vx6953_regs.reg_pat[rt].reg_0x0900},
+			{REG_0x0901,
+				vx6953_regs.reg_pat[rt].reg_0x0901},
+			{REG_0x0902,
+				vx6953_regs.reg_pat[rt].reg_0x0902},
+			{REG_0x0383,
+				vx6953_regs.reg_pat[rt].reg_0x0383},
+			{REG_0x0387,
+				vx6953_regs.reg_pat[rt].reg_0x0387},
+			/* Change output size / frame rate */
+			{REG_0x034c,
+				vx6953_regs.reg_pat[rt].reg_0x034c},
+			{REG_0x034d,
+				vx6953_regs.reg_pat[rt].reg_0x034d},
+			{REG_0x034e,
+				vx6953_regs.reg_pat[rt].reg_0x034e},
+			{REG_0x034f,
+				vx6953_regs.reg_pat[rt].reg_0x034f},
+			{REG_0x1716,
+				vx6953_regs.reg_pat[rt].reg_0x1716},
+			{REG_0x1717,
+				vx6953_regs.reg_pat[rt].reg_0x1717},
+			{REG_0x1718,
+				vx6953_regs.reg_pat[rt].reg_0x1718},
+			{REG_0x1719,
+				vx6953_regs.reg_pat[rt].reg_0x1719},
+			};
+						/* reset fps_divider */
+			vx6953_ctrl->fps = 30 * Q8;
+			/* stop streaming */
+
+			/* Reset everything first */
+			if (vx6953_i2c_write_b_sensor(0x103, 0x01) < 0) {
+				CDBG("S/W reset failed\n");
+				return rc;
+			} else
+				CDBG("S/W reset successful\n");
+
+			msleep(10);
+
+			CDBG("Init vx6953_sensor_setting standby\n");
+			if (vx6953_i2c_write_b_sensor(REG_MODE_SELECT,
+				MODE_SELECT_STANDBY_MODE) < 0)
+				return rc;
+				/*vx6953_stm5m0edof_delay_msecs_stdby*/
+			msleep(vx6953_stm5m0edof_delay_msecs_stdby);
+			vx6953_patch_for_cut2();
+			rc = vx6953_i2c_write_w_table(&init_tbl[0],
+				ARRAY_SIZE(init_tbl));
+			if (rc < 0)
+				return rc;
+				msleep(vx6953_stm5m0edof_delay_msecs_stdby);
+		}
+	return rc;
+	case UPDATE_PERIODIC:
+		if (rt == RES_PREVIEW || rt == RES_CAPTURE) {
+			struct vx6953_i2c_reg_conf init_mode_tbl[] =  {
+			{REG_0x0112,
+				vx6953_regs.reg_pat_init[0].reg_0x0112},
+			{REG_0x0113,
+				vx6953_regs.reg_pat_init[0].reg_0x0113},
+			{REG_VT_PIX_CLK_DIV,
+				vx6953_regs.reg_pat_init[0].
+				vt_pix_clk_div},
+			{REG_PRE_PLL_CLK_DIV,
+				vx6953_regs.reg_pat_init[0].
+				pre_pll_clk_div},
+			{REG_PLL_MULTIPLIER,
+				vx6953_regs.reg_pat_init[0].
+				pll_multiplier},
+			{REG_OP_PIX_CLK_DIV,
+				vx6953_regs.reg_pat_init[0].
+				op_pix_clk_div},
+			{REG_COARSE_INTEGRATION_TIME_HI,
+				vx6953_regs.reg_pat[rt].
+				coarse_integration_time_hi},
+			{REG_COARSE_INTEGRATION_TIME_LO,
+				vx6953_regs.reg_pat[rt].
+				coarse_integration_time_lo},
+			{REG_ANALOGUE_GAIN_CODE_GLOBAL_LO,
+				vx6953_regs.reg_pat[rt].
+				analogue_gain_code_global},
+			{REG_0x3030,
+				vx6953_regs.reg_pat_init[0].reg_0x3030},
+			/* 953 specific registers */
+			{REG_0x0111,
+				vx6953_regs.reg_pat_init[0].reg_0x0111},
+			{REG_0x0b00,
+				vx6953_regs.reg_pat_init[0].reg_0x0b00},
+			{REG_0x3001,
+				vx6953_regs.reg_pat_init[0].reg_0x3001},
+			{REG_0x3004,
+				vx6953_regs.reg_pat_init[0].reg_0x3004},
+			{REG_0x3007,
+				vx6953_regs.reg_pat_init[0].reg_0x3007},
+			{REG_0x3016,
+				vx6953_regs.reg_pat_init[0].reg_0x3016},
+			{REG_0x301d,
+				vx6953_regs.reg_pat_init[0].reg_0x301d},
+			{REG_0x317e,
+				vx6953_regs.reg_pat_init[0].reg_0x317e},
+			{REG_0x317f,
+				vx6953_regs.reg_pat_init[0].reg_0x317f},
+			{REG_0x3400,
+				vx6953_regs.reg_pat_init[0].reg_0x3400},
+			{0x0b06,
+				vx6953_regs.reg_pat_init[0].reg_0x0b06},
+			/*Single_defect_correct_weight = auto*/
+			{0x0b07,
+				vx6953_regs.reg_pat_init[0].reg_0x0b07},
+			/*Dynamic couplet correction ENABLED*/
+			{0x0b08,
+				vx6953_regs.reg_pat_init[0].reg_0x0b08},
+			/*Dynamic couplet correction weight*/
+			{0x0b09,
+				vx6953_regs.reg_pat_init[0].reg_0x0b09},
+			/* Clock Setup */
+			/* Tell sensor ext clk is 24MHz*/
+			{0x0136,
+				vx6953_regs.reg_pat_init[0].reg_0x0136},
+			{0x0137,
+				vx6953_regs.reg_pat_init[0].reg_0x0137},
+			/* The white balance gains must be written
+			to the sensor every frame. */
+			/* Edof */
+			{REG_0x0b83,
+				vx6953_regs.reg_pat_init[0].reg_0x0b83},
+			{REG_0x0b84,
+				vx6953_regs.reg_pat_init[0].reg_0x0b84},
+			{0x0b85,
+				vx6953_regs.reg_pat_init[0].reg_0x0b85},
+			{0x0b88,
+				vx6953_regs.reg_pat_init[0].reg_0x0b88},
+			{0x0b89,
+				vx6953_regs.reg_pat_init[0].reg_0x0b89},
+			{REG_0x0b8a,
+				vx6953_regs.reg_pat_init[0].reg_0x0b8a},
+			/* Mode specific regieters */
+			{REG_FRAME_LENGTH_LINES_HI,
+				vx6953_regs.reg_pat[rt].
+				frame_length_lines_hi},
+			{REG_FRAME_LENGTH_LINES_LO,
+				vx6953_regs.reg_pat[rt].
+				frame_length_lines_lo},
+			{REG_LINE_LENGTH_PCK_HI,
+				vx6953_regs.reg_pat[rt].
+				line_length_pck_hi},
+			{REG_LINE_LENGTH_PCK_LO,
+				vx6953_regs.reg_pat[rt].
+				line_length_pck_lo},
+			{REG_0x3005,
+				vx6953_regs.reg_pat[rt].reg_0x3005},
+			{0x3010,
+				vx6953_regs.reg_pat[rt].reg_0x3010},
+			{REG_0x3011,
+				vx6953_regs.reg_pat[rt].reg_0x3011},
+			{REG_0x301a,
+				vx6953_regs.reg_pat[rt].reg_0x301a},
+			{REG_0x3035,
+				vx6953_regs.reg_pat[rt].reg_0x3035},
+			{REG_0x3036,
+				vx6953_regs.reg_pat[rt].reg_0x3036},
+			{REG_0x3041,
+				vx6953_regs.reg_pat[rt].reg_0x3041},
+			{0x3042,
+				vx6953_regs.reg_pat[rt].reg_0x3042},
+			{REG_0x3045,
+				vx6953_regs.reg_pat[rt].reg_0x3045},
+			/*EDOF: Estimation settings for Preview mode
+			Application settings for capture mode
+			(standard settings - Not tuned) */
+			{REG_0x0b80,
+				vx6953_regs.reg_pat[rt].reg_0x0b80},
+			{REG_0x0900,
+				vx6953_regs.reg_pat[rt].reg_0x0900},
+			{REG_0x0901,
+				vx6953_regs.reg_pat[rt].reg_0x0901},
+			{REG_0x0902,
+				vx6953_regs.reg_pat[rt].reg_0x0902},
+			{REG_0x0383,
+				vx6953_regs.reg_pat[rt].reg_0x0383},
+			{REG_0x0387,
+				vx6953_regs.reg_pat[rt].reg_0x0387},
+			/* Change output size / frame rate */
+			{REG_0x034c,
+				vx6953_regs.reg_pat[rt].reg_0x034c},
+			{REG_0x034d,
+				vx6953_regs.reg_pat[rt].reg_0x034d},
+			{REG_0x034e,
+				vx6953_regs.reg_pat[rt].reg_0x034e},
+			{REG_0x034f,
+				vx6953_regs.reg_pat[rt].reg_0x034f},
+			{REG_0x1716,
+				vx6953_regs.reg_pat[rt].reg_0x1716},
+			{REG_0x1717,
+				vx6953_regs.reg_pat[rt].reg_0x1717},
+			{REG_0x1718,
+				vx6953_regs.reg_pat[rt].reg_0x1718},
+			{REG_0x1719,
+				vx6953_regs.reg_pat[rt].reg_0x1719},
+			};
+			struct vx6953_i2c_reg_conf mode_tbl[] = {
+			{REG_0x0112,
+				vx6953_regs.reg_pat_init[0].reg_0x0112},
+			{REG_0x0113,
+				vx6953_regs.reg_pat_init[0].reg_0x0113},
+			{REG_VT_PIX_CLK_DIV,
+				vx6953_regs.reg_pat_init[0].
+				vt_pix_clk_div},
+			{REG_PRE_PLL_CLK_DIV,
+				vx6953_regs.reg_pat_init[0].
+				pre_pll_clk_div},
+			{REG_PLL_MULTIPLIER,
+				vx6953_regs.reg_pat_init[0].
+				pll_multiplier},
+			{REG_OP_PIX_CLK_DIV,
+				vx6953_regs.reg_pat_init[0].
+				op_pix_clk_div},
+		/* Mode specific regieters */
+			{REG_FRAME_LENGTH_LINES_HI,
+				vx6953_regs.reg_pat[rt].frame_length_lines_hi},
+			{REG_FRAME_LENGTH_LINES_LO,
+				vx6953_regs.reg_pat[rt].frame_length_lines_lo},
+			{REG_LINE_LENGTH_PCK_HI,
+				vx6953_regs.reg_pat[rt].line_length_pck_hi},
+			{REG_LINE_LENGTH_PCK_LO,
+				vx6953_regs.reg_pat[rt].line_length_pck_lo},
+			{REG_0x3005, vx6953_regs.reg_pat[rt].reg_0x3005},
+			{0x3010, vx6953_regs.reg_pat[rt].reg_0x3010},
+			{REG_0x3011, vx6953_regs.reg_pat[rt].reg_0x3011},
+			{REG_0x301a, vx6953_regs.reg_pat[rt].reg_0x301a},
+			{REG_0x3035, vx6953_regs.reg_pat[rt].reg_0x3035},
+			{REG_0x3036, vx6953_regs.reg_pat[rt].reg_0x3036},
+			{REG_0x3041, vx6953_regs.reg_pat[rt].reg_0x3041},
+			{0x3042, vx6953_regs.reg_pat[rt].reg_0x3042},
+			{REG_0x3045, vx6953_regs.reg_pat[rt].reg_0x3045},
+			/*EDOF: Estimation settings for Preview mode
+			Application settings for capture
+			mode(standard settings - Not tuned) */
+			{REG_0x0b80, vx6953_regs.reg_pat[rt].reg_0x0b80},
+			{REG_0x0900, vx6953_regs.reg_pat[rt].reg_0x0900},
+			{REG_0x0901, vx6953_regs.reg_pat[rt].reg_0x0901},
+			{REG_0x0902, vx6953_regs.reg_pat[rt].reg_0x0902},
+			{REG_0x0383, vx6953_regs.reg_pat[rt].reg_0x0383},
+			{REG_0x0387, vx6953_regs.reg_pat[rt].reg_0x0387},
+			/* Change output size / frame rate */
+			{REG_0x034c, vx6953_regs.reg_pat[rt].reg_0x034c},
+			{REG_0x034d, vx6953_regs.reg_pat[rt].reg_0x034d},
+			{REG_0x034e, vx6953_regs.reg_pat[rt].reg_0x034e},
+			{REG_0x034f, vx6953_regs.reg_pat[rt].reg_0x034f},
+			/*{0x200, vx6953_regs.reg_pat[rt].reg_0x0200},
+			{0x201, vx6953_regs.reg_pat[rt].reg_0x0201},*/
+			{REG_0x1716, vx6953_regs.reg_pat[rt].reg_0x1716},
+			{REG_0x1717, vx6953_regs.reg_pat[rt].reg_0x1717},
+			{REG_0x1718, vx6953_regs.reg_pat[rt].reg_0x1718},
+			{REG_0x1719, vx6953_regs.reg_pat[rt].reg_0x1719},
+			};
+			/* stop streaming */
+			msleep(5);
+
+			/* Reset everything first */
+			if (vx6953_i2c_write_b_sensor(0x103, 0x01) < 0) {
+				CDBG("S/W reset failed\n");
+				return rc;
+			} else
+				CDBG("S/W reset successful\n");
+
+			msleep(10);
+
+			if (vx6953_i2c_write_b_sensor(REG_MODE_SELECT,
+				MODE_SELECT_STANDBY_MODE) < 0)
+				return rc;
+			/*vx6953_stm5m0edof_delay_msecs_stdby*/
+			msleep(vx6953_stm5m0edof_delay_msecs_stdby);
+
+
+			vx6953_csi_params.data_format = CSI_8BIT;
+			vx6953_csi_params.lane_cnt = 1;
+			vx6953_csi_params.lane_assign = 0xe4;
+			vx6953_csi_params.dpcm_scheme = 0;
+			vx6953_csi_params.settle_cnt = 7;
+			rc = msm_camio_csi_config(&vx6953_csi_params);
+			if (rc < 0)
+				return rc;
+
+			msleep(vx6953_stm5m0edof_delay_msecs_stdby);
+
+			vx6953_patch_for_cut2();
+			rc = vx6953_i2c_write_w_table(&init_mode_tbl[0],
+				ARRAY_SIZE(init_mode_tbl));
+			if (rc < 0)
+				return rc;
+
+			msleep(vx6953_stm5m0edof_delay_msecs_stdby);
+
+			rc = vx6953_i2c_write_w_table(&mode_tbl[0],
+				ARRAY_SIZE(mode_tbl));
+			if (rc < 0)
+				return rc;
+
+			msleep(vx6953_stm5m0edof_delay_msecs_stdby);
+
+			/* Start sensor streaming */
+			if (vx6953_i2c_write_b_sensor(REG_MODE_SELECT,
+				MODE_SELECT_STREAM) < 0)
+				return rc;
+			msleep(vx6953_stm5m0edof_delay_msecs_stream);
+
+			if (vx6953_i2c_read(0x0005, &frame_cnt, 1) < 0)
+				return rc;
+
+			while (frame_cnt == 0xFF) {
+				if (vx6953_i2c_read(0x0005, &frame_cnt, 1) < 0)
+					return rc;
+				CDBG("frame_cnt=%d", frame_cnt);
+				msleep(10);
+			}
+		}
+		return rc;
+	default:
+		return rc;
+	}
+	}
+	return rc;
+}
+
+
+static int32_t vx6953_video_config(int mode)
+{
+
+	int32_t	rc = 0;
+	int	rt;
+	/* change sensor resolution	if needed */
+	if (vx6953_ctrl->curr_res != vx6953_ctrl->prev_res) {
+		if (vx6953_ctrl->prev_res == QTR_SIZE) {
+			rt = RES_PREVIEW;
+			vx6953_stm5m0edof_delay_msecs_stdby	=
+				((((2 * 1000 * vx6953_ctrl->fps_divider) /
+				   vx6953_ctrl->fps) * Q8) / Q10) + 1;
+		} else {
+			rt = RES_CAPTURE;
+			vx6953_stm5m0edof_delay_msecs_stdby	=
+				((((1000 * vx6953_ctrl->fps_divider) /
+				   vx6953_ctrl->fps) * Q8) / Q10) + 1;
+		}
+		if (vx6953_sensor_setting(UPDATE_PERIODIC, rt) < 0)
+			return rc;
+	}
+	if (vx6953_ctrl->set_test) {
+		if (vx6953_test(vx6953_ctrl->set_test) < 0)
+			return	rc;
+	}
+	vx6953_ctrl->edof_mode = VX6953_EDOF_ESTIMATION;
+	rc = vx6953_enable_edof(vx6953_ctrl->edof_mode);
+	if (rc < 0)
+		return rc;
+	vx6953_ctrl->curr_res = vx6953_ctrl->prev_res;
+	vx6953_ctrl->sensormode = mode;
+	return rc;
+}
+
+static int32_t vx6953_snapshot_config(int mode)
+{
+	int32_t rc = 0;
+	int rt;
+	/*change sensor resolution if needed */
+	if (vx6953_ctrl->curr_res != vx6953_ctrl->pict_res) {
+		if (vx6953_ctrl->pict_res == QTR_SIZE) {
+			rt = RES_PREVIEW;
+			vx6953_stm5m0edof_delay_msecs_stdby =
+				((((2 * 1000 * vx6953_ctrl->fps_divider) /
+				vx6953_ctrl->fps) * Q8) / Q10) + 1;
+		} else {
+			rt = RES_CAPTURE;
+			vx6953_stm5m0edof_delay_msecs_stdby =
+				((((1000 * vx6953_ctrl->fps_divider) /
+				vx6953_ctrl->fps) * Q8) / Q10) + 1;
+		}
+	if (vx6953_sensor_setting(UPDATE_PERIODIC, rt) < 0)
+		return rc;
+	}
+
+	vx6953_ctrl->edof_mode = VX6953_EDOF_APPLICATION;
+	if (vx6953_enable_edof(vx6953_ctrl->edof_mode) < 0)
+		return rc;
+	vx6953_ctrl->curr_res = vx6953_ctrl->pict_res;
+	vx6953_ctrl->sensormode = mode;
+	return rc;
+} /*end of vx6953_snapshot_config*/
+
+static int32_t vx6953_raw_snapshot_config(int mode)
+{
+	int32_t rc = 0;
+	int rt;
+	/* change sensor resolution if needed */
+	if (vx6953_ctrl->curr_res != vx6953_ctrl->pict_res) {
+		if (vx6953_ctrl->pict_res == QTR_SIZE) {
+			rt = RES_PREVIEW;
+			vx6953_stm5m0edof_delay_msecs_stdby =
+				((((2 * 1000 * vx6953_ctrl->fps_divider)/
+				vx6953_ctrl->fps) * Q8) / Q10) + 1;
+		} else {
+			rt = RES_CAPTURE;
+			vx6953_stm5m0edof_delay_msecs_stdby =
+				((((1000 * vx6953_ctrl->fps_divider)/
+				vx6953_ctrl->fps) * Q8) / Q10) + 1;
+		}
+		if (vx6953_sensor_setting(UPDATE_PERIODIC, rt) < 0)
+			return rc;
+	}
+	vx6953_ctrl->edof_mode = VX6953_EDOF_APPLICATION;
+	if (vx6953_enable_edof(vx6953_ctrl->edof_mode) < 0)
+		return rc;
+	vx6953_ctrl->curr_res = vx6953_ctrl->pict_res;
+	vx6953_ctrl->sensormode = mode;
+	return rc;
+} /*end of vx6953_raw_snapshot_config*/
+static int32_t vx6953_set_sensor_mode(int mode,
+	int res)
+{
+	int32_t rc = 0;
+	switch (res) {
+	case MSM_SENSOR_RES_QTR:
+		rc = vx6953_video_config(mode);
+		break;
+	case MSM_SENSOR_RES_FULL:
+		rc = vx6953_snapshot_config(mode);
+		break;
+		rc = vx6953_raw_snapshot_config(mode);
+		break;
+	default:
+		rc = -EINVAL;
+		break;
+	}
+	return rc;
+}
+static int32_t vx6953_power_down(void)
+{
+	return 0;
+}
+
+
+static int vx6953_probe_init_done(const struct msm_camera_sensor_info *data)
+{
+	gpio_set_value_cansleep(data->sensor_reset, 0);
+	gpio_free(data->sensor_reset);
+	return 0;
+}
+static int vx6953_probe_init_sensor(const struct msm_camera_sensor_info *data)
+{
+	int32_t rc = 0;
+	unsigned short chipidl, chipidh;
+	CDBG("%s: %d\n", __func__, __LINE__);
+	rc = gpio_request(data->sensor_reset, "vx6953");
+	CDBG(" vx6953_probe_init_sensor \n");
+	if (!rc) {
+		CDBG("sensor_reset = %d\n", rc);
+		CDBG(" vx6953_probe_init_sensor 1\n");
+		gpio_direction_output(data->sensor_reset, 0);
+		msleep(10);
+		CDBG(" vx6953_probe_init_sensor 1\n");
+		gpio_set_value_cansleep(data->sensor_reset, 1);
+	} else {
+		CDBG(" vx6953_probe_init_sensor 2\n");
+		goto init_probe_done;
+	}
+	msleep(20);
+	CDBG(" vx6953_probe_init_sensor is called\n");
+	/* 3. Read sensor Model ID: */
+	rc = vx6953_i2c_read(0x0000, &chipidh, 1);
+	if (rc < 0) {
+		CDBG(" vx6953_probe_init_sensor 3\n");
+		goto init_probe_fail;
+	}
+	rc = vx6953_i2c_read(0x0001, &chipidl, 1);
+	if (rc < 0) {
+		CDBG(" vx6953_probe_init_sensor4\n");
+		goto init_probe_fail;
+	}
+	CDBG("vx6953 model_id = 0x%x  0x%x\n", chipidh, chipidl);
+	/* 4. Compare sensor ID to VX6953 ID: */
+	if (chipidh != 0x03 || chipidl != 0xB9) {
+		rc = -ENODEV;
+		CDBG("vx6953_probe_init_sensor fail chip id doesnot match\n");
+		goto init_probe_fail;
+	}
+	goto init_probe_done;
+init_probe_fail:
+	CDBG(" vx6953_probe_init_sensor fails\n");
+	vx6953_probe_init_done(data);
+init_probe_done:
+	CDBG(" vx6953_probe_init_sensor finishes\n");
+	return rc;
+	}
+/* camsensor_iu060f_vx6953_reset */
+int vx6953_sensor_open_init(const struct msm_camera_sensor_info *data)
+{
+	unsigned short revision_number;
+	int32_t rc = 0;
+
+	CDBG("%s: %d\n", __func__, __LINE__);
+	CDBG("Calling vx6953_sensor_open_init\n");
+	vx6953_ctrl = kzalloc(sizeof(struct vx6953_ctrl_t), GFP_KERNEL);
+	if (!vx6953_ctrl) {
+		CDBG("vx6953_init failed!\n");
+		rc = -ENOMEM;
+		goto init_done;
+	}
+	vx6953_ctrl->fps_divider = 1 * 0x00000400;
+	vx6953_ctrl->pict_fps_divider = 1 * 0x00000400;
+	vx6953_ctrl->set_test = TEST_OFF;
+	vx6953_ctrl->prev_res = QTR_SIZE;
+	vx6953_ctrl->pict_res = FULL_SIZE;
+	vx6953_ctrl->curr_res = INVALID_SIZE;
+	vx6953_ctrl->sensor_type = VX6953_STM5M0EDOF_CUT_2;
+	vx6953_ctrl->edof_mode = VX6953_EDOF_ESTIMATION;
+	if (data)
+		vx6953_ctrl->sensordata = data;
+	if (rc < 0) {
+		CDBG("Calling vx6953_sensor_open_init fail1\n");
+		return rc;
+	}
+	CDBG("%s: %d\n", __func__, __LINE__);
+	/* enable mclk first */
+	msm_camio_clk_rate_set(VX6953_STM5M0EDOF_DEFAULT_MASTER_CLK_RATE);
+	CDBG("%s: %d\n", __func__, __LINE__);
+	rc = vx6953_probe_init_sensor(data);
+	if (rc < 0) {
+		CDBG("Calling vx6953_sensor_open_init fail3\n");
+		goto init_fail;
+	}
+	if (vx6953_i2c_read(0x0002, &revision_number, 1) < 0)
+		return rc;
+		CDBG("sensor revision number major = 0x%x\n", revision_number);
+	if (vx6953_i2c_read(0x0018, &revision_number, 1) < 0)
+		return rc;
+		CDBG("sensor revision number = 0x%x\n", revision_number);
+	if (revision_number == VX6953_REVISION_NUMBER_CUT3) {
+		vx6953_ctrl->sensor_type = VX6953_STM5M0EDOF_CUT_3;
+		CDBG("VX6953 EDof Cut 3.0 sensor\n ");
+	} else if (revision_number == VX6953_REVISION_NUMBER_CUT2) {
+		vx6953_ctrl->sensor_type = VX6953_STM5M0EDOF_CUT_2;
+		CDBG("VX6953 EDof Cut 2.0 sensor\n ");
+	} else {/* Cut1.0 reads 0x00 for register 0x0018*/
+		vx6953_ctrl->sensor_type = VX6953_STM5M0EDOF_CUT_1;
+		CDBG("VX6953 EDof Cut 1.0 sensor\n ");
+	}
+	if (vx6953_ctrl->prev_res == QTR_SIZE) {
+		if (vx6953_sensor_setting(REG_INIT, RES_PREVIEW) < 0)
+			return rc;
+	} else {
+		if (vx6953_sensor_setting(REG_INIT, RES_CAPTURE) < 0)
+			return rc;
+	}
+	vx6953_ctrl->fps = 30*Q8;
+	if (rc < 0)
+		goto init_fail;
+	else
+		goto init_done;
+init_fail:
+	CDBG("init_fail\n");
+	vx6953_probe_init_done(data);
+	kfree(vx6953_ctrl);
+init_done:
+	CDBG("init_done\n");
+	return rc;
+} /*endof vx6953_sensor_open_init*/
+
+static int vx6953_init_client(struct i2c_client *client)
+{
+	/* Initialize the MSM_CAMI2C Chip */
+	init_waitqueue_head(&vx6953_wait_queue);
+	return 0;
+}
+
+static const struct i2c_device_id vx6953_i2c_id[] = {
+	{"vx6953", 0},
+	{ }
+};
+
+static int vx6953_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	int rc = 0;
+	CDBG("vx6953_probe called!\n");
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		CDBG("i2c_check_functionality failed\n");
+		goto probe_failure;
+	}
+
+	vx6953_sensorw = kzalloc(sizeof(struct vx6953_work_t), GFP_KERNEL);
+	if (!vx6953_sensorw) {
+		CDBG("kzalloc failed.\n");
+		rc = -ENOMEM;
+		goto probe_failure;
+	}
+
+	i2c_set_clientdata(client, vx6953_sensorw);
+	vx6953_init_client(client);
+	vx6953_client = client;
+
+	msleep(50);
+
+	CDBG("vx6953_probe successed! rc = %d\n", rc);
+	return 0;
+
+probe_failure:
+	CDBG("vx6953_probe failed! rc = %d\n", rc);
+	return rc;
+}
+
+static int vx6953_send_wb_info(struct wb_info_cfg *wb)
+{
+	unsigned short read_data;
+	uint8_t temp[8];
+	int rc = 0;
+	int i = 0;
+
+	/* red_gain */
+	temp[2] = wb->red_gain >> 8;
+	temp[3] = wb->red_gain & 0xFF;
+
+	/* green_gain */
+	temp[0] = wb->green_gain >> 8;
+	temp[1] = wb->green_gain & 0xFF;
+	temp[6] = temp[0];
+	temp[7] = temp[1];
+
+	/* blue_gain */
+	temp[4] = wb->blue_gain >> 8;
+	temp[5] = wb->blue_gain & 0xFF;
+	rc = vx6953_i2c_write_seq_sensor(0x0B8E, &temp[0], 8);
+
+	for (i = 0; i < 6; i++) {
+		rc = vx6953_i2c_read(0x0B8E + i, &read_data, 1);
+		CDBG("%s addr 0x%x val %d \n", __func__, 0x0B8E + i, read_data);
+	}
+	rc = vx6953_i2c_read(0x0B82, &read_data, 1);
+	CDBG("%s addr 0x%x val %d \n", __func__, 0x0B82, read_data);
+	if (rc < 0)
+		return rc;
+	return rc;
+} /*end of vx6953_snapshot_config*/
+
+static int __exit vx6953_remove(struct i2c_client *client)
+{
+	struct vx6953_work_t_t *sensorw = i2c_get_clientdata(client);
+	free_irq(client->irq, sensorw);
+	vx6953_client = NULL;
+	kfree(sensorw);
+	return 0;
+}
+
+static struct i2c_driver vx6953_i2c_driver = {
+	.id_table = vx6953_i2c_id,
+	.probe  = vx6953_i2c_probe,
+	.remove = __exit_p(vx6953_i2c_remove),
+	.driver = {
+		.name = "vx6953",
+	},
+};
+
+int vx6953_sensor_config(void __user *argp)
+{
+	struct sensor_cfg_data cdata;
+	long   rc = 0;
+	if (copy_from_user(&cdata,
+		(void *)argp,
+		sizeof(struct sensor_cfg_data)))
+		return -EFAULT;
+	mutex_lock(&vx6953_mut);
+	CDBG("vx6953_sensor_config: cfgtype = %d\n",
+	cdata.cfgtype);
+		switch (cdata.cfgtype) {
+		case CFG_GET_PICT_FPS:
+			vx6953_get_pict_fps(
+				cdata.cfg.gfps.prevfps,
+				&(cdata.cfg.gfps.pictfps));
+
+			if (copy_to_user((void *)argp,
+				&cdata,
+				sizeof(struct sensor_cfg_data)))
+				rc = -EFAULT;
+			break;
+
+		case CFG_GET_PREV_L_PF:
+			cdata.cfg.prevl_pf =
+			vx6953_get_prev_lines_pf();
+
+			if (copy_to_user((void *)argp,
+				&cdata,
+				sizeof(struct sensor_cfg_data)))
+				rc = -EFAULT;
+			break;
+
+		case CFG_GET_PREV_P_PL:
+			cdata.cfg.prevp_pl =
+				vx6953_get_prev_pixels_pl();
+
+			if (copy_to_user((void *)argp,
+				&cdata,
+				sizeof(struct sensor_cfg_data)))
+				rc = -EFAULT;
+			break;
+
+		case CFG_GET_PICT_L_PF:
+			cdata.cfg.pictl_pf =
+				vx6953_get_pict_lines_pf();
+
+			if (copy_to_user((void *)argp,
+				&cdata,
+				sizeof(struct sensor_cfg_data)))
+				rc = -EFAULT;
+			break;
+
+		case CFG_GET_PICT_P_PL:
+			cdata.cfg.pictp_pl =
+				vx6953_get_pict_pixels_pl();
+
+			if (copy_to_user((void *)argp,
+				&cdata,
+				sizeof(struct sensor_cfg_data)))
+				rc = -EFAULT;
+			break;
+
+		case CFG_GET_PICT_MAX_EXP_LC:
+			cdata.cfg.pict_max_exp_lc =
+				vx6953_get_pict_max_exp_lc();
+
+			if (copy_to_user((void *)argp,
+				&cdata,
+				sizeof(struct sensor_cfg_data)))
+				rc = -EFAULT;
+			break;
+
+		case CFG_SET_FPS:
+		case CFG_SET_PICT_FPS:
+			rc = vx6953_set_fps(&(cdata.cfg.fps));
+			break;
+
+		case CFG_SET_EXP_GAIN:
+			rc =
+				vx6953_write_exp_gain(
+					cdata.cfg.exp_gain.gain,
+					cdata.cfg.exp_gain.line);
+			break;
+
+		case CFG_SET_PICT_EXP_GAIN:
+			rc =
+				vx6953_set_pict_exp_gain(
+				cdata.cfg.exp_gain.gain,
+				cdata.cfg.exp_gain.line);
+			break;
+
+		case CFG_SET_MODE:
+			rc = vx6953_set_sensor_mode(cdata.mode,
+					cdata.rs);
+			break;
+
+		case CFG_PWR_DOWN:
+			rc = vx6953_power_down();
+			break;
+
+		case CFG_MOVE_FOCUS:
+			rc =
+				vx6953_move_focus(
+				cdata.cfg.focus.dir,
+				cdata.cfg.focus.steps);
+			break;
+
+		case CFG_SET_DEFAULT_FOCUS:
+			rc =
+				vx6953_set_default_focus(
+				cdata.cfg.focus.steps);
+			break;
+
+		case CFG_SET_EFFECT:
+			rc = vx6953_set_default_focus(
+				cdata.cfg.effect);
+			break;
+
+
+		case CFG_SEND_WB_INFO:
+			rc = vx6953_send_wb_info(
+				&(cdata.cfg.wb_info));
+			break;
+
+		default:
+			rc = -EFAULT;
+			break;
+		}
+
+	mutex_unlock(&vx6953_mut);
+
+	return rc;
+}
+
+
+
+
+static int vx6953_sensor_release(void)
+{
+	int rc = -EBADF;
+	mutex_lock(&vx6953_mut);
+	vx6953_power_down();
+	gpio_direction_output(vx6953_ctrl->sensordata->sensor_reset, 0);
+	gpio_free(vx6953_ctrl->sensordata->sensor_reset);
+	kfree(vx6953_ctrl);
+	vx6953_ctrl = NULL;
+	CDBG("vx6953_release completed\n");
+	mutex_unlock(&vx6953_mut);
+
+	return rc;
+}
+
+static int vx6953_sensor_probe(const struct msm_camera_sensor_info *info,
+		struct msm_sensor_ctrl *s)
+{
+	int rc = 0;
+	rc = i2c_add_driver(&vx6953_i2c_driver);
+	if (rc < 0 || vx6953_client == NULL) {
+		rc = -ENOTSUPP;
+		goto probe_fail;
+	}
+	msm_camio_clk_rate_set(24000000);
+	rc = vx6953_probe_init_sensor(info);
+	if (rc < 0)
+		goto probe_fail;
+	s->s_init = vx6953_sensor_open_init;
+	s->s_release = vx6953_sensor_release;
+	s->s_config  = vx6953_sensor_config;
+	s->s_mount_angle  = info->sensor_platform_info->mount_angle;
+	vx6953_probe_init_done(info);
+	return rc;
+
+probe_fail:
+	CDBG("vx6953_sensor_probe: SENSOR PROBE FAILS!\n");
+	return rc;
+}
+
+struct vx6953_v4l2_subdev_info {
+	enum v4l2_mbus_pixelcode code;
+	enum v4l2_colorspace colorspace;
+	uint16_t fmt;
+	uint16_t order;
+};
+
+static struct vx6953_v4l2_subdev_info vx6953_subdev_info[] = {
+	{
+	.code   = V4L2_MBUS_FMT_SBGGR10_1X10,
+	.colorspace = V4L2_COLORSPACE_JPEG,
+	.fmt    = 1,
+	.order    = 0,
+	},
+	/* more can be supported, to be added later */
+};
+
+static int32_t vx6953_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
+			   enum v4l2_mbus_pixelcode *code)
+{
+	if ((unsigned int)index >= ARRAY_SIZE(vx6953_subdev_info))
+		return -EINVAL;
+
+	*code = vx6953_subdev_info[index].code;
+	return 0;
+}
+
+static struct v4l2_subdev_core_ops vx6953_subdev_core_ops;
+static struct v4l2_subdev_video_ops vx6953_subdev_video_ops = {
+	.enum_mbus_fmt = vx6953_enum_fmt,
+};
+
+static struct v4l2_subdev_ops vx6953_subdev_ops = {
+	.core = &vx6953_subdev_core_ops,
+	.video  = &vx6953_subdev_video_ops,
+};
+
+static int vx6953_v4l2_probe(const struct msm_camera_sensor_info *info,
+	struct v4l2_subdev *sdev, struct msm_sensor_ctrl *s)
+{
+	int32_t rc = 0;
+	rc = vx6953_sensor_probe(info, s);
+	if (rc < 0)
+		return rc;
+	vx6953_sdev = sdev;
+	v4l2_i2c_subdev_init(vx6953_sdev,
+		vx6953_client,
+		&vx6953_subdev_ops);
+	return rc;
+}
+
+static int __vx6953_probe(struct platform_device *pdev)
+{
+	return msm_sensor_register(pdev, vx6953_v4l2_probe);
+}
+
+static struct platform_driver msm_camera_driver = {
+	.probe = __vx6953_probe,
+	.driver = {
+		.name = "msm_camera_vx6953",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init vx6953_init(void)
+{
+	return platform_driver_register(&msm_camera_driver);
+}
+
+module_init(vx6953_init);
+void vx6953_exit(void)
+{
+	i2c_del_driver(&vx6953_i2c_driver);
+}
+
+
diff --git a/drivers/media/video/msm/sensors/vx6953.h b/drivers/media/video/msm/sensors/vx6953.h
new file mode 100644
index 0000000..0e12063
--- /dev/null
+++ b/drivers/media/video/msm/sensors/vx6953.h
@@ -0,0 +1,136 @@
+/* Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef VX6953_H
+#define VX6953_H
+#include <linux/types.h>
+#include <mach/board.h>
+extern struct vx6953_reg vx6953_regs;
+struct reg_struct_init {
+	uint8_t reg_0x0112;      /* 0x0112*/
+	uint8_t reg_0x0113;      /* 0x0113*/
+	uint8_t vt_pix_clk_div;  /* 0x0301*/
+	uint8_t pre_pll_clk_div; /* 0x0305*/
+	uint8_t pll_multiplier;  /* 0x0307*/
+	uint8_t op_pix_clk_div;  /* 0x0309*/
+	uint8_t reg_0x3030;      /*0x3030*/
+	uint8_t reg_0x0111;      /*0x0111*/
+	uint8_t reg_0x0b00;      /*0x0b00*/
+	uint8_t reg_0x3001;      /*0x3001*/
+	uint8_t reg_0x3004;      /*0x3004*/
+	uint8_t reg_0x3007;      /*0x3007*/
+	uint8_t reg_0x3016;      /*0x3016*/
+	uint8_t reg_0x301d;      /*0x301d*/
+	uint8_t reg_0x317e;      /*0x317E*/
+	uint8_t reg_0x317f;      /*0x317F*/
+	uint8_t reg_0x3400;      /*0x3400*/
+	uint8_t reg_0x0b06;      /*0x0b06*/
+	uint8_t reg_0x0b07;      /*0x0b07*/
+	uint8_t reg_0x0b08;      /*0x0b08*/
+	uint8_t reg_0x0b09;      /*0x0b09*/
+	uint8_t reg_0x0136;
+	uint8_t reg_0x0137;
+	/* Edof */
+	uint8_t reg_0x0b83;      /*0x0b83*/
+	uint8_t reg_0x0b84;      /*0x0b84*/
+	uint8_t reg_0x0b85;      /*0x0b85*/
+	uint8_t reg_0x0b88;      /*0x0b88*/
+	uint8_t reg_0x0b89;      /*0x0b89*/
+	uint8_t reg_0x0b8a;      /*0x0b8a*/
+	};
+struct reg_struct {
+	uint8_t coarse_integration_time_hi; /*REG_COARSE_INTEGRATION_TIME_HI*/
+	uint8_t coarse_integration_time_lo; /*REG_COARSE_INTEGRATION_TIME_LO*/
+	uint8_t analogue_gain_code_global;
+	uint8_t frame_length_lines_hi; /* 0x0340*/
+	uint8_t frame_length_lines_lo; /* 0x0341*/
+	uint8_t line_length_pck_hi;    /* 0x0342*/
+	uint8_t line_length_pck_lo;    /* 0x0343*/
+	uint8_t reg_0x3005;   /* 0x3005*/
+	uint8_t reg_0x3010;  /* 0x3010*/
+	uint8_t reg_0x3011;  /* 0x3011*/
+	uint8_t reg_0x301a;  /* 0x301a*/
+	uint8_t reg_0x3035;  /* 0x3035*/
+	uint8_t reg_0x3036;   /* 0x3036*/
+	uint8_t reg_0x3041;  /*0x3041*/
+	uint8_t reg_0x3042;  /*0x3042*/
+	uint8_t reg_0x3045;  /*0x3045*/
+	uint8_t reg_0x0b80;   /* 0x0b80*/
+	uint8_t reg_0x0900;   /*0x0900*/
+	uint8_t reg_0x0901;   /* 0x0901*/
+	uint8_t reg_0x0902;   /*0x0902*/
+	uint8_t reg_0x0383;   /*0x0383*/
+	uint8_t reg_0x0387;   /* 0x0387*/
+	uint8_t reg_0x034c;   /* 0x034c*/
+	uint8_t reg_0x034d;   /*0x034d*/
+	uint8_t reg_0x034e;   /* 0x034e*/
+	uint8_t reg_0x034f;   /* 0x034f*/
+	uint8_t reg_0x1716; /*0x1716*/
+	uint8_t reg_0x1717; /*0x1717*/
+	uint8_t reg_0x1718; /*0x1718*/
+	uint8_t reg_0x1719; /*0x1719*/
+	uint8_t reg_0x3210;/*0x3210*/
+	uint8_t reg_0x111; /*0x111*/
+	uint8_t reg_0x3410;  /*0x3410*/
+	uint8_t reg_0x3098;
+	uint8_t reg_0x309D;
+	uint8_t reg_0x0200;
+	uint8_t reg_0x0201;
+	};
+struct vx6953_i2c_reg_conf {
+	unsigned short waddr;
+	unsigned short wdata;
+};
+
+enum vx6953_test_mode_t {
+	TEST_OFF,
+	TEST_1,
+	TEST_2,
+	TEST_3
+};
+
+enum vx6953_resolution_t {
+	QTR_SIZE,
+	FULL_SIZE,
+	INVALID_SIZE
+};
+enum vx6953_setting {
+	RES_PREVIEW,
+	RES_CAPTURE
+};
+enum mt9p012_reg_update {
+	/* Sensor egisters that need to be updated during initialization */
+	REG_INIT,
+	/* Sensor egisters that needs periodic I2C writes */
+	UPDATE_PERIODIC,
+	/* All the sensor Registers will be updated */
+	UPDATE_ALL,
+	/* Not valid update */
+	UPDATE_INVALID
+};
+
+enum sensor_revision_t {
+	VX6953_STM5M0EDOF_CUT_1,
+	VX6953_STM5M0EDOF_CUT_2,
+	VX6953_STM5M0EDOF_CUT_3
+};
+enum edof_mode_t {
+	VX6953_EDOF_DISABLE,       /* 0x00 */
+	VX6953_EDOF_APPLICATION,   /* 0x01 */
+	VX6953_EDOF_ESTIMATION     /* 0x02 */
+};
+struct vx6953_reg {
+	const struct reg_struct_init  *reg_pat_init;
+	const struct reg_struct  *reg_pat;
+};
+#endif /* VX6953_H */
diff --git a/drivers/media/video/msm/sensors/vx6953_reg.c b/drivers/media/video/msm/sensors/vx6953_reg.c
new file mode 100644
index 0000000..48fc71f
--- /dev/null
+++ b/drivers/media/video/msm/sensors/vx6953_reg.c
@@ -0,0 +1,135 @@
+/* Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+
+#include "vx6953.h"
+const struct reg_struct_init vx6953_reg_init[1] = {
+	{
+		10,			/*REG = 0x0112 , 10 bit */
+		10,			/*REG = 0x0113*/
+		9,			/*REG = 0x0301 vt_pix_clk_div*/
+		4,		/*REG = 0x0305 pre_pll_clk_div*/
+		133,		/*REG = 0x0307 pll_multiplier*/
+		10,		/*REG = 0x0309 op_pix_clk_div*/
+		0x08,		/*REG = 0x3030*/
+		0x02,		/*REG = 0x0111*/
+		0x01,		/*REG = 0x0b00 ,lens shading off */
+		0x30,		/*REG = 0x3001*/
+		0x33,		/*REG = 0x3004*/
+		0x09,		/*REG = 0x3007*/
+		0x1F,		/*REG = 0x3016*/
+		0x03,		/*REG = 0x301d*/
+		0x11,		/*REG = 0x317E*/
+		0x09,		/*REG = 0x317F*/
+		0x38,		/*REG = 0x3400*/
+		0x00,		/*REG_0x0b06*/
+		0x80,		/*REG_0x0b07*/
+		0x01,		/*REG_0x0b08*/
+		0x4F,		/*REG_0x0b09*/
+		0x18,		/*REG_0x0136*/
+		0x00,		/*/REG_0x0137*/
+		0x20,		/*REG = 0x0b83*/
+		0x90,		/*REG = 0x0b84*/
+		0x20,		/*REG = 0x0b85*/
+		0x80,		/*REG = 0x0b88*/
+		0x00,		/*REG = 0x0b89*/
+		0x00,		/*REG = 0x0b8a*/
+	}
+};
+const struct reg_struct vx6953_reg_pat[2] = {
+	{/* Preview */
+		0x03,	/*REG = 0x0202 coarse integration_time_hi*/
+		0xd0,	/*REG = 0x0203 coarse_integration_time_lo*/
+		0xc0,	/*REG = 0x0205 analogue_gain_code_global*/
+		0x03,	/*REG = 0x0340 frame_length_lines_hi*/
+		0xf0,	/*REG = 0x0341 frame_length_lines_lo*/
+		0x0b,	/*REG = 0x0342  line_length_pck_hi*/
+		0x74,	/*REG = 0x0343  line_length_pck_lo*/
+		0x03,	/*REG = 0x3005*/
+		0x00,	/*REG = 0x3010*/
+		0x01,	/*REG = 0x3011*/
+		0x6a,	/*REG = 0x301a*/
+		0x03,	/*REG = 0x3035*/
+		0x2c,	/*REG = 0x3036*/
+		0x00,	/*REG = 0x3041*/
+		0x24,	/*REG = 0x3042*/
+		0x81,	/*REG = 0x3045*/
+		0x02,	/*REG = 0x0b80 edof estimate*/
+		0x01,	/*REG = 0x0900*/
+		0x22,	/*REG = 0x0901*/
+		0x04,	/*REG = 0x0902*/
+		0x03,	/*REG = 0x0383*/
+		0x03,	/*REG = 0x0387*/
+		0x05,	/*REG = 0x034c*/
+		0x18,	/*REG = 0x034d*/
+		0x03,	/*REG = 0x034e*/
+		0xd4,	/*REG = 0x034f*/
+		0x02,	/*0x1716*/
+		0x04,	/*0x1717*/
+		0x08,	/*0x1718*/
+		0x2c,	/*0x1719*/
+		0x01,   /*0x3210*/
+		0x02,   /*0x111*/
+		0x01,   /*0x3410*/
+		0x01,   /*0x3098*/
+		0x05,   /*0x309D*/
+		0x02,
+		0x04,
+	},
+	{ /* Snapshot */
+		0x07,/*REG = 0x0202 coarse_integration_time_hi*/
+		0x00,/*REG = 0x0203 coarse_integration_time_lo*/
+		0xc0,/*REG = 0x0205 analogue_gain_code_global*/
+		0x07,/*REG = 0x0340 frame_length_lines_hi*/
+		0xd0,/*REG = 0x0341 frame_length_lines_lo*/
+		0x0b,/*REG = 0x0342 line_length_pck_hi*/
+		0x8c,/*REG = 0x0343 line_length_pck_lo*/
+		0x01,/*REG = 0x3005*/
+		0x00,/*REG = 0x3010*/
+		0x00,/*REG = 0x3011*/
+		0x55,/*REG = 0x301a*/
+		0x01,/*REG = 0x3035*/
+		0x23,/*REG = 0x3036*/
+		0x00,/*REG = 0x3041*/
+		0x24,/*REG = 0x3042*/
+		0xb7,/*REG = 0x3045*/
+		0x01,/*REG = 0x0b80 edof application*/
+		0x00,/*REG = 0x0900*/
+		0x00,/*REG = 0x0901*/
+		0x00,/*REG = 0x0902*/
+		0x01,/*REG = 0x0383*/
+		0x01,/*REG = 0x0387*/
+		0x0A,/*REG = 0x034c*/
+		0x30,/*REG = 0x034d*/
+		0x07,/*REG = 0x034e*/
+		0xA8,/*REG = 0x034f*/
+		0x02,/*0x1716*/
+		0x0d,/*0x1717*/
+		0x07,/*0x1718*/
+		0x7d,/*0x1719*/
+		0x01,/*0x3210*/
+		0x02,/*0x111*/
+		0x01,/*0x3410*/
+		0x01,/*0x3098*/
+		0x05, /*0x309D*/
+		0x02,
+		0x00,
+	}
+};
+
+
+
+struct vx6953_reg vx6953_regs = {
+	.reg_pat_init = &vx6953_reg_init[0],
+	.reg_pat = &vx6953_reg_pat[0],
+};
diff --git a/include/media/msm_camera.h b/include/media/msm_camera.h
index 65ca534..9732b35 100644
--- a/include/media/msm_camera.h
+++ b/include/media/msm_camera.h
@@ -6,16 +6,13 @@
 #endif
 #include <linux/types.h>
 #include <linux/ioctl.h>
-#include <linux/cdev.h>
 #ifdef MSM_CAMERA_GCC
 #include <time.h>
 #else
 #include <linux/time.h>
 #endif
 
-#ifdef __KERNEL__
 #include <linux/ion.h>
-#endif
 #define MSM_CAM_IOCTL_MAGIC 'm'
 
 #define MSM_CAM_IOCTL_GET_SENSOR_INFO \
