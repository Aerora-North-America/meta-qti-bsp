diff --git a/arch/arm/configs/msm7630-perf_defconfig b/arch/arm/configs/msm7630-perf_defconfig
index 56b9ae19..77c474c 100644
--- a/arch/arm/configs/msm7630-perf_defconfig
+++ b/arch/arm/configs/msm7630-perf_defconfig
@@ -377,5 +377,6 @@ CONFIG_CRC_CCITT=y
 CONFIG_DEVTMPFS=y
 CONFIG_DEVTMPFS_MOUNT=y
 CONFIG_UNIX98_PTYS=y
+CONFIG_VIDEO_MSM=y
 CONFIG_DRM=y
 CONFIG_MSM_KGSL_DRM=y
diff --git a/arch/arm/mach-msm/board-msm7x30.c b/arch/arm/mach-msm/board-msm7x30.c
index 0e3ae26..f4aea01 100644
--- a/arch/arm/mach-msm/board-msm7x30.c
+++ b/arch/arm/mach-msm/board-msm7x30.c
@@ -3823,6 +3823,12 @@ static struct resource msm_fb_resources[] = {
 	}
 };
 
+static struct resource msm_v4l2_resources[] = {
+	{
+		.flags = IORESOURCE_DMA,
+	}
+};
+
 static int msm_fb_detect_panel(const char *name)
 {
 	if (machine_is_msm7x30_fluid()) {
@@ -3856,6 +3862,24 @@ static struct platform_device msm_fb_device = {
 	}
 };
 
+struct msm_v4l2_platform_data {
+	const char* name;
+};
+
+static struct msm_v4l2_platform_data msm_v4l2_pdata = {
+	.name = "msm_v4l2",
+};
+
+static struct platform_device msm_v4l2_device = {
+	.name   = "msmv4l2_pd",
+	.id     = 0,
+	.num_resources  = ARRAY_SIZE(msm_v4l2_resources),
+	.resource       = msm_v4l2_resources,
+	.dev    = {
+		.platform_data = &msm_v4l2_pdata,
+	}
+};
+
 static struct platform_device msm_migrate_pages_device = {
 	.name   = "msm_migrate_pages",
 	.id     = -1,
@@ -5334,6 +5358,7 @@ static struct platform_device *devices[] __initdata = {
 #endif
 	&android_pmem_device,
 	&msm_fb_device,
+	&msm_v4l2_device,
 	&msm_migrate_pages_device,
 	&mddi_toshiba_device,
 	&lcdc_toshiba_panel_device,
@@ -7224,10 +7249,16 @@ static void __init msm7x30_reserve(void)
 	msm_reserve();
 }
 
+/* Set aside 500K for the overlay buffers.
+	An overlay of 176x144 in YUV420 format
+	would consume 38K of memory per buffer.
+	But need a better estimate eventually */
+#define MSM_V4L2_BUF_SIZE 0x7A120
+
 static void __init msm7x30_allocate_memory_regions(void)
 {
 	void *addr;
-	unsigned long size;
+	unsigned long size; 
 
 	size = fb_size ? : MSM_FB_SIZE;
 	addr = alloc_bootmem_align(size, 0x1000);
@@ -7235,6 +7266,11 @@ static void __init msm7x30_allocate_memory_regions(void)
 	msm_fb_resources[0].end = msm_fb_resources[0].start + size - 1;
 	pr_info("allocating %lu bytes at %p (%lx physical) for fb\n",
 		size, addr, __pa(addr));
+
+	size = MSM_V4L2_BUF_SIZE;
+	addr = alloc_bootmem_align(size, 0x1000);
+	msm_v4l2_resources[0].start = __pa(addr);
+	msm_v4l2_resources[0].end = msm_v4l2_resources[0].start + size - 1;
 }
 
 static void __init msm7x30_map_io(void)
diff --git a/arch/arm/mach-msm/include/mach/msm_fb.h b/arch/arm/mach-msm/include/mach/msm_fb.h
index 339fa46..c791f44 100644
--- a/arch/arm/mach-msm/include/mach/msm_fb.h
+++ b/arch/arm/mach-msm/include/mach/msm_fb.h
@@ -187,6 +187,9 @@ struct msm_mddi_bridge_platform_data {
 	uint32_t panel_caps;
 };
 
+struct mdp_v4l2_req;
+int msm_fb_v4l2_enable(struct mdp_overlay *req, bool enable, void **par);
+int msm_fb_v4l2_update(void *par, unsigned long src_addr);
 
 
 #endif
diff --git a/drivers/media/video/msm/Kconfig b/drivers/media/video/msm/Kconfig
index 24f2b68..7f2d075 100644
--- a/drivers/media/video/msm/Kconfig
+++ b/drivers/media/video/msm/Kconfig
@@ -220,3 +220,12 @@ config S5K4ECGX
 	default y
 	---help---
 	  SAMSUNG 5M Bayer / JPG Sensor
+
+config VIDEO_MSM
+	bool "MSM V4l2 video driver"
+	default n
+	---help---
+	  Enables support for the MSM V4L2 video
+	  driver. This allows video rendering apps
+	  to render video using Video4Linux2 APIs,
+	  by using /dev/videoX device
diff --git a/drivers/media/video/msm/Makefile b/drivers/media/video/msm/Makefile
index d7aa7cb..fe1f85e 100644
--- a/drivers/media/video/msm/Makefile
+++ b/drivers/media/video/msm/Makefile
@@ -47,3 +47,4 @@ ifeq ($(CONFIG_MSM_CAMERA_V4L2),n)
 endif
 
 obj-$(CONFIG_FB_MSM_WRITEBACK_MSM_PANEL) += wfd/
+obj-$(CONFIG_VIDEO_MSM) += msm_v4l2_video.o
diff --git a/drivers/media/video/msm/msm_v4l2_video.c b/drivers/media/video/msm/msm_v4l2_video.c
new file mode 100644
index 0000000..be0c82b
--- /dev/null
+++ b/drivers/media/video/msm/msm_v4l2_video.c
@@ -0,0 +1,786 @@
+/*
+Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License version 2 and
+only version 2 as published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#include <linux/init.h>
+#include <linux/fb.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/time.h>
+#include <linux/videodev2.h>
+#include <linux/platform_device.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/msm_mdp.h>
+
+#include <media/v4l2-ioctl.h>
+#include <media/videobuf-dma-sg.h>
+
+#include <mach/board.h>
+#include <mach/msm_fb.h>
+
+#include <linux/msm_v4l2_video.h>
+#include <media/v4l2-dev.h> 
+
+#define MSM_VIDEO -1
+
+static struct msmv4l2_device 	*saved_vout0;
+
+struct mutex msmfb_lock;
+static char *v4l2_ram_phys;
+static unsigned int v4l2_ram_size;
+
+static int msmv4l2_mapformat(uint32_t pixelformat);
+
+static int msmv4l2_startstreaming(struct msmv4l2_device *vout)
+{
+	
+	memset (&vout->req, 0, sizeof(struct mdp_overlay));
+	
+	vout->req.src.width = vout->pix.width;
+	vout->req.src.height = vout->pix.height;
+
+	vout->req.src_rect.x = vout->crop_rect.left;
+	vout->req.src_rect.y = vout->crop_rect.top;
+	vout->req.src_rect.w = vout->crop_rect.width;
+	vout->req.src_rect.h = vout->crop_rect.height;
+
+
+	vout->req.src.format = msmv4l2_mapformat(vout->pix.pixelformat);
+
+
+	vout->req.dst_rect.x = vout->win.w.left;
+	vout->req.dst_rect.y = vout->win.w.top;
+	vout->req.dst_rect.w = vout->win.w.width;
+	vout->req.dst_rect.h = vout->win.w.height;
+
+	vout->req.alpha = MDP_ALPHA_NOP;
+	vout->req.transp_mask = MDP_TRANSP_NOP;
+	vout->req.flags = MDP_ROT_NOP;
+
+	mutex_lock(&msmfb_lock);
+	msm_fb_v4l2_enable(&vout->req, true, &vout->par);
+	mutex_unlock(&msmfb_lock);
+
+	vout->streaming = 1;
+
+	return 0;
+}
+
+static int msmv4l2_stopstreaming(struct msmv4l2_device *vout)
+{
+	if (!vout->streaming)
+		return 0;
+
+	mutex_lock(&msmfb_lock);
+	msm_fb_v4l2_enable(&vout->req, false, &vout->par);
+	mutex_unlock(&msmfb_lock);
+
+	vout->streaming = 0;
+
+	return 0;
+}
+
+static int msmv4l2_mapformat(uint32_t pixelformat)
+{
+	int mdp_format;
+
+	switch(pixelformat) {
+		case V4L2_PIX_FMT_RGB565:
+			mdp_format = MDP_RGB_565;
+			break;
+		case V4L2_PIX_FMT_RGB32:
+			mdp_format = MDP_ARGB_8888;
+			break;
+		case V4L2_PIX_FMT_RGB24:
+			mdp_format = MDP_RGB_888;
+			break;
+		case V4L2_PIX_FMT_NV12:
+			mdp_format = MDP_Y_CRCB_H2V2;
+			break;
+		case V4L2_PIX_FMT_NV21:
+			mdp_format = MDP_Y_CBCR_H2V2;
+			break;
+      case V4L2_PIX_FMT_YUV420:
+			mdp_format = MDP_Y_CR_CB_H2V2;
+			break;
+		default:	
+			mdp_format = MDP_Y_CBCR_H2V2;	
+			break;
+	}	
+
+	return mdp_format;
+}
+
+static int 
+msmv4l2_fb_update(struct msmv4l2_device *vout, struct v4l2_buffer *buffer)
+{
+	int ret;
+	unsigned long src_addr;
+	if(!buffer || buffer->index >= vout->numbufs) 
+		return -EINVAL;
+
+
+	src_addr = (unsigned long)v4l2_ram_phys 
+								+ vout->bufs[buffer->index].offset;
+
+	mutex_lock(&msmfb_lock);
+
+	ret = msm_fb_v4l2_update(vout->par, src_addr);
+
+	mutex_unlock(&msmfb_lock);
+
+   vout->bufs[buffer->index].queued = 1;
+	buffer->flags |= V4L2_BUF_FLAG_MAPPED;
+	buffer->flags |= V4L2_BUF_FLAG_QUEUED;
+
+	
+	return ret;
+}
+
+static int
+msmv4l2_vidioc_dqbuf(struct file *file, struct msmv4l2_fh* fh, void *arg)
+{
+	struct msmv4l2_device *vout = fh->vout;
+	struct v4l2_buffer *buffer = (struct v4l2_buffer *)arg;
+	int i;
+
+	if(!vout->streaming) {
+		printk(KERN_ERR "msmv4l2: Video Stream not enabled\n");
+		return -EINVAL;
+	}
+
+	if(!buffer || buffer->type != V4L2_BUF_TYPE_VIDEO_OUTPUT 
+			|| buffer->memory != V4L2_MEMORY_MMAP)
+		return -EINVAL;
+
+	for(i=0;i<vout->numbufs;i++) {
+		if(vout->bufs[i].queued == 1)  {
+			vout->bufs[i].queued = 0;
+			/* Call into fb to remove this buffer? */
+			break;
+		}
+	}
+	
+   /* This should actually block, unless O_NONBLOCK was specified in open, but fine for now,
+		especially since this is not a capturing device */
+	if(i == vout->numbufs)
+		return -EAGAIN;
+
+	return 0;
+}
+
+
+static int 
+msmv4l2_vidioc_qbuf(struct file *file, struct msmv4l2_fh* fh, void *arg)
+{
+	struct msmv4l2_device *vout = fh->vout;
+	struct v4l2_buffer *buffer = (struct v4l2_buffer *) arg;
+	int ret;
+
+	if(!vout->streaming) {
+		printk(KERN_ERR "msmv4l2: Video Stream not enabled\n");
+		return -EINVAL;
+	}
+
+	/* maybe allow only one qbuf at a time? */
+	ret =  msmv4l2_fb_update( vout, buffer );
+
+	return 0;
+}
+
+
+static int
+msmv4l2_vidioc_querycap(struct file *file, void *arg)
+{
+	struct v4l2_capability *buffer = (struct v4l2_capability *) arg;
+	memset(buffer, 0, sizeof(struct v4l2_capability));
+	strlcpy(buffer->driver, "msm_v4l2_video", sizeof(buffer->driver)/sizeof(buffer->driver[0]));
+	strlcpy(buffer->card, "MSM MDP", sizeof(buffer->card)/sizeof(buffer->card[0]));
+	buffer->capabilities = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_VIDEO_OVERLAY;
+	return 0;
+
+
+}
+
+static int
+msmv4l2_vidioc_fbuf(struct file *file, struct msmv4l2_device *vout, void *arg,  bool get)
+{
+	struct v4l2_framebuffer *fb = (struct v4l2_framebuffer *)arg;
+
+	if(fb == NULL) {
+		return -EINVAL;
+	}
+
+	if(get) {
+		mutex_lock(&vout->update_lock);
+		memcpy(&fb->fmt, &vout->pix, sizeof(struct v4l2_pix_format));
+		mutex_unlock(&vout->update_lock);
+		return 0;
+	} else {
+		/* Ignoring framebuffer parameters for now */
+#if 0
+		mutex_lock(&vout->update_lock);
+		memcpy(&vout->pix, &fb->fmt, sizeof(struct v4l2_pix_format));
+		mutex_unlock(&vout->update_lock);
+#endif
+		return 0;
+	}
+}
+
+static long msmv4l2_calculate_bufsize(struct v4l2_pix_format *pix)
+{
+	int bpp;
+	long bufsize;
+	switch(pix->pixelformat) {
+		case V4L2_PIX_FMT_YUV420:
+			bpp = 12;
+			break;
+
+		case V4L2_PIX_FMT_RGB24:
+		case V4L2_PIX_FMT_BGR24:
+		case V4L2_PIX_FMT_YUV444:
+			bpp = 24;
+			break;
+
+		case V4L2_PIX_FMT_RGB32:
+		case V4L2_PIX_FMT_BGR32:
+			bpp = 32;
+			break;
+		default:
+			bpp = 0;
+	}
+
+	bufsize = (pix->width * pix->height * bpp)/8;
+
+   return bufsize;
+}
+
+static long 
+msmv4l2_vidioc_reqbufs(struct file *file, struct msmv4l2_device *vout, 
+						void *arg)
+{
+
+	struct v4l2_requestbuffers *rqb = (struct v4l2_requestbuffers *)arg;
+	long bufsize;
+	int i;
+
+	if(rqb == NULL || rqb->type != V4L2_BUF_TYPE_VIDEO_OUTPUT
+			|| rqb->memory != V4L2_MEMORY_MMAP)
+		return -EINVAL;
+
+	if(rqb->count == 0) {
+		/*Deallocate allocated buffers */
+		mutex_lock(&vout->update_lock);
+	   vout->numbufs = 0;
+		kfree(vout->bufs);
+		/* There should be a way to look at bufs[i]->mapped, 
+			and prevent userspace from mmaping and directly calling
+			this ioctl without unmapping. Maybe kernel handles for us,
+			but needs to be checked out */
+		mutex_unlock(&vout->update_lock);
+	} else {
+		/* Keep it simple for now - need to deallocate before reallocate */
+		if(vout->bufs)
+			return -EINVAL;
+
+		mutex_lock(&vout->update_lock);
+		bufsize = msmv4l2_calculate_bufsize(&vout->pix);	
+		mutex_unlock(&vout->update_lock);
+
+		if(bufsize == 0 || (bufsize * rqb->count) > v4l2_ram_size)  
+			return -EINVAL;
+
+	   /* We don't support multiple open of one vout,
+		 but there are probably still some MT problems here,
+		 (what if same fh is shared between two userspace threads
+		 and they both call REQBUFS etc), need to look at them*/
+		 
+		mutex_lock(&vout->update_lock);
+		vout->numbufs = rqb->count;
+		vout->bufs = kmalloc(rqb->count * sizeof(struct msmv4l2_buffer), GFP_KERNEL);
+
+		for(i=0;i<rqb->count;i++) {
+			struct msmv4l2_buffer *b = (struct msmv4l2_buffer *)vout->bufs + i;
+			/* The mapped thing is not yet implemented, even on mmap */
+			b->mapped = 0;
+			b->queued = 0;
+			b->offset = PAGE_ALIGN(bufsize*i);
+			b->bufsize = bufsize;
+		}
+
+		mutex_unlock(&vout->update_lock);
+
+	}
+
+	return 0;
+}
+
+static long
+msmv4l2_vidioc_querybuf(struct file *file,
+				 struct msmv4l2_device *vout,
+				 void *arg)
+{
+	struct v4l2_buffer *buf = (struct v4l2_buffer *)arg;
+	struct msmv4l2_buffer *mbuf;
+
+	if(buf == NULL || buf->type != V4L2_BUF_TYPE_VIDEO_OUTPUT
+			|| buf->index >= vout->numbufs)
+		return -EINVAL;
+
+	mutex_lock(&vout->update_lock);
+
+	mbuf = (struct msmv4l2_buffer *)vout->bufs + buf->index;
+	buf->flags = 0;
+	if(mbuf->mapped)
+		buf->flags |= V4L2_BUF_FLAG_MAPPED;
+	if(mbuf->queued)
+		buf->flags |= V4L2_BUF_FLAG_QUEUED;
+
+	buf->memory = V4L2_MEMORY_MMAP;
+	buf->length = mbuf->bufsize;
+	buf->m.offset = mbuf->offset;
+
+	mutex_unlock(&vout->update_lock);
+
+	return 0;
+	
+}
+
+
+static long 
+msmv4l2_do_ioctl (struct file *file,
+		       unsigned int cmd, void *arg)
+{
+	struct msmv4l2_fh *fh = (struct msmv4l2_fh *)file->private_data;
+	struct msmv4l2_device *vout = fh->vout;
+	int ret;
+
+	switch (cmd){
+   case VIDIOC_QUERYCAP:
+		return msmv4l2_vidioc_querycap(file, arg);
+
+	case VIDIOC_G_FBUF:
+		return msmv4l2_vidioc_fbuf(file, vout, arg, true);
+
+	case VIDIOC_S_FBUF:
+		return msmv4l2_vidioc_fbuf(file, vout, arg, false);
+
+	case VIDIOC_REQBUFS:
+		return msmv4l2_vidioc_reqbufs(file, vout, arg);
+
+  case VIDIOC_QUERYBUF:
+		return msmv4l2_vidioc_querybuf(file, vout, arg);
+
+	case VIDIOC_QBUF:
+		mutex_lock(&vout->update_lock);
+		ret = msmv4l2_vidioc_qbuf(file, fh, arg);
+		mutex_unlock(&vout->update_lock);
+
+		return ret;
+	
+	case VIDIOC_DQBUF:
+		mutex_lock(&vout->update_lock);
+		ret = msmv4l2_vidioc_dqbuf(file, fh, arg);
+		mutex_unlock(&vout->update_lock);
+		break;
+
+	case VIDIOC_S_FMT: {
+		struct v4l2_format *f = (struct v4l2_format *) arg;
+
+		switch(f->type){
+			case V4L2_BUF_TYPE_VIDEO_OVERLAY: {
+
+				mutex_lock(&vout->update_lock);
+				memcpy(&vout->win, &f->fmt.win, sizeof(struct v4l2_window));
+				mutex_unlock(&vout->update_lock);
+
+				break;
+			}
+			case V4L2_BUF_TYPE_VIDEO_OUTPUT: {				
+
+				mutex_lock(&vout->update_lock);
+				memcpy(&vout->pix, &f->fmt.pix, sizeof(struct v4l2_pix_format));
+				mutex_unlock(&vout->update_lock);
+
+				break;
+			}
+			default:
+				return -EINVAL;
+		}
+		break;
+	}
+	case VIDIOC_G_FMT: {
+		struct v4l2_format *f = (struct v4l2_format *) arg;
+
+		switch (f->type){
+			case V4L2_BUF_TYPE_VIDEO_OUTPUT: {
+				struct v4l2_pix_format *pix = &f->fmt.pix;
+				memset (pix, 0, sizeof (*pix));
+				*pix = vout->pix;
+				break;
+			}
+
+			case V4L2_BUF_TYPE_VIDEO_OVERLAY: {
+				struct v4l2_window *win = &f->fmt.win;
+				memset (win, 0, sizeof (*win));
+				win->w = vout->win.w;
+				break;
+			}
+			default:
+				return -EINVAL;
+		}
+		break;
+	}
+
+   case VIDIOC_CROPCAP: {
+		struct v4l2_cropcap *cr = (struct v4l2_cropcap *)arg;
+		if(cr->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+			return -EINVAL;
+		
+		cr->bounds.left =  0;
+		cr->bounds.top = 0;
+		cr->bounds.width = vout->pix.width;
+		cr->bounds.height = vout->pix.height;
+											
+		cr->defrect.left =  0;
+		cr->defrect.top = 0;
+		cr->defrect.width = vout->pix.width;
+		cr->defrect.height = vout->pix.height;
+
+		cr->pixelaspect.numerator = 1;
+		cr->pixelaspect.denominator = 1;
+		break;									
+	}
+
+	case VIDIOC_S_CROP: {
+		struct v4l2_crop *crop = (struct v4l2_crop *) arg;
+
+		switch(crop->type) {
+
+			case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+
+				mutex_lock(&vout->update_lock);
+				memcpy(&vout->crop_rect, &crop->c, sizeof(struct v4l2_rect));
+				mutex_unlock(&vout->update_lock);
+
+				break;
+
+			default:
+
+				return -EINVAL;
+		}
+		break;
+	}
+	case VIDIOC_G_CROP: {
+		struct v4l2_crop *crop = (struct v4l2_crop *) arg;
+		
+		switch (crop->type) {
+
+			case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+				memcpy(&crop->c, &vout->crop_rect, sizeof(struct v4l2_rect));
+				break;
+
+			default:
+				return -EINVAL;
+		}
+		break;
+	}
+	case VIDIOC_STREAMON: {
+
+		if(vout->streaming) {
+			printk(KERN_ERR "msmv4l2: VIDIOC_STREAMON: already streaming.\n");
+			return -EBUSY;
+		}
+		
+		mutex_lock(&vout->update_lock);
+		msmv4l2_startstreaming(vout);
+		mutex_unlock(&vout->update_lock);
+
+		break;
+	}
+
+	case VIDIOC_STREAMOFF: {
+
+		if(!vout->streaming) {
+			printk(KERN_ERR "msmv4l2: VIDIOC_STREAMOFF: not currently streaming.\n");
+			return -EINVAL;
+		}
+
+		mutex_lock(&vout->update_lock);
+		msmv4l2_stopstreaming( vout );
+		mutex_unlock(&vout->update_lock);
+
+		break;
+	}
+
+	default:
+		return -ENOIOCTLCMD;
+
+	}/* switch */
+
+	return 0;
+}
+
+static long 
+msmv4l2_ioctl (struct file *file, unsigned int cmd,
+		    unsigned long arg)
+{
+	return video_usercopy (file, cmd, arg, msmv4l2_do_ioctl);
+}
+
+static int
+msmv4l2_mmap (struct file *filp, struct vm_area_struct * vma) 
+{
+	unsigned long start = (unsigned long)v4l2_ram_phys;
+	/* vm_pgoff is the offset (>>PAGE_SHIFT) that we provided during REQBUFS */ 
+	/* off therefore should equal the offset we provided in REQBUFS, since last
+	   (PAGE_SHIFT) bits of off should be 0*/
+	unsigned long off = vma->vm_pgoff << PAGE_SHIFT;
+	u32 len = PAGE_ALIGN((start & ~PAGE_MASK) + v4l2_ram_size);
+
+	/* This is probably unnecessary now - the last PAGE_SHIFT bits of start
+		should be 0 now, since we are page aligning v4l2_ram_phys */
+	start &= PAGE_MASK;
+
+	printk(KERN_INFO "v4l2 map req for phys(%p,%p) offset %u to virt (%p,%p)\n",
+			(void *)(start+off),(void *)(start+off+(vma->vm_end - vma->vm_start)), 
+			(unsigned int)off, (void *)vma->vm_start,(void *)vma->vm_end);
+
+	if ((vma->vm_end - vma->vm_start + off) > len) {
+		printk(KERN_ERR "v4l2 map req too big\n");
+		return -EINVAL;
+	}
+
+	start += off;
+	vma->vm_pgoff = start >> PAGE_SHIFT;
+	/* This is an IO map - tell maydump to skip this VMA */
+	vma->vm_flags |= VM_IO | VM_RESERVED;
+
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	/* Remap the frame buffer I/O range */
+	if (io_remap_pfn_range(vma, vma->vm_start, start >> PAGE_SHIFT,
+				vma->vm_end - vma->vm_start,
+				vma->vm_page_prot)) {
+		printk(KERN_ERR "io_remap_pfn_range failed\n");
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+
+int
+msmv4l2_release(struct file *file)
+{
+	struct msmv4l2_fh *fh = file->private_data;
+	struct msmv4l2_device *vout = fh->vout;
+
+	if(vout->streaming)
+ 		msmv4l2_stopstreaming( vout );
+
+	vout->ref_count--;
+
+	if(vout->bufs) {
+		kfree(vout->bufs);
+		vout->numbufs = 0;
+	}
+	kfree(fh);
+
+	return 0;
+}
+
+int
+msmv4l2_open(struct file *file)
+{
+	struct msmv4l2_device 	*vout = 0;
+	struct v4l2_pix_format	*pix = 0;
+	struct msmv4l2_fh *fh;
+
+	vout = saved_vout0;
+	vout->id = 0;
+
+	if (!vout) {
+		printk (KERN_ERR "msmv4l2_open: no context\n");
+		return -EBUSY;
+	}
+
+	if (vout->ref_count) {
+		printk (KERN_ERR "msmv4l2_open: multiple open currently is not supported!\n");
+		return -EBUSY;
+	}
+
+	// Increment reference count
+	vout->ref_count++;
+
+	/* allocate per-filehandle data */
+	fh = kmalloc (sizeof(struct msmv4l2_fh), GFP_KERNEL);
+	if (NULL == fh) {
+		printk (KERN_ERR "msmv4l2_open: kmalloc failed\n");
+		return -ENOMEM;
+	}
+
+	fh->vout = vout;
+	fh->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+
+	file->private_data = fh;
+
+	vout->streaming 	= 0;
+	vout->crop_rect.left 	= vout->crop_rect.top = 0;
+	vout->crop_rect.width 	= vout->screen_width;
+	vout->crop_rect.height 	= vout->screen_height;
+
+	pix 				= &vout->pix;
+	pix->width 			= vout->screen_width;
+	pix->height 		= vout->screen_height;
+	pix->pixelformat 	= V4L2_PIX_FMT_RGB32;
+	pix->field 			= V4L2_FIELD_NONE;
+	pix->bytesperline 	= pix->width * 4;
+	pix->sizeimage 		= pix->bytesperline * pix->height;
+	pix->priv 			= 0;
+	pix->colorspace 	= V4L2_COLORSPACE_SRGB;
+
+	vout->win.w.left 	= 0;
+	vout->win.w.top 	= 0;
+	vout->win.w.width 	= vout->screen_width;
+	vout->win.w.height 	= vout->screen_height;
+
+	vout->fb.capability = V4L2_FBUF_CAP_EXTERNOVERLAY | V4L2_FBUF_CAP_LOCAL_ALPHA;
+	vout->fb.flags = V4L2_FBUF_FLAG_LOCAL_ALPHA;
+	vout->fb.base = 0;
+	memcpy(&vout->fb.fmt, pix, sizeof(struct v4l2_format));
+
+	vout->bufs = 0;
+	vout->numbufs = 0;
+
+	mutex_init(&vout->update_lock);
+
+	return 0;
+}
+
+
+static int 
+msmv4l2_probe(struct platform_device *pdev)
+{	
+	char *v4l2_ram_phys_unaligned;
+	if ((pdev->id == 0) && (pdev->num_resources > 0)) {
+		v4l2_ram_size =
+			pdev->resource[0].end - pdev->resource[0].start + 1;
+		v4l2_ram_phys_unaligned = (char *)pdev->resource[0].start;
+		v4l2_ram_phys = (char *)PAGE_ALIGN((unsigned int)v4l2_ram_phys_unaligned);
+		/* We are (fwd) page aligning the start of v4l2 memory.
+			Therefore we have that much less physical memory available */
+		v4l2_ram_size -= (unsigned int)v4l2_ram_phys - (unsigned int)v4l2_ram_phys_unaligned;
+
+		
+	}
+	return 0;
+}
+
+static int msmv4l2_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+void msmv4l2_videodev_release(struct video_device *vfd)
+{
+	return;
+}
+
+/* TODO: Implement mmap here */
+static const struct v4l2_file_operations msmv4l2_fops = {
+	.owner		= THIS_MODULE,
+	.open		= msmv4l2_open,
+	.release	= msmv4l2_release,
+	.mmap		= msmv4l2_mmap,
+	.ioctl		= msmv4l2_ioctl,
+};
+
+static struct video_device msmv4l2_vid_device0 = {
+	.name		= "msmv4l2",
+	//.vfl_type		= VFL_TYPE_GRABBER, 
+	.fops       = &msmv4l2_fops,
+	.minor		= -1,
+	.release	= msmv4l2_videodev_release,
+};
+
+static struct platform_driver msmv4l2_platform_driver = {
+	.probe   = msmv4l2_probe,
+	.remove  = msmv4l2_remove,
+	.driver  = {
+			 .name = "msmv4l2_pd",
+		   },
+};
+
+static int __init
+msmv4l2_init (void)
+{
+	int ret = 0;
+
+
+	saved_vout0 = kmalloc (sizeof (struct msmv4l2_device), GFP_KERNEL);
+
+	if (!saved_vout0) {
+		printk (KERN_ERR "msmv4l2: kmalloc failed\n");
+		goto end;
+	}
+
+	memset (saved_vout0, 0, sizeof (struct msmv4l2_device));
+
+	ret = platform_driver_register(&msmv4l2_platform_driver);
+	if(ret < 0) {
+		printk (KERN_ERR "msmv4l2: platform_driver_register failed\n");
+		goto end;
+	}
+
+	//Register the device with videodev. 
+	//Videodev will make IOCTL calls on application requests
+	ret = video_register_device (&msmv4l2_vid_device0, VFL_TYPE_GRABBER, MSM_VIDEO);
+	if (ret < 0) {
+		printk (KERN_ERR "msmv4l2: could not register Video for Linux device 1\n");
+		goto end_unregister;
+	}	
+
+	mutex_init(&msmfb_lock);
+	
+	return 0;
+
+end_unregister:
+	platform_driver_unregister(&msmv4l2_platform_driver);
+
+end:
+	kfree(saved_vout0);
+	saved_vout0 = NULL;
+	return ret;
+}
+
+static void
+msmv4l2_exit (void)
+{
+
+
+	video_unregister_device(&msmv4l2_vid_device0);
+
+	platform_driver_unregister(&msmv4l2_platform_driver);
+
+	kfree(saved_vout0);
+	saved_vout0 = NULL;
+	return;
+}
+
+module_init (msmv4l2_init);
+module_exit (msmv4l2_exit);
+
+MODULE_AUTHOR ("Code Aurora Forum");
+MODULE_DESCRIPTION ("MSM V4L2 Driver");
+MODULE_LICENSE ("GPL");
+
diff --git a/drivers/video/msm/mdp.c b/drivers/video/msm/mdp.c
index aeeb503..8ebef40 100644
--- a/drivers/video/msm/mdp.c
+++ b/drivers/video/msm/mdp.c
@@ -1356,6 +1356,7 @@ static int mdp_probe(struct platform_device *pdev)
 	pdata->next = pdev;
 
 	mdp_prim_panel_type = mfd->panel.type;
+	printk(KERN_INFO "MDP panel type is %d\n", mfd->panel.type);
 	switch (mfd->panel.type) {
 	case EXT_MDDI_PANEL:
 	case MDDI_PANEL:
diff --git a/drivers/video/msm/mdp4.h b/drivers/video/msm/mdp4.h
index ad7fc04..c0a23fd 100644
--- a/drivers/video/msm/mdp4.h
+++ b/drivers/video/msm/mdp4.h
@@ -636,4 +636,8 @@ int mdp4_writeback_terminate(struct fb_info *info);
 
 void mdp4_hsic_set(struct mdp4_overlay_pipe *pipe, struct dpp_ctrl *ctrl);
 void mdp4_hsic_update(struct mdp4_overlay_pipe *pipe);
+
+int mdp4_v4l2_overlay_set(struct fb_info *info, struct mdp_overlay *req, struct mdp4_overlay_pipe **ppipe);
+void mdp4_v4l2_overlay_clear(struct mdp4_overlay_pipe *pipe);
+int mdp4_v4l2_overlay_play(struct fb_info *info, struct mdp4_overlay_pipe *pipe, unsigned long src_addr);
 #endif /* MDP_H */
diff --git a/drivers/video/msm/mdp4_overlay.c b/drivers/video/msm/mdp4_overlay.c
index 1b80d4c..e2b7e36 100644
--- a/drivers/video/msm/mdp4_overlay.c
+++ b/drivers/video/msm/mdp4_overlay.c
@@ -605,6 +605,7 @@ int mdp4_overlay_format2type(uint32 format)
 	case MDP_Y_CBCR_H1V1:
 		return OVERLAY_TYPE_VIDEO;
 	default:
+		pr_err("%s %u\n", __func__, __LINE__);
 		mdp4_stat.err_format++;
 		return -ERANGE;
 	}
@@ -1213,6 +1214,7 @@ void mdp4_mixer_stage_up(struct mdp4_overlay_pipe *pipe)
 
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
+	pr_err("ctrl %p pipe %p mixer_num %d mixer_stage %d\n", ctrl, pipe, pipe->mixer_num, pipe->mixer_stage);
 	ctrl->stage[pipe->mixer_num][pipe->mixer_stage] = pipe;	/* keep it */
 }
 
@@ -1389,6 +1391,7 @@ void mdp4_overlay_reg_flush(struct mdp4_overlay_pipe *pipe, int all)
 
 struct mdp4_overlay_pipe *mdp4_overlay_stage_pipe(int mixer, int stage)
 {
+	pr_err("ctrl %p mixer %d stage %d\n", ctrl, mixer, stage);
 	return ctrl->stage[mixer][stage];
 }
 
@@ -2472,3 +2475,89 @@ end:
 #endif
 	return ret;
 }
+
+int mdp4_v4l2_overlay_set(struct fb_info *info, struct mdp_overlay *req, struct mdp4_overlay_pipe **ppipe)
+{
+	struct mdp4_overlay_pipe *pipe;
+	int err;
+	struct msm_fb_data_type *mfb = (struct msm_fb_data_type *)info->par;
+
+	/* Setup pipe parameters here */
+	req->z_order = 1;
+	req->id = MSMFB_NEW_REQUEST;
+	req->is_fg = true;
+	err = mdp4_overlay_req2pipe(req, MDP4_MIXER0, &pipe,
+				mfb);	
+	if(err < 0) {
+		printk(KERN_ERR "v4l2:Could not allocate MDP overlay pipe");
+		return err;
+	}
+	
+	mdp4_mixer_blend_setup(pipe);
+	*ppipe = pipe;
+
+	printk(KERN_INFO "v4l2 overlay pipe allocated: %d\n", pipe->pipe_num);
+	if(pipe->src_format == MDP_Y_CB_CR_H2V2) 
+		printk(KERN_INFO "v4l2 pipe src format is : MDP_Y_CB_CR_H2V2\n");
+	else
+		printk(KERN_INFO "v4l2 pipe src format is NOT MDP_Y_CB_CR_H2V2\n");
+	return 0;
+}
+
+void mdp4_v4l2_overlay_clear(struct mdp4_overlay_pipe *pipe)
+{
+	/* Bring down the overlay pipe here */
+	mdp4_mixer_stage_down(pipe);
+	mdp4_overlay_pipe_free(pipe);
+}
+
+int mdp4_v4l2_overlay_play(struct fb_info *info, struct mdp4_overlay_pipe *pipe, unsigned long src_addr)
+{
+	/* here, we need to look at which format is configured into the pipe, and accordingly set p0addr/p1addr etc */
+
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+
+	if(pipe->src_format == MDP_Y_CR_CB_H2V2) {
+		printk(KERN_INFO "v4l2_play: YCbCr\n");
+		pipe->srcp0_addr = src_addr;
+		pipe->srcp0_ystride = pipe->src_width;
+		/* For YUV420, the luma plane is 1 byte per pixel times num of pixels in the image */
+		pipe->srcp2_addr = src_addr + (pipe->src_width * pipe->src_height);
+		pipe->srcp1_ystride = pipe->src_width/2;
+		/* The chroma planes are half the size of the luma planes */
+		pipe->srcp1_addr = pipe->srcp2_addr + (pipe->src_width * pipe->src_height) / 4 ;
+		pipe->srcp2_ystride = pipe->src_width/2;
+	} else {
+		printk(KERN_INFO "v4l2_play: unsupported format\n");
+		return -EINVAL; /* for now */
+	}
+
+	if(pipe->pipe_type == OVERLAY_TYPE_VIDEO) {
+		mdp4_overlay_vg_setup(pipe);
+	} else {
+		mdp4_overlay_rgb_setup(pipe);
+	}
+	mdp4_mixer_stage_up(pipe);
+
+	printk(KERN_INFO "v4l2: Updating MDP now: panel mode: 0x%x\n", ctrl->panel_mode);
+	if (ctrl->panel_mode & MDP4_PANEL_LCDC) {
+		printk(KERN_INFO "v4l2: Updating LCDC\n");
+		mdp4_overlay_reg_flush(pipe, 1);
+		printk(KERN_INFO "v4l2: Pushing vsync\n");
+		mdp4_overlay_lcdc_vsync_push(mfd, pipe);
+	}
+	else {
+		if (ctrl->panel_mode & MDP4_PANEL_MDDI) { 
+			printk(KERN_INFO "v4l2: Updating MDDI\n");
+			printk(KERN_INFO "v4l2: Pushing vsync\n");
+			mdp4_mddi_kickoff_video(mfd, pipe);
+			printk(KERN_INFO "v4l2: Waiting for dma\n");
+			mdp4_mddi_dma_busy_wait(mfd);
+		} else
+			printk(KERN_INFO "v4l2: panel play is not supported\n");
+			
+	}
+	return 0;
+}
+
+
diff --git a/drivers/video/msm/mdp4_overlay_mddi.c b/drivers/video/msm/mdp4_overlay_mddi.c
index 928ac32..ba0dc76 100644
--- a/drivers/video/msm/mdp4_overlay_mddi.c
+++ b/drivers/video/msm/mdp4_overlay_mddi.c
@@ -109,6 +109,7 @@ void mdp4_overlay_update_lcd(struct msm_fb_data_type *mfd)
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
 
 	if (mddi_pipe == NULL) {
+		pr_err("%s %u\n", __func__, __LINE__);
 		ptype = mdp4_overlay_format2type(mfd->fb_imgType);
 		if (ptype < 0)
 			printk(KERN_INFO "%s: format2type failed\n", __func__);
@@ -424,6 +425,7 @@ void mdp4_mddi_dma_busy_wait(struct msm_fb_data_type *mfd)
 	if (need_wait) {
 		/* wait until DMA finishes the current job */
 		pr_debug("%s: PENDING, pid=%d\n", __func__, current->pid);
+		printk(KERN_INFO "mdp4:Waiting on dma for pid %d\n", current->pid);
 		wait_for_completion(&mfd->dma->comp);
 	}
 	pr_debug("%s: DONE, pid=%d\n", __func__, current->pid);
@@ -579,7 +581,7 @@ void mdp4_mddi_overlay(struct msm_fb_data_type *mfd)
 	mutex_lock(&mfd->dma->ov_mutex);
 
 	if (mfd && mfd->panel_power_on) {
-		mdp4_mddi_dma_busy_wait(mfd);
+		pr_err("%s\n", __func__);
 		mdp4_overlay_update_lcd(mfd);
 
 		if (mdp_hw_revision < MDP4_REVISION_V2_1) {
@@ -593,6 +595,7 @@ void mdp4_mddi_overlay(struct msm_fb_data_type *mfd)
 		} else	/* no dams dmap switch  */
 			mdp4_mddi_kickoff_ui(mfd, mddi_pipe);
 
+		mdp4_mddi_dma_busy_wait(mfd);
 		mdp4_stat.kickoff_mddi++;
 
 	/* signal if pan function is waiting for the update completion */
diff --git a/drivers/video/msm/msm_fb.c b/drivers/video/msm/msm_fb.c
index 10e4156..b02f8f6 100644
--- a/drivers/video/msm/msm_fb.c
+++ b/drivers/video/msm/msm_fb.c
@@ -40,6 +40,7 @@
 #include <linux/android_pmem.h>
 #include <linux/leds.h>
 #include <linux/pm_runtime.h>
+#include <linux/msm_v4l2_video.h>
 
 #define MSM_FB_C
 #include "msm_fb.h"
@@ -1339,6 +1340,7 @@ static int msm_fb_open(struct fb_info *info, int user)
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
 	int result;
 
+	printk(KERN_INFO "msm_fb_open\n");
 	result = pm_runtime_get_sync(info->dev);
 
 	if (result < 0) {
@@ -1363,6 +1365,7 @@ static int msm_fb_release(struct fb_info *info, int user)
 {
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
 	int ret = 0;
+	printk(KERN_INFO "msm_fb_release\n");
 
 	if (!mfd->ref_cnt) {
 		MSM_FB_INFO("msm_fb_release: try to close unopened fb %d!\n",
@@ -3361,4 +3364,30 @@ int __init msm_fb_init(void)
 	return 0;
 }
 
+/* Called by v4l2 driver to enable/disable overlay pipe */
+int msm_fb_v4l2_enable(struct mdp_overlay *req, bool enable, void **par)
+{
+	int err;
+	struct mdp4_overlay_pipe *pipe;
+	if(enable) {
+
+		err = mdp4_v4l2_overlay_set(fbi_list[0], req, &pipe); 
+
+		*(struct mdp4_overlay_pipe **)par = pipe;
+
+	} else {
+		pipe = *(struct mdp4_overlay_pipe **)par;
+		mdp4_v4l2_overlay_clear(pipe);
+	}
+	
+	return 0;
+}
+
+/* Called by v4l2 driver to provide a frame for display */
+int msm_fb_v4l2_update(void *par, unsigned long src_addr)
+{
+	struct mdp4_overlay_pipe *pipe = (struct mdp4_overlay_pipe *)par;
+	return mdp4_v4l2_overlay_play(fbi_list[0], pipe, src_addr);
+}
+
 module_init(msm_fb_init);
diff --git a/include/linux/msm_v4l2_video.h b/include/linux/msm_v4l2_video.h
new file mode 100644
index 0000000..d3eadf7
--- /dev/null
+++ b/include/linux/msm_v4l2_video.h
@@ -0,0 +1,48 @@
+#ifndef MSM_V4L2_VIDEO_H
+#define MSM_V4L2_VIDEO_H
+
+#include <linux/mm.h>
+#include <linux/msm_mdp.h>
+#include <linux/videodev2.h>
+
+
+struct msmv4l2_buffer {
+	int mapped;
+	int queued;
+	int offset;
+	int bufsize;
+};
+
+// msmv4l2 device data
+struct msmv4l2_device {
+	struct device dev;
+	int fb_fd;
+	struct file *fb_fp;
+
+	int ref_count;
+	int id;
+
+	int screen_width;
+	int screen_height;
+	int streaming;
+
+	struct v4l2_pix_format pix;
+	struct v4l2_window win;
+	struct v4l2_rect crop_rect;
+	struct v4l2_framebuffer fb;
+	struct msmv4l2_buffer *bufs;
+	int numbufs;
+	struct mdp_overlay req;
+	void *par;
+
+	struct mutex update_lock;
+};
+
+// Context data. Every open instance of the device has its own.
+struct msmv4l2_fh {
+	struct msmv4l2_device *vout;
+	enum v4l2_buf_type type;
+};
+
+#endif //MSM_V4L2_VIDEO_H
+
-- 
1.7.8

