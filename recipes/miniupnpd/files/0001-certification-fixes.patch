From 33a6458267c8061450858d563cf43356307d7a08 Mon Sep 17 00:00:00 2001
From: Tyler Wear <twear@codeaurora.org>
Date: Fri, 26 Sep 2014 09:00:50 -0700
Subject: [PATCH 1/1] certification-fixes

---
 config.h                      | 140 ++++++++++++++++++++++++++++++++++++++++++
 getifstats.h                  |   6 ++
 linux/miniupnpd.init.d.script |  15 -----
 miniupnpd.c                   |  33 +++++++++-
 miniupnpd.conf                |  20 +++---
 natpmp.c                      |  12 +++-
 pcpserver.c                   |  19 +++++-
 upnpredirect.c                |  81 +++++++++++++++++++++++-
 upnpredirect.h                |  17 ++++-
 upnpsoap.c                    | 119 ++++++++++++++++++++++++++++++++---
 10 files changed, 415 insertions(+), 47 deletions(-)
 create mode 100755 config.h
 mode change 100644 => 100755 getifstats.h
 mode change 100644 => 100755 linux/miniupnpd.init.d.script
 mode change 100644 => 100755 miniupnpd.c
 mode change 100644 => 100755 miniupnpd.conf
 mode change 100644 => 100755 natpmp.c
 mode change 100644 => 100755 pcpserver.c
 mode change 100644 => 100755 upnpredirect.c
 mode change 100644 => 100755 upnpredirect.h
 mode change 100644 => 100755 upnpsoap.c

diff --git a/config.h b/config.h
new file mode 100755
index 0000000..05e943b
--- /dev/null
+++ b/config.h
@@ -0,0 +1,140 @@
+/* MiniUPnP Project
+ * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
+ * (c) 2006-2014 Thomas Bernard
+ * generated by ./genconfig.sh on Tue Jul 22 16:26:08 PDT 2014
+ * using command line options  */
+#ifndef CONFIG_H_INCLUDED
+#define CONFIG_H_INCLUDED
+
+#include <inttypes.h>
+
+#define MINIUPNPD_VERSION "1.8"
+
+#define UPNP_VERSION	"20140722"
+#define USE_IFACEWATCHER 1
+#define USE_NETFILTER 1
+#define SUPPORT_REMOTEHOST
+
+#define OS_NAME		"Ubuntu"
+#define OS_VERSION	"Ubuntu/lucid"
+#define OS_URL		"http://www.ubuntu.com/"
+
+/* syslog facility to be used by miniupnpd */
+#define LOG_MINIUPNPD		 LOG_DAEMON
+
+/* Uncomment the following line to allow miniupnpd to be
+ * controlled by miniupnpdctl */
+/*#define USE_MINIUPNPDCTL*/
+
+/* Comment the following line to disable NAT-PMP operations */
+#define ENABLE_NATPMP
+
+/* Comment the following line to disable PCP operations */
+#define ENABLE_PCP
+
+#ifdef ENABLE_PCP
+/* Uncomment the following line to enable PCP PEER operation */
+/*#define PCP_PEER*/
+#ifdef PCP_PEER
+/*#define PCP_FLOWP*/
+#endif /*PCP_PEER*/
+/*#define PCP_SADSCP*/
+#endif /*ENABLE_PCP*/
+
+/* Uncomment the following line to enable generation of
+ * filter rules with pf */
+/*#define PF_ENABLE_FILTER_RULES*/
+
+/* Uncomment the following line to enable caching of results of
+ * the getifstats() function */
+/*#define ENABLE_GETIFSTATS_CACHING*/
+/* The cache duration is indicated in seconds */
+#define GETIFSTATS_CACHING_DURATION 2
+
+/* Uncomment the following line to enable multiple external ip support */
+/* note : That is EXPERIMENTAL, do not use that unless you know perfectly what you are doing */
+/* Dynamic external ip adresses are not supported when this option is enabled.
+ * Also note that you would need to configure your .conf file accordingly. */
+/*#define MULTIPLE_EXTERNAL_IP*/
+
+/* Comment the following line to use home made daemonize() func instead
+ * of BSD daemon() */
+#define USE_DAEMON
+
+/* Uncomment the following line to enable lease file support */
+/*#define ENABLE_LEASEFILE*/
+
+/* Uncomment the following line to enable port in use check */
+/*#define CHECK_PORTINUSE*/
+
+/* Define one or none of the two following macros in order to make some
+ * clients happy. It will change the XML Root Description of the IGD.
+ * Enabling the Layer3Forwarding Service seems to be the more compatible
+ * option. */
+/*#define HAS_DUMMY_SERVICE*/
+#define ENABLE_L3F_SERVICE
+
+/* Enable IP v6 support */
+/*#define ENABLE_IPV6*/
+
+/* Define V6SOCKETS_ARE_V6ONLY if AF_INET6 sockets are restricted
+ * to IPv6 communications only. */
+/*#define V6SOCKETS_ARE_V6ONLY*/
+
+/* Enable the support of IGD v2 specification.
+ * This is not fully tested yet and can cause incompatibilities with some
+ * control points, so enable with care. */
+/*#define IGD_V2*/
+
+#ifdef IGD_V2
+/* Enable DeviceProtection service (IGDv2) */
+#define ENABLE_DP_SERVICE
+/*#define ENABLE_HTTPS*/
+/*#define HTTPS_CERTFILE "/path/to/certificate.pem"*/
+/*#define HTTPS_KEYFILE "/path/to/private.key"*/
+
+/* Enable WANIPv6FirewallControl service (IGDv2). needs IPv6 */
+#ifdef ENABLE_IPV6
+#define ENABLE_6FC_SERVICE
+#endif /* ENABLE_IPV6 */
+#endif /* IGD_V2 */
+
+/* UPnP Events support. Working well enough to be enabled by default.
+ * It can be disabled to save a few bytes. */
+#define ENABLE_EVENTS
+
+/* include interface name in pf and ipf rules */
+#define USE_IFNAME_IN_RULES
+
+/* Experimental NFQUEUE support. */
+/*#define ENABLE_NFQUEUE*/
+
+/* Enable to make MiniUPnPd more strict about UPnP conformance
+ * and the messages it receives from control points */
+#define UPNP_STRICT
+
+/* If SSDP_RESPOND_SAME_VERSION is defined, the M-SEARCH response
+ * include the same device version as was contained in the search
+ * request. It conforms to UPnP DA v1.1 */
+#define SSDP_RESPOND_SAME_VERSION
+
+/* Add the optional Date: header in all HTTP responses */
+#define ENABLE_HTTP_DATE
+
+/* Wait a little before answering M-SEARCH request */
+/*#define DELAY_MSEARCH_RESPONSE*/
+
+/* disable reading and parsing of config file (miniupnpd.conf) */
+/*#define DISABLE_CONFIG_FILE*/
+
+/* Uncomment the following line to configure all manufacturer infos through miniupnpd.conf */
+#define ENABLE_MANUFACTURER_INFO_CONFIGURATION
+
+#if defined(ENABLE_6FC_SERVICE) || (defined(ENABLE_PCP) && defined(ENABLE_IPV6))
+#define ENABLE_UPNPPINHOLE
+#endif
+
+/* Enable QCMAP */
+#define QCMAP
+
+#endif /* CONFIG_H_INCLUDED */
diff --git a/getifstats.h b/getifstats.h
old mode 100644
new mode 100755
index e14b853..cecaa49
--- a/getifstats.h
+++ b/getifstats.h
@@ -7,12 +7,18 @@
 #ifndef GETIFSTATS_H_INCLUDED
 #define GETIFSTATS_H_INCLUDED
 
+#include "config.h"
+
 struct ifdata {
 	unsigned long opackets;
 	unsigned long ipackets;
 	unsigned long obytes;
 	unsigned long ibytes;
 	unsigned long baudrate;
+#ifdef QCMAP
+	unsigned long upstream_bitrate;
+	unsigned long downstream_bitrate;
+#endif
 };
 
 /* getifstats()
diff --git a/linux/miniupnpd.init.d.script b/linux/miniupnpd.init.d.script
old mode 100644
new mode 100755
index ee6e47b..b29c249
--- a/linux/miniupnpd.init.d.script
+++ b/linux/miniupnpd.init.d.script
@@ -18,33 +18,18 @@ set -e
 MINIUPNPD=/usr/sbin/miniupnpd
 ARGS='-f /etc/miniupnpd/miniupnpd.conf'
 
-IPTABLES_CREATE=/etc/miniupnpd/iptables_init.sh
-IPTABLES_REMOVE=/etc/miniupnpd/iptables_removeall.sh
-
 test -f $MINIUPNPD || exit 0
 
-. /lib/lsb/init-functions
-
 case "$1" in
   start)
-	log_daemon_msg "Starting miniupnpd" "miniupnpd"
-	$IPTABLES_CREATE > /dev/null 2>&1
 	start-stop-daemon --start --quiet --pidfile /var/run/miniupnpd.pid --startas $MINIUPNPD -- $ARGS $LSBNAMES
-	log_end_msg $?
 	;;
   stop)
-	log_daemon_msg "Stopping miniupnpd" "miniupnpd"
 	start-stop-daemon --stop --quiet --pidfile /var/run/miniupnpd.pid
-	log_end_msg $?
-	$IPTABLES_REMOVE > /dev/null 2>&1
 	;;
   restart|reload|force-reload)
-	log_daemon_msg "Restarting miniupnpd" "miniupnpd"
 	start-stop-daemon --stop --retry 5 --quiet --pidfile /var/run/miniupnpd.pid
-	$IPTABLES_REMOVE > /dev/null 2>&1
-	$IPTABLES_CREATE > /dev/null 2>&1
 	start-stop-daemon --start --quiet --pidfile /var/run/miniupnpd.pid --startas $MINIUPNPD -- $ARGS $LSBNAMES
-	log_end_msg $?
 	;;
   status)
 	status_of_proc /usr/sbin/miniupnpd miniupnpd
diff --git a/miniupnpd.c b/miniupnpd.c
old mode 100644
new mode 100755
index e22ba13..991011a
--- a/miniupnpd.c
+++ b/miniupnpd.c
@@ -1347,7 +1347,11 @@ init(int argc, char * * argv, struct runtime_vars * v)
 			fprintf(stderr, "Unknown option: %s\n", argv[i]);
 		}
 	}
-	if(!ext_if_name || !lan_addrs.lh_first)
+	if(
+#ifndef QCMAP
+           !ext_if_name ||
+#endif
+           !lan_addrs.lh_first)
 	{
 		/* bad configuration */
 		goto print_usage;
@@ -1433,9 +1437,15 @@ init(int argc, char * * argv, struct runtime_vars * v)
 	srandom((unsigned int)time(NULL));
 
 	/* initialize redirection engine (and pinholes) */
+#ifndef QCMAP
 	if(init_redirect() < 0)
 	{
 		syslog(LOG_ERR, "Failed to init redirection engine. EXITING");
+#else
+	if(!QCMAPClient())
+	{
+		syslog(LOG_ERR, "Failed to init QCMAP. EXITING");
+#endif
 		return 1;
 	}
 #ifdef ENABLE_UPNPPINHOLE
@@ -1623,7 +1633,11 @@ main(int argc, char * * argv)
 		return 0;
 	}
 
+#ifndef QCMAP
 	syslog(LOG_INFO, "Starting%s%swith external interface %s",
+#else
+	syslog(LOG_INFO, "Starting%s%swith external interface",
+#endif
 #ifdef ENABLE_NATPMP
 #ifdef ENABLE_PCP
 	       GETFLAG(ENABLENATPMPMASK) ? " NAT-PMP/PCP " : " ",
@@ -1633,8 +1647,12 @@ main(int argc, char * * argv)
 #else
 	       " ",
 #endif
-	       GETFLAG(ENABLEUPNPMASK) ? "UPnP-IGD " : "",
-	       ext_if_name);
+	       GETFLAG(ENABLEUPNPMASK) ? "UPnP-IGD " : ""
+#ifndef QCMAP
+               ,ext_if_name);
+#else
+               );
+#endif
 
 	if(GETFLAG(ENABLEUPNPMASK))
 	{
@@ -2279,6 +2297,7 @@ main(int argc, char * * argv)
 
 shutdown:
 	syslog(LOG_NOTICE, "shutting down MiniUPnPd");
+
 	/* send good-bye */
 	if (GETFLAG(ENABLEUPNPMASK))
 	{
@@ -2294,6 +2313,14 @@ shutdown:
 	/* try to send pending packets */
 	finalize_sendto();
 
+#ifdef QCMAP
+        /* Tear Down QCMap Client */
+	if(!tearDownQCMAPClient())
+	{
+		syslog(LOG_ERR, "Unable to tear down QCMAP Client");
+	}
+#endif
+
 	/* close out open sockets */
 	while(upnphttphead.lh_first != NULL)
 	{
diff --git a/miniupnpd.conf b/miniupnpd.conf
old mode 100644
new mode 100755
index 466abd6..871ccb3
--- a/miniupnpd.conf
+++ b/miniupnpd.conf
@@ -1,5 +1,5 @@
 # WAN network interface
-ext_ifname=eth1
+#ext_ifname=eth1
 #ext_ifname=xl1
 # if the WAN interface has several IP addresses, you
 # can specify the one to use below
@@ -15,8 +15,8 @@ ext_ifname=eth1
 # address associated with the subnet follows. for example :
 #  listening_ip=192.168.0.1/24 88.22.44.13
 #listening_ip=192.168.0.1/24
-listening_ip=192.168.10.109/24
-#listening_ip=eth0
+listening_ip=bridge0
+listening_ip=ppp0
 # port for HTTP (descriptions and SOAP) traffic. set 0 for autoselect.
 http_port=0
 # port for HTTPS. set to 0 for autoselect (default)
@@ -50,7 +50,7 @@ max_lifetime=86400
 # ENABLE_MANUFACTURER_INFO_CONFIGURATION (config.h)
 
 # name of this service, default is "`uname -s` router"
-#friendly_name=MiniUPnPd router
+friendly_name=9x35 MobileAP UPnP
 
 # manufacturer name, default is "`uname -s`"
 #manufacturer_name=Manufacturer corp
@@ -80,7 +80,7 @@ secure_mode=no
 # If set to an empty string, no presentationURL element will appear
 # in the XML description of the device, which prevents MS Windows
 # from displaying an icon in the "Network Connections" panel.
-#presentation_url=http://www.mylan/index.php
+presentation_url=/192.168.225.1:8201
 
 # report system uptime instead of daemon uptime
 system_uptime=yes
@@ -130,9 +130,9 @@ model_number=1
 # ip/mask format must be nn.nn.nn.nn/nn
 # it is advised to only allow redirection of port above 1024
 # and to finish the rule set with "deny 0-65535 0.0.0.0/0 0-65535"
-allow 1024-65535 192.168.0.0/24 1024-65535
-allow 1024-65535 192.168.1.0/24 1024-65535
-allow 1024-65535 192.168.0.0/23 22
-allow 12345 192.168.7.113/32 54321
-deny 0-65535 0.0.0.0/0 0-65535
+#allow 1024-65535 192.168.0.0/24 0-65535
+#allow 1024-65535 192.168.1.0/24 1024-65535
+#allow 1024-65535 192.168.0.0/23 22
+#allow 12345 192.168.7.113/32 54321
+allow 0-65535 0.0.0.0/0 0-65535
 
diff --git a/natpmp.c b/natpmp.c
old mode 100644
new mode 100755
index 2fd9ed5..4ea63ef
--- a/natpmp.c
+++ b/natpmp.c
@@ -314,6 +314,7 @@ void ProcessIncomingNATPMPPacket(int s, unsigned char *msg_buff, int len,
 				/* remove the mapping */
 				if(iport == 0) {
 					/* remove all the mappings for this client */
+#ifndef QCMAP
 					int index = 0;
 					unsigned short eport2, iport2;
 					char iaddr2[16];
@@ -341,6 +342,7 @@ void ProcessIncomingNATPMPPacket(int s, unsigned char *msg_buff, int len,
 							index++;
 						}
 					}
+#endif
 				} else {
 					/* To improve the interworking between nat-pmp and
 					 * UPnP, we should check that we remove only NAT-PMP
@@ -390,10 +392,14 @@ void ProcessIncomingNATPMPPacket(int s, unsigned char *msg_buff, int len,
 						continue;
 					}
 #endif
+#ifndef QCMAP
 					r = get_redirect_rule(ext_if_name, eport, proto,
 					                      iaddr_old, sizeof(iaddr_old),
 					                      &iport_old, 0, 0, 0, 0,
 					                      &timestamp, 0, 0);
+#else
+					r=0;
+#endif
 					if(r==0) {
 						if(strcmp(senderaddrstr, iaddr_old)==0
 						    && iport==iport_old) {
@@ -422,7 +428,11 @@ void ProcessIncomingNATPMPPacket(int s, unsigned char *msg_buff, int len,
 					         eport, (proto==IPPROTO_TCP)?"tcp":"udp");
 #endif
 					/* TODO : check return code */
-					if(upnp_redirect_internal(NULL, eport, senderaddrstr,
+					if(upnp_redirect_internal(
+#ifndef QCMAP
+                                                                  NULL,
+#endif 
+                                                                  eport, senderaddrstr,
 					                          iport, proto, desc,
 					                          timestamp) < 0) {
 						syslog(LOG_ERR, "Failed to add NAT-PMP %hu %s->%s:%hu '%s'",
diff --git a/pcpserver.c b/pcpserver.c
old mode 100644
new mode 100755
index e5f0cc6..392ea99
--- a/pcpserver.c
+++ b/pcpserver.c
@@ -962,13 +962,18 @@ static int CreatePCPMap_NAT(pcp_info_t *pcp_msg_info)
 			continue;
 		}
 #endif
+#ifndef QCMAP
 		r = get_redirect_rule(ext_if_name,
 				      pcp_msg_info->ext_port,
 				      pcp_msg_info->protocol,
 				      iaddr_old, sizeof(iaddr_old),
 				      &iport_old, 0, 0, 0, 0,
 				      &timestamp, 0, 0);
-
+#else
+		r = getSpecificEntry( pcp_msg_info->ext_port, pcp_msg_info->protocol,
+	                      iaddr_old, sizeof(iaddr_old), &iport_old,
+	                      0, 0, &timestamp);
+#endif
 		if(r==0) {
 			if((strcmp(pcp_msg_info->mapped_str, iaddr_old)!=0)
 			   || (pcp_msg_info->int_port != iport_old)) {
@@ -995,7 +1000,10 @@ static int CreatePCPMap_NAT(pcp_info_t *pcp_msg_info)
 		}
 	} while (r==0);
 
-	r = upnp_redirect_internal(NULL,
+	r = upnp_redirect_internal(
+#ifndef QCMAP
+				   NULL,
+#endif
 				   pcp_msg_info->ext_port,
 				   pcp_msg_info->mapped_str,
 				   pcp_msg_info->int_port,
@@ -1093,11 +1101,16 @@ static void DeletePCPMap(pcp_info_t *pcp_msg_info)
 	/* iterate through all rules and delete the requested ones */
 	for (index = 0 ;
 	     (!pcp_msg_info->is_fw &&
+#ifndef QCMAP
 	      get_redirect_rule_by_index(index, 0,
 					 &eport2, iaddr2, sizeof(iaddr2),
 					 &iport2, &proto2,
 					 desc, sizeof(desc),
-					 0, 0, &timestamp, 0, 0) >= 0)
+					 0, 0, &timestamp, 0, 0)
+#else
+	     getStaticNatConfigByEntry(index, iaddr2, sizeof(iaddr2), &eport2, &iport2, &proto2)
+#endif
+	     >= 0)
 #ifdef ENABLE_UPNPPINHOLE
 	       ||
 	     (pcp_msg_info->is_fw &&
diff --git a/upnpredirect.c b/upnpredirect.c
old mode 100644
new mode 100755
index b3d9a65..2c9890f
--- a/upnpredirect.c
+++ b/upnpredirect.c
@@ -43,6 +43,9 @@
 #ifdef ENABLE_LEASEFILE
 #include <sys/stat.h>
 #endif
+#ifdef QCMAP
+#include "netfilter/iptcrdr.c"
+#endif
 
 /* from <inttypes.h> */
 #ifndef PRIu64
@@ -256,7 +259,11 @@ int reload_from_lease_file()
  *          -3 permission check failed
  */
 int
+#ifndef QCMAP
 upnp_redirect(const char * rhost, unsigned short eport,
+#else
+upnp_redirect(/*const char * rhost,*/unsigned short eport,
+#endif
               const char * iaddr, unsigned short iport,
               const char * protocol, const char * desc,
               unsigned int leaseduration)
@@ -279,6 +286,7 @@ upnp_redirect(const char * rhost, unsigned short eport,
 		                 "%hu->%s:%hu %s", eport, iaddr, iport, protocol);
 		return -3;
 	}
+#ifndef QCMAP
 	r = get_redirect_rule(ext_if_name, eport, proto,
 	                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,
 	                      0, 0,
@@ -302,32 +310,44 @@ upnp_redirect(const char * rhost, unsigned short eport,
 		return -2;
 #endif /* CHECK_PORTINUSE */
 	} else {
+#endif
 		timestamp = (leaseduration > 0) ? time(NULL) + leaseduration : 0;
 		syslog(LOG_INFO, "redirecting port %hu to %s:%hu protocol %s for: %s",
 			eport, iaddr, iport, protocol, desc);
+#ifdef QCMAP
+	return upnp_redirect_internal(eport, iaddr, iport, proto, desc, timestamp);
+#else
 		return upnp_redirect_internal(rhost, eport, iaddr, iport, proto,
 		                              desc, timestamp);
 	}
+#endif
 
 	return 0;
 }
 
 int
-upnp_redirect_internal(const char * rhost, unsigned short eport,
+upnp_redirect_internal(
+#ifndef QCMAP
+                       const char * rhost,
+#endif
+                       unsigned short eport,
                        const char * iaddr, unsigned short iport,
                        int proto, const char * desc,
                        unsigned int timestamp)
 {
+#ifndef QCMAP
 	/*syslog(LOG_INFO, "redirecting port %hu to %s:%hu protocol %s for: %s",
 		eport, iaddr, iport, protocol, desc);			*/
 	if(add_redirect_rule2(ext_if_name, rhost, eport, iaddr, iport, proto,
 	                      desc, timestamp) < 0) {
 		return -1;
 	}
+#endif
 
 #ifdef ENABLE_LEASEFILE
 	lease_file_add( eport, iaddr, iport, proto, desc, timestamp);
 #endif
+#ifndef QCMAP
 /*	syslog(LOG_INFO, "creating pass rule to %s:%hu protocol %s for: %s",
 		iaddr, iport, protocol, desc);*/
 	if(add_filter_rule2(ext_if_name, rhost, iaddr, eport, iport, proto, desc) < 0) {
@@ -335,8 +355,21 @@ upnp_redirect_internal(const char * rhost, unsigned short eport,
 #if !defined(__linux__)
 		delete_redirect_rule(ext_if_name, eport, proto);
 #endif
+#else
+	struct in_addr address;
+
+	if(inet_aton(iaddr, &address) < 0) {
+		syslog(LOG_ERR, "inet_aton(%s) : %m", iaddr);
 		return -1;
 	}
+        if(addStaticNatEntry_wrapper(address, proto, iport, eport) < 0)
+                return -1;
+	add_redirect_desc(eport, proto, desc, timestamp);
+#endif
+#ifndef QCMAP
+		return -1;
+	}
+#endif
 	if(timestamp > 0) {
 		if(!nextruletoclean_timestamp || (timestamp < nextruletoclean_timestamp))
 			nextruletoclean_timestamp = timestamp;
@@ -368,17 +401,30 @@ upnp_get_redirection_infos(unsigned short eport, const char * protocol,
 		desc[0] = '\0';
 	if(rhost && (rhostlen > 0))
 		rhost[0] = '\0';
+#ifndef QCMAP
 	r = get_redirect_rule(ext_if_name, eport, proto_atoi(protocol),
 	                      iaddr, iaddrlen, iport, desc, desclen,
 	                      rhost, rhostlen, &timestamp,
 	                      0, 0);
 	if(r == 0 &&
 	   timestamp > 0 &&
+#else
+	r = getSpecificEntry( eport, proto_atoi(protocol),
+	                      iaddr, iaddrlen, iport,
+	                      rhost, rhostlen, &timestamp);
+	if (r == 0) {
+		get_redirect_desc(eport, proto_atoi(protocol), desc, desclen, &timestamp);
+
+		if(timestamp > 0 &&
+#endif
 	   timestamp > (unsigned int)(current_time = time(NULL))) {
 		*leaseduration = timestamp - current_time;
 	} else {
 		*leaseduration = 0;
 	}
+#ifdef QCMAP
+        }
+#endif
 	return r;
 }
 
@@ -400,13 +446,20 @@ upnp_get_redirection_infos_by_index(int index,
 		desc[0] = '\0';
 	if(rhost && (rhostlen > 0))
 		rhost[0] = '\0';
+#ifndef QCMAP
 	if(get_redirect_rule_by_index(index, 0/*ifname*/, eport, iaddr, iaddrlen,
 	                              iport, &proto, desc, desclen,
 	                              rhost, rhostlen, &timestamp,
 	                              0, 0) < 0)
+#else
+	if (getStaticNatConfigByEntry(index, iaddr, iaddrlen, eport, iport, &proto) < 0)
+#endif
 		return -1;
 	else
 	{
+#ifdef QCMAP
+		get_redirect_desc(*eport, proto, desc, desclen, &timestamp);
+#endif
 		current_time = time(NULL);
 		*leaseduration = (timestamp > (unsigned int)current_time)
 		                 ? (timestamp - current_time)
@@ -425,7 +478,11 @@ _upnp_delete_redir(unsigned short eport, int proto)
 {
 	int r;
 #if defined(__linux__)
+#ifndef QCMAP
 	r = delete_redirect_and_filter_rules(eport, proto);
+#else
+	r = deleteStaticNatEntry_wrapper( eport, proto);
+#endif
 #elif defined(USE_PF)
 	r = delete_redirect_and_filter_rules(ext_if_name, eport, proto);
 #else
@@ -439,6 +496,10 @@ _upnp_delete_redir(unsigned short eport, int proto)
 #ifdef ENABLE_EVENTS
 	upnp_event_var_change_notify(EWanIPC);
 #endif
+#ifdef QCMAP
+	if ( r >= 0 )
+		del_redirect_desc(eport, proto);
+#endif
 	return r;
 }
 
@@ -491,11 +552,18 @@ get_upnp_rules_state_list(int max_rules_number_target)
 		return 0;
 	current_time = time(NULL);
 	nextruletoclean_timestamp = 0;
+#ifndef QCMAP
 	while(get_redirect_rule_by_index(i, /*ifname*/0, &tmp->eport, 0, 0,
 	                              &iport, &proto, 0, 0, 0,0, &timestamp,
 								  &tmp->packets, &tmp->bytes) >= 0)
+#else
+	while(getStaticNatConfigByEntry(i, 0, 0, &tmp->eport, &iport, &proto) >= 0)
+#endif
 	{
 		tmp->to_remove = 0;
+#ifdef QCMAP
+		get_redirect_desc(tmp->eport, proto, 0, 0, &timestamp);
+#endif
 		if(timestamp > 0) {
 			/* need to remove this port mapping ? */
 			if(timestamp <= (unsigned int)current_time)
@@ -582,6 +650,7 @@ remove_unused_rules(struct rule_state * list)
 	while(list)
 	{
 		/* remove the rule if no traffic has used it */
+#ifndef QCMAP
 		if(get_redirect_rule(ifname, list->eport, list->proto,
 	                         0, 0, &iport, 0, 0, 0, 0, &timestamp,
 		                     &packets, &bytes) >= 0)
@@ -592,6 +661,7 @@ remove_unused_rules(struct rule_state * list)
 				n++;
 			}
 		}
+#endif
 		tmp = list;
 		list = tmp->next;
 		free(tmp);
@@ -604,8 +674,11 @@ remove_unused_rules(struct rule_state * list)
  * return a list of all "external" ports for which a port
  * mapping exists */
 unsigned short *
-upnp_get_portmappings_in_range(unsigned short startport,
+upnp_get_portmappings_in_range(
+#ifndef QCMAP
+                               unsigned short startport,
                                unsigned short endport,
+#endif
                                const char * protocol,
                                unsigned int * number)
 {
@@ -613,7 +686,11 @@ upnp_get_portmappings_in_range(unsigned short startport,
 	proto = proto_atoi(protocol);
 	if(!number)
 		return NULL;
+#ifndef QCMAP
 	return get_portmappings_in_range(startport, endport, proto, number);
+#else
+	return NULL;
+#endif
 }
 
 /* stuff for miniupnpdctl */
diff --git a/upnpredirect.h b/upnpredirect.h
old mode 100644
new mode 100755
index b549824..311abba
--- a/upnpredirect.h
+++ b/upnpredirect.h
@@ -26,7 +26,11 @@ int reload_from_lease_file(void);
  *          -3 permission check failed
  */
 int
-upnp_redirect(const char * rhost, unsigned short eport,
+upnp_redirect(
+#ifndef QCMAP
+              const char * rhost,
+#endif
+              unsigned short eport,
               const char * iaddr, unsigned short iport,
               const char * protocol, const char * desc,
               unsigned int leaseduration);
@@ -34,7 +38,11 @@ upnp_redirect(const char * rhost, unsigned short eport,
 /* upnp_redirect_internal()
  * same as upnp_redirect() without any check */
 int
-upnp_redirect_internal(const char * rhost, unsigned short eport,
+upnp_redirect_internal(
+#ifndef QCMAP
+                       const char * rhost,
+#endif
+                       unsigned short eport,
                        const char * iaddr, unsigned short iport,
                        int proto, const char * desc,
                        unsigned int timestamp);
@@ -103,8 +111,11 @@ remove_unused_rules(struct rule_state * list);
  * return a list of all "external" ports for which a port
  * mapping exists */
 unsigned short *
-upnp_get_portmappings_in_range(unsigned short startport,
+upnp_get_portmappings_in_range(
+#ifndef QCMAP
+                               unsigned short startport,
                                unsigned short endport,
+#endif
                                const char * protocol,
                                unsigned int * number);
 
diff --git a/upnpsoap.c b/upnpsoap.c
old mode 100644
new mode 100755
index dd5e069..6255bc3
--- a/upnpsoap.c
+++ b/upnpsoap.c
@@ -88,8 +88,11 @@ GetTotalBytesSent(struct upnphttp * h, const char * action)
 	char body[512];
 	int bodylen;
 	struct ifdata data;
-
+#ifndef QCMAP
 	r = getifstats(ext_if_name, &data);
+#else
+	r = getIfaceStats(&data);
+#endif
 	bodylen = snprintf(body, sizeof(body), resp,
 	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
              r<0?0:data.obytes, action);
@@ -110,8 +113,11 @@ GetTotalBytesReceived(struct upnphttp * h, const char * action)
 	char body[512];
 	int bodylen;
 	struct ifdata data;
-
+#ifndef QCMAP
 	r = getifstats(ext_if_name, &data);
+#else
+	r = getIfaceStats(&data);
+#endif
 	bodylen = snprintf(body, sizeof(body), resp,
 	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
 	         r<0?0:data.ibytes, action);
@@ -132,8 +138,11 @@ GetTotalPacketsSent(struct upnphttp * h, const char * action)
 	char body[512];
 	int bodylen;
 	struct ifdata data;
-
+#ifndef QCMAP
 	r = getifstats(ext_if_name, &data);
+#else
+	r = getIfaceStats(&data);
+#endif
 	bodylen = snprintf(body, sizeof(body), resp,
 	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
 	         r<0?0:data.opackets, action);
@@ -154,8 +163,11 @@ GetTotalPacketsReceived(struct upnphttp * h, const char * action)
 	char body[512];
 	int bodylen;
 	struct ifdata data;
-
+#ifndef QCMAP
 	r = getifstats(ext_if_name, &data);
+#else
+	r = getIfaceStats(&data);
+#endif
 	bodylen = snprintf(body, sizeof(body), resp,
 	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
 	         r<0?0:data.ipackets, action);
@@ -184,6 +196,7 @@ GetCommonLinkProperties(struct upnphttp * h, const char * action)
 	                             * Initializing, Unavailable (Optional) */
 	char ext_ip_addr[INET_ADDRSTRLEN];
 
+#ifndef QCMAP
 	if((downstream_bitrate == 0) || (upstream_bitrate == 0))
 	{
 		if(getifstats(ext_if_name, &data) >= 0)
@@ -193,6 +206,19 @@ GetCommonLinkProperties(struct upnphttp * h, const char * action)
 		}
 	}
 	if(getifaddr(ext_if_name, ext_ip_addr, INET_ADDRSTRLEN, NULL, NULL) < 0) {
+#else
+	if(getIfaceStats(&data) >= 0)
+	{
+		downstream_bitrate = data.downstream_bitrate;
+		upstream_bitrate = data.upstream_bitrate;
+	}
+	else
+	{
+		downstream_bitrate = 0;
+		upstream_bitrate = 0;
+	}
+	if(getIPAddr(ext_ip_addr, INET_ADDRSTRLEN) < 0) {
+#endif
 		status = "Down";
 	}
 	bodylen = snprintf(body, sizeof(body), resp,
@@ -220,8 +246,11 @@ GetStatusInfo(struct upnphttp * h, const char * action)
 	/* ConnectionStatus possible values :
 	 * Unconfigured, Connecting, Connected, PendingDisconnect,
 	 * Disconnecting, Disconnected */
-
+#ifndef QCMAP
 	status = get_wan_connection_status_str(ext_if_name);
+#else
+	status = getWanStatusStr();
+#endif
 	uptime = (time(NULL) - startup_time);
 	bodylen = snprintf(body, sizeof(body), resp,
 		action, SERVICE_TYPE_WANIPC,
@@ -270,10 +299,16 @@ GetExternalIPAddress(struct upnphttp * h, const char * action)
 	{
 		strncpy(ext_ip_addr, use_ext_ip_addr, INET_ADDRSTRLEN);
 	}
+#ifndef QCMAP
 	else if(getifaddr(ext_if_name, ext_ip_addr, INET_ADDRSTRLEN, NULL, NULL) < 0)
 	{
 		syslog(LOG_ERR, "Failed to get ip address for interface %s",
 			ext_if_name);
+#else
+	else if(getIPAddr(ext_ip_addr, INET_ADDRSTRLEN) < 0)
+	{
+		syslog(LOG_ERR, "Failed to get ip address for interface");
+#endif
 		strncpy(ext_ip_addr, "0.0.0.0", INET_ADDRSTRLEN);
 	}
 #else
@@ -418,7 +453,11 @@ AddPortMapping(struct upnphttp * h, const char * action)
 	PortMappingDescription, PortMappingEnabled and PortMappingLeaseDuration are
 	overwritten.
 	*/
-	r = upnp_redirect(r_host, eport, int_ip, iport, protocol, desc, leaseduration);
+	r = upnp_redirect(
+#ifndef QCMAP
+                          r_host,
+#endif
+                          eport, int_ip, iport, protocol, desc, leaseduration);
 
 	ClearNameValueList(&data);
 
@@ -554,7 +593,11 @@ AddAnyPortMapping(struct upnphttp * h, const char * action)
 	/* TODO : accept a different external port
 	 * have some smart strategy to choose the port */
 	for(;;) {
-		r = upnp_redirect(r_host, eport, int_ip, iport, protocol, desc, leaseduration);
+	                  r = upnp_redirect(
+#ifndef QCMAP
+                          r_host,
+#endif
+                          eport, int_ip, iport, protocol, desc, leaseduration);
 		if(r==-2 && eport < 65535) {
 			eport++;
 		} else {
@@ -775,7 +818,10 @@ DeletePortMappingRange(struct upnphttp * h, const char * action)
 	syslog(LOG_INFO, "%s: deleting external ports: %hu-%hu, protocol: %s",
 	       action, startport, endport, protocol);
 
-	port_list = upnp_get_portmappings_in_range(startport, endport,
+	port_list = upnp_get_portmappings_in_range(
+#ifndef QCMAP
+                                                   startport, endport,
+#endif
 	                                           protocol, &number);
 	if(number == 0)
 	{
@@ -993,7 +1039,10 @@ http://www.upnp.org/schemas/gw/WANIPConnection-v2.xsd">
 	memcpy(body+bodylen, list_start, sizeof(list_start));
 	bodylen += (sizeof(list_start) - 1);
 
-	port_list = upnp_get_portmappings_in_range(startport, endport,
+	port_list = upnp_get_portmappings_in_range(
+#ifndef QCMAP
+                                                   startport, endport,
+#endif
 	                                           protocol, &list_size);
 	/* loop through port mappings */
 	for(i = 0; number > 0 && i < list_size; i++)
@@ -1124,16 +1173,63 @@ SetConnectionType(struct upnphttp * h, const char * action)
 static void
 RequestConnection(struct upnphttp * h, const char * action)
 {
+#ifndef QCMAP
 	UNUSED(action);
 	SoapError(h, 606, "Action not authorized");
+#else
+	static const char resp[] =
+		"<u:RequestConnectionResponse "
+		"xmlns:u=\"" SERVICE_TYPE_WANIPC "\">"
+		"</u:RequestConnectionResponse>";
+	if(getWanStatus() == 1)/* Connecting */
+	{
+		SoapError(h, 705, "ConnectionSetupInProgress");
+		return;
+	}
+	if(getWanStatus() == 4)/* Disconnecting */
+	{
+		SoapError(h, 707, "DisconnectInProgress");
+		return;
+	}
+	if(startConnection() < 0) {
+		SoapError(h, 501, "Action Failed");
+		return;
+	}
+
+	BuildSendAndCloseSoapResp(h, resp, sizeof(resp)-1);
+#endif
 }
 
 /* Added for compliance with WANIPConnection v2 */
 static void
 ForceTermination(struct upnphttp * h, const char * action)
 {
+#ifndef QCMAP
 	UNUSED(action);
 	SoapError(h, 606, "Action not authorized");
+#else
+	static const char resp[] =
+		"<u:ForceTerminationResponse "
+		"xmlns:u=\"" SERVICE_TYPE_WANIPC "\">"
+		"</u:ForceTerminationResponse>";
+
+	if(getWanStatus() == 4)/* Disconnecting */
+	{
+		SoapError(h, 707, "DisconnectInProgress");
+		return;
+	}
+	if(getWanStatus() == 5)/* Disconnected */
+	{
+		SoapError(h, 711, "ConnectionAlreadyTerminated");
+		return;
+	}
+	if(stopConnection() < 0) {
+		SoapError(h, 501, "Action Failed");
+		return;
+	}
+
+	BuildSendAndCloseSoapResp(h, resp, sizeof(resp)-1);
+#endif
 }
 
 /*
@@ -1172,8 +1268,11 @@ QueryStateVariable(struct upnphttp * h, const char * action)
 	else if(strcmp(var_name, "ConnectionStatus") == 0)
 	{
 		const char * status;
-
+#ifndef QCMAP
 		status = get_wan_connection_status_str(ext_if_name);
+#else
+		status = getWanStatusStr();
+#endif
 		bodylen = snprintf(body, sizeof(body), resp,
                            action, "urn:schemas-upnp-org:control-1-0",
 		                   status, action);
-- 
1.8.2.1

