From 799793d69697871b9e3f7022403d99c30caf75ff Mon Sep 17 00:00:00 2001
From: Tyler Wear <twear@codeaurora.org>
Date: Wed, 12 Jun 2013 18:33:09 -0700
Subject: [PATCH 1/1] certification-fixes

---
 config.h                      |  103 +++++++++++++++++++++++++++++++++++++++++
 getifstats.h                  |    6 ++
 linux/miniupnpd.init.d.script |   15 ------
 minissdp.c                    |  103 ++++++++++++++++++++++++----------------
 miniupnpd.c                   |   32 +++++++++++-
 miniupnpd.conf                |   25 +++++-----
 natpmp.c                      |   17 ++++++-
 upnpdescgen.c                 |   16 ++++++
 upnpredirect.c                |   77 +++++++++++++++++++++++++++++-
 upnpredirect.h                |   23 +++++++--
 upnpsoap.c                    |   72 ++++++++++++++++++++++++----
 11 files changed, 396 insertions(+), 93 deletions(-)
 create mode 100755 config.h
 mode change 100644 => 100755 getifstats.h
 mode change 100644 => 100755 linux/miniupnpd.init.d.script
 mode change 100644 => 100755 minissdp.c
 mode change 100644 => 100755 miniupnpd.c
 mode change 100644 => 100755 miniupnpd.conf
 mode change 100644 => 100755 natpmp.c
 mode change 100644 => 100755 upnpdescgen.c
 mode change 100644 => 100755 upnpredirect.c
 mode change 100644 => 100755 upnpredirect.h
 mode change 100644 => 100755 upnpreplyparse.c
 mode change 100644 => 100755 upnpreplyparse.h
 mode change 100644 => 100755 upnpsoap.c

diff --git a/config.h b/config.h
new file mode 100755
index 0000000..e31d95e
--- /dev/null
+++ b/config.h
@@ -0,0 +1,103 @@
+/* MiniUPnP Project
+ * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
+ * (c) 2006-2012 Thomas Bernard
+ * generated by ./genconfig.sh on Mon Dec 17 11:25:57 PST 2012
+ * using command line options  */
+#ifndef CONFIG_H_INCLUDED
+#define CONFIG_H_INCLUDED
+
+#include <inttypes.h>
+
+#define MINIUPNPD_VERSION "1.7"
+
+#define UPNP_VERSION	"20121217"
+#define USE_IFACEWATCHER 1
+#define USE_NETFILTER 0
+#define SUPPORT_REMOTEHOST
+
+#define OS_NAME		"Ubuntu"
+#define OS_VERSION	"Ubuntu/lucid"
+#define OS_URL		"http://www.ubuntu.com/"
+
+/* syslog facility to be used by miniupnpd */
+#define LOG_MINIUPNPD		 LOG_DAEMON
+
+/* Uncomment the following line to allow miniupnpd to be
+ * controlled by miniupnpdctl */
+/*#define USE_MINIUPNPDCTL*/
+
+/* Comment the following line to disable NAT-PMP operations */
+#define ENABLE_NATPMP
+
+/* Uncomment the following line to enable generation of
+ * filter rules with pf */
+/*#define PF_ENABLE_FILTER_RULES*/
+
+/* Uncomment the following line to enable caching of results of
+ * the getifstats() function */
+/*#define ENABLE_GETIFSTATS_CACHING*/
+/* The cache duration is indicated in seconds */
+#define GETIFSTATS_CACHING_DURATION 2
+
+/* Uncomment the following line to enable multiple external ip support */
+/* note : That is EXPERIMENTAL, do not use that unless you know perfectly what you are doing */
+/* Dynamic external ip adresses are not supported when this option is enabled.
+ * Also note that you would need to configure your .conf file accordingly. */
+/*#define MULTIPLE_EXTERNAL_IP*/
+
+/* Comment the following line to use home made daemonize() func instead
+ * of BSD daemon() */
+#define USE_DAEMON
+
+/* Uncomment the following line to enable lease file support */
+/*#define ENABLE_LEASEFILE*/
+
+/* Define one or none of the two following macros in order to make some
+ * clients happy. It will change the XML Root Description of the IGD.
+ * Enabling the Layer3Forwarding Service seems to be the more compatible
+ * option. */
+/*#define HAS_DUMMY_SERVICE*/
+#define ENABLE_L3F_SERVICE
+
+/* Enable IP v6 support */
+/*#define ENABLE_IPV6*/
+
+/* Enable the support of IGD v2 specification.
+ * This is not fully tested yet and can cause incompatibilities with some
+ * control points, so enable with care. */
+/*#define IGD_V2*/
+
+#ifdef IGD_V2
+/* Enable DeviceProtection service (IGDv2) */
+#define ENABLE_DP_SERVICE
+
+/* Enable WANIPv6FirewallControl service (IGDv2). needs IPv6 */
+#ifdef ENABLE_IPV6
+#define ENABLE_6FC_SERVICE
+#endif /* ENABLE_IPV6 */
+#endif /* IGD_V2 */
+
+/* UPnP Events support. Working well enough to be enabled by default.
+ * It can be disabled to save a few bytes. */
+#define ENABLE_EVENTS
+
+/* include interface name in pf and ipf rules */
+#define USE_IFNAME_IN_RULES
+
+/* Experimental NFQUEUE support. */
+/*#define ENABLE_NFQUEUE*/
+
+/* Enable to make MiniUPnPd more strict about UPnP conformance
+ * and the messages it receives from control points */
+#define UPNP_STRICT
+
+/* Add the optional Date: header in all HTTP responses */
+/*#define ENABLE_HTTP_DATE*/
+
+/* disable reading and parsing of config file (miniupnpd.conf) */
+/*#define DISABLE_CONFIG_FILE*/
+
+/* Enable QCMAP */
+#define QCMAP
+
+#endif
diff --git a/getifstats.h b/getifstats.h
old mode 100644
new mode 100755
index e14b853..cecaa49
--- a/getifstats.h
+++ b/getifstats.h
@@ -7,12 +7,18 @@
 #ifndef GETIFSTATS_H_INCLUDED
 #define GETIFSTATS_H_INCLUDED
 
+#include "config.h"
+
 struct ifdata {
 	unsigned long opackets;
 	unsigned long ipackets;
 	unsigned long obytes;
 	unsigned long ibytes;
 	unsigned long baudrate;
+#ifdef QCMAP
+	unsigned long upstream_bitrate;
+	unsigned long downstream_bitrate;
+#endif
 };
 
 /* getifstats()
diff --git a/linux/miniupnpd.init.d.script b/linux/miniupnpd.init.d.script
old mode 100644
new mode 100755
index ee6e47b..b29c249
--- a/linux/miniupnpd.init.d.script
+++ b/linux/miniupnpd.init.d.script
@@ -18,33 +18,18 @@ set -e
 MINIUPNPD=/usr/sbin/miniupnpd
 ARGS='-f /etc/miniupnpd/miniupnpd.conf'
 
-IPTABLES_CREATE=/etc/miniupnpd/iptables_init.sh
-IPTABLES_REMOVE=/etc/miniupnpd/iptables_removeall.sh
-
 test -f $MINIUPNPD || exit 0
 
-. /lib/lsb/init-functions
-
 case "$1" in
   start)
-	log_daemon_msg "Starting miniupnpd" "miniupnpd"
-	$IPTABLES_CREATE > /dev/null 2>&1
 	start-stop-daemon --start --quiet --pidfile /var/run/miniupnpd.pid --startas $MINIUPNPD -- $ARGS $LSBNAMES
-	log_end_msg $?
 	;;
   stop)
-	log_daemon_msg "Stopping miniupnpd" "miniupnpd"
 	start-stop-daemon --stop --quiet --pidfile /var/run/miniupnpd.pid
-	log_end_msg $?
-	$IPTABLES_REMOVE > /dev/null 2>&1
 	;;
   restart|reload|force-reload)
-	log_daemon_msg "Restarting miniupnpd" "miniupnpd"
 	start-stop-daemon --stop --retry 5 --quiet --pidfile /var/run/miniupnpd.pid
-	$IPTABLES_REMOVE > /dev/null 2>&1
-	$IPTABLES_CREATE > /dev/null 2>&1
 	start-stop-daemon --start --quiet --pidfile /var/run/miniupnpd.pid --startas $MINIUPNPD -- $ARGS $LSBNAMES
-	log_end_msg $?
 	;;
   status)
 	status_of_proc /usr/sbin/miniupnpd miniupnpd
diff --git a/minissdp.c b/minissdp.c
old mode 100644
new mode 100755
index 934d9ca..8645524
--- a/minissdp.c
+++ b/minissdp.c
@@ -484,6 +484,16 @@ SendSSDPNotify(int s, const struct sockaddr * dest,
 }
 
 static void
+_usleep(long usecs)
+{
+	struct timespec sleep_time;
+
+	sleep_time.tv_sec = 0;
+	sleep_time.tv_nsec = usecs * 1000;
+	nanosleep(&sleep_time, NULL);
+}
+
+static void
 SendSSDPNotifies(int s, const char * host, unsigned short port,
                  unsigned int lifetime, int ipv6)
 {
@@ -492,7 +502,7 @@ SendSSDPNotifies(int s, const char * host, unsigned short port,
 #else
 	struct sockaddr_in sockname;
 #endif
-	int i=0;
+	int dup, i=0;
 	char ver_str[4];
 
 	memset(&sockname, 0, sizeof(sockname));
@@ -513,22 +523,30 @@ SendSSDPNotifies(int s, const char * host, unsigned short port,
 		p->sin_addr.s_addr = inet_addr(SSDP_MCAST_ADDR);
 	}
 
-	while(known_service_types[i].s)
-	{
-		if(i==0)
-			ver_str[0] = '\0';
-		else
-			snprintf(ver_str, sizeof(ver_str), "%d", known_service_types[i].version);
-		SendSSDPNotify(s, (struct sockaddr *)&sockname, host, port,
-		               known_service_types[i].s, ver_str,	/* NT: */
-		               uuidvalue, "::", known_service_types[i].s, /* ver_str,	USN: */
-		               lifetime, ipv6);
-		if(i==0) /* rootdevice */
-			SendSSDPNotify(s, (struct sockaddr *)&sockname, host, port,
-			               uuidvalue, "",	/* NT: */
-			               uuidvalue, "", "", /* ver_str,	USN: */
-			               lifetime, ipv6);
-		i++;
+
+	for( dup=0; dup<2; dup++ )
+	{
+
+		if( dup )
+			_usleep(200000);
+		i=0;
+    	while(known_service_types[i].s)
+    	{
+    		if(i==0)
+    			ver_str[0] = '\0';
+    		else
+    			snprintf(ver_str, sizeof(ver_str), "%d", known_service_types[i].version);
+    		SendSSDPNotify(s, (struct sockaddr *)&sockname, host, port,
+    		               known_service_types[i].s, ver_str,	/* NT: */
+    		               uuidvalue, "::", known_service_types[i].s, /* ver_str,	USN: */
+    		               lifetime, ipv6);
+    		if(i==0) /* rootdevice */
+    			SendSSDPNotify(s, (struct sockaddr *)&sockname, host, port,
+    			               uuidvalue, "",	/* NT: */
+    			               uuidvalue, "", "", /* ver_str,	USN: */
+    			               lifetime, ipv6);
+    		i++;
+		}
 	}
 }
 
@@ -849,7 +867,7 @@ SendSSDPGoodbye(int * sockets, int n_sockets)
 #endif
 	int i, j;
 	char ver_str[4];
-	int ret = 0;
+	int dup, ret = 0;
 	int ipv6 = 0;
 
     memset(&sockname, 0, sizeof(struct sockaddr_in));
@@ -863,39 +881,42 @@ SendSSDPGoodbye(int * sockets, int n_sockets)
 	inet_pton(AF_INET6, LL_SSDP_MCAST_ADDR, &(sockname6.sin6_addr));
 #endif
 
-	for(j=0; j<n_sockets; j++)
+	for (dup = 0; dup < 2; dup++)
 	{
+		for(j=0; j<n_sockets; j++)
+		{
 #ifdef ENABLE_IPV6
-		ipv6 = j & 1;
+			ipv6 = j & 1;
 #endif
-	    for(i=0; known_service_types[i].s; i++)
-	    {
-			if(i==0)
-				ver_str[0] = '\0';
-			else
-				snprintf(ver_str, sizeof(ver_str), "%d", known_service_types[i].version);
-			ret += SendSSDPbyebye(sockets[j],
+			for(i=0; known_service_types[i].s; i++)
+			{
+				if(i==0)
+					ver_str[0] = '\0';
+				else
+					snprintf(ver_str, sizeof(ver_str), "%d", known_service_types[i].version);
+				ret += SendSSDPbyebye(sockets[j],
 #ifdef ENABLE_IPV6
-			                      ipv6 ? (struct sockaddr *)&sockname6 : (struct sockaddr *)&sockname,
+									  ipv6 ? (struct sockaddr *)&sockname6 : (struct sockaddr *)&sockname,
 #else
-			                      (struct sockaddr *)&sockname,
+									  (struct sockaddr *)&sockname,
 #endif
-			                      known_service_types[i].s, ver_str,	/* NT: */
-			                      uuidvalue, "::", known_service_types[i].s, /* ver_str, USN: */
-			                      ipv6);
-			if(i==0)	/* root device */
-			{
-				ret += SendSSDPbyebye(sockets[j],
+									  known_service_types[i].s, ver_str,	/* NT: */
+									  uuidvalue, "::", known_service_types[i].s, /* ver_str, USN: */
+									  ipv6);
+				if(i==0)	/* root device */
+				{
+					ret += SendSSDPbyebye(sockets[j],
 #ifdef ENABLE_IPV6
-				                      ipv6 ? (struct sockaddr *)&sockname6 : (struct sockaddr *)&sockname,
+										  ipv6 ? (struct sockaddr *)&sockname6 : (struct sockaddr *)&sockname,
 #else
-				                      (struct sockaddr *)&sockname,
+										  (struct sockaddr *)&sockname,
 #endif
-				                      uuidvalue, "",	/* NT: */
-				                      uuidvalue, "", "", /* ver_str, USN: */
-				                      ipv6);
+										  uuidvalue, "",	/* NT: */
+										  uuidvalue, "", "", /* ver_str, USN: */
+										  ipv6);
+				}
 			}
-    	}
+		}
 	}
 	return ret;
 }
diff --git a/miniupnpd.c b/miniupnpd.c
old mode 100644
new mode 100755
index 1dd3ff3..1243568
--- a/miniupnpd.c
+++ b/miniupnpd.c
@@ -1079,7 +1079,11 @@ init(int argc, char * * argv, struct runtime_vars * v)
 			fprintf(stderr, "Unknown option: %s\n", argv[i]);
 		}
 	}
-	if(!ext_if_name || !lan_addrs.lh_first)
+	if(
+#ifndef QCMAP
+           !ext_if_name ||
+#endif
+           !lan_addrs.lh_first)
 	{
 		/* bad configuration */
 		goto print_usage;
@@ -1161,9 +1165,15 @@ init(int argc, char * * argv, struct runtime_vars * v)
 		syslog(LOG_NOTICE, "Failed to set %s handler", "SIGUSR1");
 	}
 
+#ifndef QCMAP
 	if(init_redirect() < 0)
 	{
 		syslog(LOG_ERR, "Failed to init redirection engine. EXITING");
+#else
+	if(!QCMAPClient())
+	{
+		syslog(LOG_ERR, "Failed to init QCMAP. EXITING");
+#endif
 		return 1;
 	}
 #ifdef ENABLE_6FC_SERVICE
@@ -1329,14 +1339,22 @@ main(int argc, char * * argv)
 		return 0;
 	}
 
+#ifndef QCMAP
 	syslog(LOG_INFO, "Starting%s%swith external interface %s",
+#else
+	syslog(LOG_INFO, "Starting%s%swith external interface",
+#endif
 #ifdef ENABLE_NATPMP
 	       GETFLAG(ENABLENATPMPMASK) ? " NAT-PMP " : " ",
 #else
 	       " ",
 #endif
-	       GETFLAG(ENABLEUPNPMASK) ? "UPnP-IGD " : "",
-	       ext_if_name);
+	       GETFLAG(ENABLEUPNPMASK) ? "UPnP-IGD " : ""
+#ifndef QCMAP
+               ,ext_if_name);
+#else
+               );
+#endif
 
 	if(GETFLAG(ENABLEUPNPMASK))
 	{
@@ -1867,6 +1885,14 @@ main(int argc, char * * argv)
 	}	/* end of main loop */
 
 shutdown:
+#ifdef QCMAP
+        /* Tear Down QCMap Client */
+	if(!tearDownQCMAPClient())
+	{
+		syslog(LOG_ERR, "Unable to tear down QCMAP Client");
+	}
+#endif
+
 	/* close out open sockets */
 	while(upnphttphead.lh_first != NULL)
 	{
diff --git a/miniupnpd.conf b/miniupnpd.conf
old mode 100644
new mode 100755
index e34e088..058da75
--- a/miniupnpd.conf
+++ b/miniupnpd.conf
@@ -1,6 +1,6 @@
 # WAN network interface
-ext_ifname=eth1
-#ext_ifname=xl1
+#ext_ifname=eth1
+
 # if the WAN interface has several IP addresses, you
 # can specify the one to use below
 #ext_ip=
@@ -15,8 +15,7 @@ ext_ifname=eth1
 # address associated with the subnet follows. for example :
 #  listening_ip=192.168.0.1/24 88.22.44.13
 #listening_ip=192.168.0.1/24
-listening_ip=192.168.10.109/24
-#listening_ip=eth0
+listening_ip=bridge0
 # port for HTTP (descriptions and SOAP) traffic. set 0 for autoselect.
 port=0
 
@@ -40,11 +39,11 @@ enable_upnp=yes
 #lease_file=/var/log/upnp.leases
 
 # name of this service, default is "`uname -s` Router"
-#friendly_name=MiniUPnPd router
+friendly_name=9x25 MobileAP UPnP
 
 # bitrates reported by daemon in bits per second
-bitrate_up=1000000
-bitrate_down=10000000
+#bitrate_up=1000000
+#bitrate_down=10000000
 
 # "secure" mode : when enabled, UPnP client are allowed to add mappings only
 # to their IP.
@@ -91,7 +90,7 @@ clean_ruleset_interval=600
 #quickrules=no
 
 # uuid : generate your own with "make genuuid"
-uuid=3d3cec3a-8cf0-11e0-98ee-001a6bd2d07b
+uuid=7471399c-da43-4c17-a53e-c8d5f3ee1184
 
 # serial and model number the daemon will report to clients
 # in its XML description
@@ -105,9 +104,9 @@ model_number=1
 # ip/mask format must be nn.nn.nn.nn/nn
 # it is advised to only allow redirection of port above 1024
 # and to finish the rule set with "deny 0-65535 0.0.0.0/0 0-65535"
-allow 1024-65535 192.168.0.0/24 1024-65535
-allow 1024-65535 192.168.1.0/24 1024-65535
-allow 1024-65535 192.168.0.0/23 22
-allow 12345 192.168.7.113/32 54321
-deny 0-65535 0.0.0.0/0 0-65535
+#allow 1024-65535 192.168.0.0/24 0-65535
+#allow 1024-65535 192.168.1.0/24 1024-65535
+#allow 1024-65535 192.168.0.0/23 22
+#allow 12345 192.168.7.113/32 54321
+allow 0-65535 0.0.0.0/0 0-65535
 
diff --git a/natpmp.c b/natpmp.c
old mode 100644
new mode 100755
index 2add04a..55d7fb4
--- a/natpmp.c
+++ b/natpmp.c
@@ -203,6 +203,7 @@ void ProcessIncomingNATPMPPacket(int s)
 				/* remove the mapping */
 				if(iport == 0) {
 					/* remove all the mappings for this client */
+#ifndef QCMAP
 					int index = 0;
 					unsigned short eport2, iport2;
 					char iaddr2[16];
@@ -230,6 +231,7 @@ void ProcessIncomingNATPMPPacket(int s)
 							index++;
 						}
 					}
+#endif
 				} else {
 					/* To improve the interworking between nat-pmp and
 					 * UPnP, we should check that we remove only NAT-PMP
@@ -247,10 +249,14 @@ void ProcessIncomingNATPMPPacket(int s)
 			   || !check_upnp_rule_against_permissions(upnppermlist, num_upnpperm, eport, senderaddr.sin_addr, iport)) {
 				resp[3] = 2;	/* Not Authorized/Refused */
 			} else do {
+#ifndef QCMAP
 				r = get_redirect_rule(ext_if_name, eport, proto,
 				                      iaddr_old, sizeof(iaddr_old),
 				                      &iport_old, 0, 0, 0, 0,
 				                      &timestamp, 0, 0);
+#else
+                                r=0;
+#endif
 				if(r==0) {
 					if(strcmp(senderaddrstr, iaddr_old)==0
 				       && iport==iport_old) {
@@ -279,9 +285,14 @@ void ProcessIncomingNATPMPPacket(int s)
 					         eport, (proto==IPPROTO_TCP)?"tcp":"udp");
 #endif
 					/* TODO : check return code */
-					if(upnp_redirect_internal(NULL, eport, senderaddrstr,
-					                          iport, proto, desc,
-					                          timestamp) < 0) {
+					if(upnp_redirect_internal(
+#ifndef QCMAP
+                                                                  NULL,
+#endif
+                                                                  eport, senderaddrstr,
+					                          iport, proto
+                                                                  , desc, timestamp
+                                                                  ) < 0) {
 						syslog(LOG_ERR, "Failed to add NAT-PMP %hu %s->%s:%hu '%s'",
 						       eport, (proto==IPPROTO_TCP)?"tcp":"udp", senderaddrstr, iport, desc);
 						resp[3] = 3;  /* Failure */
diff --git a/upnpdescgen.c b/upnpdescgen.c
old mode 100644
new mode 100755
index 754e06d..2f37a59
--- a/upnpdescgen.c
+++ b/upnpdescgen.c
@@ -1151,7 +1151,11 @@ genEventVars(int * len, const struct serviceDesc * s, const char * servns)
 	str = strcat_str(str, len, &tmplen, "\">");
 	while(v->name) {
 		if(v->itype & 0x80) {
+#ifndef QCMAP
 			str = strcat_str(str, len, &tmplen, "<e:property><s:");
+#else
+			str = strcat_str(str, len, &tmplen, "<e:property><");
+#endif
 			str = strcat_str(str, len, &tmplen, v->name);
 			str = strcat_str(str, len, &tmplen, ">");
 			/*printf("<e:property><s:%s>", v->name);*/
@@ -1161,7 +1165,11 @@ genEventVars(int * len, const struct serviceDesc * s, const char * servns)
 			case CONNECTIONSTATUS_MAGICALVALUE:
 				/* or get_wan_connection_status_str(ext_if_name) */
 				str = strcat_str(str, len, &tmplen,
+#ifndef QCMAP
 				   upnpallowedvalues[18 + get_wan_connection_status(ext_if_name)]);
+#else
+                                   upnpallowedvalues[18 + getWanStatus()]);
+#endif
 				break;
 #ifdef ENABLE_6FC_SERVICE
 			case FIREWALLENABLED_MAGICALVALUE:
@@ -1198,7 +1206,11 @@ genEventVars(int * len, const struct serviceDesc * s, const char * servns)
 					str = strcat_str(str, len, &tmplen, use_ext_ip_addr);
 				else {
 					char ext_ip_addr[INET_ADDRSTRLEN];
+#ifndef QCMAP
 					if(getifaddr(ext_if_name, ext_ip_addr, INET_ADDRSTRLEN, NULL, NULL) < 0) {
+#else
+                                        if(getIPAddr(ext_ip_addr, INET_ADDRSTRLEN) < 0) {
+#endif
 						str = strcat_str(str, len, &tmplen, "0.0.0.0");
 					} else {
 						str = strcat_str(str, len, &tmplen, ext_ip_addr);
@@ -1217,7 +1229,11 @@ genEventVars(int * len, const struct serviceDesc * s, const char * servns)
 			default:
 				str = strcat_str(str, len, &tmplen, upnpallowedvalues[v->ieventvalue]);
 			}
+#ifndef QCMAP
 			str = strcat_str(str, len, &tmplen, "</s:");
+#else
+			str = strcat_str(str, len, &tmplen, "</");
+#endif
 			str = strcat_str(str, len, &tmplen, v->name);
 			str = strcat_str(str, len, &tmplen, "></e:property>");
 			/*printf("</s:%s></e:property>\n", v->name);*/
diff --git a/upnpredirect.c b/upnpredirect.c
old mode 100644
new mode 100755
index 5c9beae..8905d7e
--- a/upnpredirect.c
+++ b/upnpredirect.c
@@ -255,7 +255,11 @@ int reload_from_lease_file()
  *          -3 permission check failed
  */
 int
+#ifndef QCMAP
 upnp_redirect(const char * rhost, unsigned short eport,
+#else
+upnp_redirect(/*const char * rhost,*/unsigned short eport,
+#endif
               const char * iaddr, unsigned short iport,
               const char * protocol, const char * desc,
               unsigned int leaseduration)
@@ -278,6 +282,7 @@ upnp_redirect(const char * rhost, unsigned short eport,
 		                 "%hu->%s:%hu %s", eport, iaddr, iport, protocol);
 		return -3;
 	}
+#ifndef QCMAP
 	r = get_redirect_rule(ext_if_name, eport, proto,
 	                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,
 	                      0, 0,
@@ -295,32 +300,45 @@ upnp_redirect(const char * rhost, unsigned short eport,
 			return -2;
 		}
 	} else {
+#endif
 		timestamp = (leaseduration > 0) ? time(NULL) + leaseduration : 0;
 		syslog(LOG_INFO, "redirecting port %hu to %s:%hu protocol %s for: %s",
 			eport, iaddr, iport, protocol, desc);
+#ifdef QCMAP
+	return upnp_redirect_internal(eport, iaddr, iport, proto, desc, timestamp);
+#else
 		return upnp_redirect_internal(rhost, eport, iaddr, iport, proto,
 		                              desc, timestamp);
 	}
+#endif
 
 	return 0;
 }
 
 int
-upnp_redirect_internal(const char * rhost, unsigned short eport,
+upnp_redirect_internal(
+#ifndef QCMAP
+                       const char * rhost,
+#endif
+                       unsigned short eport,
                        const char * iaddr, unsigned short iport,
-                       int proto, const char * desc,
+                       int proto,
+                       const char * desc,
                        unsigned int timestamp)
 {
+#ifndef QCMAP
 	/*syslog(LOG_INFO, "redirecting port %hu to %s:%hu protocol %s for: %s",
 		eport, iaddr, iport, protocol, desc);			*/
 	if(add_redirect_rule2(ext_if_name, rhost, eport, iaddr, iport, proto,
 	                      desc, timestamp) < 0) {
 		return -1;
 	}
+#endif
 
 #ifdef ENABLE_LEASEFILE
 	lease_file_add( eport, iaddr, iport, proto, desc, timestamp);
 #endif
+#ifndef QCMAP
 /*	syslog(LOG_INFO, "creating pass rule to %s:%hu protocol %s for: %s",
 		iaddr, iport, protocol, desc);*/
 	if(add_filter_rule2(ext_if_name, rhost, iaddr, eport, iport, proto, desc) < 0) {
@@ -328,8 +346,17 @@ upnp_redirect_internal(const char * rhost, unsigned short eport,
 #if !defined(__linux__)
 		delete_redirect_rule(ext_if_name, eport, proto);
 #endif
+#else
+	struct in_addr address;
+
+	if(inet_aton(iaddr, &address) < 0) {
+		syslog(LOG_ERR, "inet_aton(%s) : %m", iaddr);
 		return -1;
 	}
+        if(addStaticNatEntry_wrapper(address, proto, iport, eport) < 0)
+                return -1;
+	add_redirect_desc(eport, proto, desc, timestamp);
+#endif
 	if(timestamp > 0) {
 		if(!nextruletoclean_timestamp || (timestamp < nextruletoclean_timestamp))
 			nextruletoclean_timestamp = timestamp;
@@ -361,17 +388,30 @@ upnp_get_redirection_infos(unsigned short eport, const char * protocol,
 		desc[0] = '\0';
 	if(rhost && (rhostlen > 0))
 		rhost[0] = '\0';
+#ifndef QCMAP
 	r = get_redirect_rule(ext_if_name, eport, proto_atoi(protocol),
 	                      iaddr, iaddrlen, iport, desc, desclen,
 	                      rhost, rhostlen, &timestamp,
 	                      0, 0);
 	if(r == 0 &&
 	   timestamp > 0 &&
+#else
+	r = getSpecificEntry( eport, proto_atoi(protocol),
+	                      iaddr, iaddrlen, iport,
+	                      rhost, rhostlen, &timestamp);
+	if (r == 0) {
+		get_redirect_desc(eport, proto_atoi(protocol), desc, desclen, &timestamp);
+
+		if(timestamp > 0 &&
+#endif
 	   timestamp > (unsigned int)(current_time = time(NULL))) {
 		*leaseduration = timestamp - current_time;
 	} else {
 		*leaseduration = 0;
 	}
+#ifdef QCMAP
+        }
+#endif
 	return r;
 }
 
@@ -393,13 +433,20 @@ upnp_get_redirection_infos_by_index(int index,
 		desc[0] = '\0';
 	if(rhost && (rhostlen > 0))
 		rhost[0] = '\0';
+#ifndef QCMAP
 	if(get_redirect_rule_by_index(index, 0/*ifname*/, eport, iaddr, iaddrlen,
 	                              iport, &proto, desc, desclen,
 	                              rhost, rhostlen, &timestamp,
 	                              0, 0) < 0)
+#else
+	if (getStaticNatConfigByEntry(index, iaddr, iaddrlen, eport, iport, &proto) < 0)
+#endif
 		return -1;
 	else
 	{
+#ifdef QCMAP
+		get_redirect_desc(*eport, proto, desc, desclen, &timestamp);
+#endif
 		current_time = time(NULL);
 		*leaseduration = (timestamp > (unsigned int)current_time)
 		                 ? (timestamp - current_time)
@@ -418,8 +465,12 @@ _upnp_delete_redir(unsigned short eport, int proto)
 {
 	int r;
 #if defined(__linux__)
+#ifndef QCMAP
 	r = delete_redirect_and_filter_rules(eport, proto);
 #else
+	r = deleteStaticNatEntry_wrapper( eport, proto);
+#endif
+#else
 	r = delete_redirect_rule(ext_if_name, eport, proto);
 	delete_filter_rule(ext_if_name, eport, proto);
 #endif
@@ -430,6 +481,10 @@ _upnp_delete_redir(unsigned short eport, int proto)
 #ifdef ENABLE_EVENTS
 	upnp_event_var_change_notify(EWanIPC);
 #endif
+#ifdef QCMAP
+	if ( r >= 0 )
+		del_redirect_desc(eport, proto);
+#endif
 	return r;
 }
 
@@ -482,11 +537,18 @@ get_upnp_rules_state_list(int max_rules_number_target)
 		return 0;
 	current_time = time(NULL);
 	nextruletoclean_timestamp = 0;
+#ifndef QCMAP
 	while(get_redirect_rule_by_index(i, /*ifname*/0, &tmp->eport, 0, 0,
 	                              &iport, &proto, 0, 0, 0,0, &timestamp,
 								  &tmp->packets, &tmp->bytes) >= 0)
+#else
+	while(getStaticNatConfigByEntry(i, 0, 0, &tmp->eport, &iport, &proto) >= 0)
+#endif
 	{
 		tmp->to_remove = 0;
+#ifdef QCMAP
+		get_redirect_desc(tmp->eport, proto, 0, 0, &timestamp);
+#endif
 		if(timestamp > 0) {
 			/* need to remove this port mapping ? */
 			if(timestamp <= (unsigned int)current_time)
@@ -547,6 +609,7 @@ remove_unused_rules(struct rule_state * list)
 	while(list)
 	{
 		/* remove the rule if no traffic has used it */
+#ifndef QCMAP
 		if(get_redirect_rule(ifname, list->eport, list->proto,
 	                         0, 0, &iport, 0, 0, 0, 0, &timestamp,
 		                     &packets, &bytes) >= 0)
@@ -557,6 +620,7 @@ remove_unused_rules(struct rule_state * list)
 				n++;
 			}
 		}
+#endif
 		tmp = list;
 		list = tmp->next;
 		free(tmp);
@@ -569,8 +633,11 @@ remove_unused_rules(struct rule_state * list)
  * return a list of all "external" ports for which a port
  * mapping exists */
 unsigned short *
-upnp_get_portmappings_in_range(unsigned short startport,
+upnp_get_portmappings_in_range(
+#ifndef QCMAP
+                               unsigned short startport,
                                unsigned short endport,
+#endif
                                const char * protocol,
                                unsigned int * number)
 {
@@ -578,7 +645,11 @@ upnp_get_portmappings_in_range(unsigned short startport,
 	proto = proto_atoi(protocol);
 	if(!number)
 		return NULL;
+#ifndef QCMAP
 	return get_portmappings_in_range(startport, endport, proto, number);
+#else
+        return NULL;
+#endif
 }
 
 /* stuff for miniupnpdctl */
diff --git a/upnpredirect.h b/upnpredirect.h
old mode 100644
new mode 100755
index b549824..db8f6ac
--- a/upnpredirect.h
+++ b/upnpredirect.h
@@ -26,7 +26,11 @@ int reload_from_lease_file(void);
  *          -3 permission check failed
  */
 int
-upnp_redirect(const char * rhost, unsigned short eport,
+upnp_redirect(
+#ifndef QCMAP
+              const char * rhost,
+#endif
+              unsigned short eport,
               const char * iaddr, unsigned short iport,
               const char * protocol, const char * desc,
               unsigned int leaseduration);
@@ -34,10 +38,16 @@ upnp_redirect(const char * rhost, unsigned short eport,
 /* upnp_redirect_internal()
  * same as upnp_redirect() without any check */
 int
-upnp_redirect_internal(const char * rhost, unsigned short eport,
+upnp_redirect_internal(
+#ifndef QCMAP
+                       const char * rhost,
+#endif
+                       unsigned short eport,
                        const char * iaddr, unsigned short iport,
-                       int proto, const char * desc,
-                       unsigned int timestamp);
+                       int proto,
+                       const char * desc,
+                       unsigned int timestamp
+                       );
 
 /* upnp_get_redirection_infos()
  * returns : 0 on success
@@ -103,8 +113,11 @@ remove_unused_rules(struct rule_state * list);
  * return a list of all "external" ports for which a port
  * mapping exists */
 unsigned short *
-upnp_get_portmappings_in_range(unsigned short startport,
+upnp_get_portmappings_in_range(
+#ifndef QCMAP
+                               unsigned short startport,
                                unsigned short endport,
+#endif
                                const char * protocol,
                                unsigned int * number);
 
diff --git a/upnpreplyparse.c b/upnpreplyparse.c
old mode 100644
new mode 100755
diff --git a/upnpreplyparse.h b/upnpreplyparse.h
old mode 100644
new mode 100755
diff --git a/upnpsoap.c b/upnpsoap.c
old mode 100644
new mode 100755
index c61ea05..082b0e4
--- a/upnpsoap.c
+++ b/upnpsoap.c
@@ -88,8 +88,11 @@ GetTotalBytesSent(struct upnphttp * h, const char * action)
 	char body[512];
 	int bodylen;
 	struct ifdata data;
-
+#ifndef QCMAP
 	r = getifstats(ext_if_name, &data);
+#else
+	r = getIfaceStats(&data);
+#endif
 	bodylen = snprintf(body, sizeof(body), resp,
 	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
              r<0?0:data.obytes, action);
@@ -110,8 +113,11 @@ GetTotalBytesReceived(struct upnphttp * h, const char * action)
 	char body[512];
 	int bodylen;
 	struct ifdata data;
-
+#ifndef QCMAP
 	r = getifstats(ext_if_name, &data);
+#else
+	r = getIfaceStats(&data);
+#endif
 	bodylen = snprintf(body, sizeof(body), resp,
 	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
 	         r<0?0:data.ibytes, action);
@@ -132,8 +138,11 @@ GetTotalPacketsSent(struct upnphttp * h, const char * action)
 	char body[512];
 	int bodylen;
 	struct ifdata data;
-
+#ifndef QCMAP
 	r = getifstats(ext_if_name, &data);
+#else
+	r = getIfaceStats(&data);
+#endif
 	bodylen = snprintf(body, sizeof(body), resp,
 	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
 	         r<0?0:data.opackets, action);
@@ -154,8 +163,11 @@ GetTotalPacketsReceived(struct upnphttp * h, const char * action)
 	char body[512];
 	int bodylen;
 	struct ifdata data;
-
+#ifndef QCMAP
 	r = getifstats(ext_if_name, &data);
+#else
+	r = getIfaceStats(&data);
+#endif
 	bodylen = snprintf(body, sizeof(body), resp,
 	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
 	         r<0?0:data.ipackets, action);
@@ -184,6 +196,7 @@ GetCommonLinkProperties(struct upnphttp * h, const char * action)
 	                             * Initializing, Unavailable (Optional) */
 	char ext_ip_addr[INET_ADDRSTRLEN];
 
+#ifndef QCMAP
 	if((downstream_bitrate == 0) || (upstream_bitrate == 0))
 	{
 		if(getifstats(ext_if_name, &data) >= 0)
@@ -193,6 +206,19 @@ GetCommonLinkProperties(struct upnphttp * h, const char * action)
 		}
 	}
 	if(getifaddr(ext_if_name, ext_ip_addr, INET_ADDRSTRLEN, NULL, NULL) < 0) {
+#else
+	if(getIfaceStats(&data) >= 0)
+	{
+		downstream_bitrate = data.downstream_bitrate;
+		upstream_bitrate = data.upstream_bitrate;
+	}
+	else
+	{
+		downstream_bitrate = 0;
+		upstream_bitrate = 0;
+	}
+	if(getIPAddr(ext_ip_addr, INET_ADDRSTRLEN) < 0) {
+#endif
 		status = "Down";
 	}
 	bodylen = snprintf(body, sizeof(body), resp,
@@ -220,8 +246,11 @@ GetStatusInfo(struct upnphttp * h, const char * action)
 	/* ConnectionStatus possible values :
 	 * Unconfigured, Connecting, Connected, PendingDisconnect,
 	 * Disconnecting, Disconnected */
-
+#ifndef QCMAP
 	status = get_wan_connection_status_str(ext_if_name);
+#else
+	status = getWanStatusStr();
+#endif
 	uptime = (time(NULL) - startup_time);
 	bodylen = snprintf(body, sizeof(body), resp,
 		action, SERVICE_TYPE_WANIPC,
@@ -270,10 +299,16 @@ GetExternalIPAddress(struct upnphttp * h, const char * action)
 	{
 		strncpy(ext_ip_addr, use_ext_ip_addr, INET_ADDRSTRLEN);
 	}
+#ifndef QCMAP
 	else if(getifaddr(ext_if_name, ext_ip_addr, INET_ADDRSTRLEN, NULL, NULL) < 0)
 	{
 		syslog(LOG_ERR, "Failed to get ip address for interface %s",
 			ext_if_name);
+#else
+	else if(getIPAddr(ext_ip_addr, INET_ADDRSTRLEN) < 0)
+	{
+		syslog(LOG_ERR, "Failed to get ip address for interface");
+#endif
 		strncpy(ext_ip_addr, "0.0.0.0", INET_ADDRSTRLEN);
 	}
 #else
@@ -410,7 +445,11 @@ AddPortMapping(struct upnphttp * h, const char * action)
 	       action, eport, int_ip, iport, protocol, desc, leaseduration,
 	       r_host ? r_host : "NULL");
 
-	r = upnp_redirect(r_host, eport, int_ip, iport, protocol, desc, leaseduration);
+	r = upnp_redirect(
+#ifndef QCMAP
+                          r_host,
+#endif
+                          eport, int_ip, iport, protocol, desc, leaseduration);
 
 	ClearNameValueList(&data);
 
@@ -546,7 +585,11 @@ AddAnyPortMapping(struct upnphttp * h, const char * action)
 	/* TODO : accept a different external port
 	 * have some smart strategy to choose the port */
 	for(;;) {
-		r = upnp_redirect(r_host, eport, int_ip, iport, protocol, desc, leaseduration);
+	                  r = upnp_redirect(
+#ifndef QCMAP
+                          r_host,
+#endif
+                          eport, int_ip, iport, protocol, desc, leaseduration);
 		if(r==-2 && eport < 65535) {
 			eport++;
 		} else {
@@ -764,7 +807,10 @@ DeletePortMappingRange(struct upnphttp * h, const char * action)
 		return;
 	}
 
-	port_list = upnp_get_portmappings_in_range(startport, endport,
+	port_list = upnp_get_portmappings_in_range(
+#ifndef QCMAP
+                                                   startport, endport,
+#endif
 	                                           protocol, &number);
 	for(i = 0; i < number; i++)
 	{
@@ -974,7 +1020,10 @@ http://www.upnp.org/schemas/gw/WANIPConnection-v2.xsd">
 	memcpy(body+bodylen, list_start, sizeof(list_start));
 	bodylen += (sizeof(list_start) - 1);
 
-	port_list = upnp_get_portmappings_in_range(startport, endport,
+	port_list = upnp_get_portmappings_in_range(
+#ifndef QCMAP
+                                                   startport, endport,
+#endif
 	                                           protocol, &list_size);
 	/* loop through port mappings */
 	for(i = 0; number > 0 && i < list_size; i++)
@@ -1149,8 +1198,11 @@ QueryStateVariable(struct upnphttp * h, const char * action)
 	else if(strcmp(var_name, "ConnectionStatus") == 0)
 	{
 		const char * status;
-
+#ifndef QCMAP
 		status = get_wan_connection_status_str(ext_if_name);
+#else
+		status = getWanStatusStr();
+#endif
 		bodylen = snprintf(body, sizeof(body), resp,
                            action, "urn:schemas-upnp-org:control-1-0",
 		                   status, action);
-- 
1.7.8.3

