From 1609acc517bcc9703f99dbb7f1189fc6293a422f Mon Sep 17 00:00:00 2001
From: Tyler Wear <twear@codeaurora.org>
Date: Tue, 4 Jun 2013 13:11:34 -0700
Subject: [PATCH 1/1] qcmap-enabled

---
 Makefile.linux                |  118 ++++++-------
 UPNP_QCMAP_Client.cpp         |  417 +++++++++++++++++++++++++++++++++++++++++
 UPNP_QCMAP_Client.h           |   62 ++++++
 config.h                      |  103 ++++++++++
 getifstats.h                  |    6 +
 linux/miniupnpd.init.d.script |   15 --
 minissdp.c                    |  103 ++++++----
 miniupnpd.c                   |   32 +++-
 miniupnpd.conf                |   25 ++--
 natpmp.c                      |   17 ++-
 upnpdescgen.c                 |   16 ++
 upnpredirect.c                |   77 ++++++++-
 upnpredirect.h                |   23 ++-
 upnpsoap.c                    |   72 ++++++-
 14 files changed, 929 insertions(+), 157 deletions(-)
 create mode 100644 UPNP_QCMAP_Client.cpp
 create mode 100644 UPNP_QCMAP_Client.h
 create mode 100644 config.h
 mode change 100644 => 100755 miniupnpd.conf
 mode change 100644 => 100755 upnpsoap.c

diff --git a/Makefile.linux b/Makefile.linux
index 900f702..4f2254f 100644
--- a/Makefile.linux
+++ b/Makefile.linux
@@ -30,10 +30,10 @@ CFLAGS += -Wall
 CFLAGS += -Wextra -Wstrict-prototypes -Wdeclaration-after-statement
 #CFLAGS += -Wno-missing-field-initializers
 #CFLAGS += -ansi	# iptables headers does use typeof which is a gcc extension
-CC ?= gcc
+#CC ?= gcc
 RM = rm -f
 INSTALL = install
-STRIP ?= strip
+#STRIP ?= strip
 CP = cp
 
 
@@ -49,34 +49,14 @@ BASEOBJS = miniupnpd.o upnphttp.o upnpdescgen.o upnpsoap.o \
            upnpevents.o upnputils.o getconnstatus.o \
            upnppinhole.o
 
-LNXOBJS = linux/getifstats.o linux/ifacewatcher.o linux/getroute.o
-NETFILTEROBJS = netfilter/iptcrdr.o netfilter/iptpinhole.o
+CPPOBJS = UPNP_QCMAP_Client.o

-ALLOBJS = $(BASEOBJS) $(LNXOBJS) $(NETFILTEROBJS)
-
-PCFILE_FOUND := $(shell pkg-config --exists libiptc; echo $$?)
-
-ifeq (${PCFILE_FOUND},0)
+LNXOBJS = linux/getifstats.o linux/ifacewatcher.o
 
-IPTABLESVERSION := $(shell pkg-config --modversion libiptc)
-IPTABLESVERSION1 := $(shell echo $(IPTABLESVERSION) | cut -d. -f1 )
-IPTABLESVERSION2 := $(shell echo $(IPTABLESVERSION) | cut -d. -f2 )
-IPTABLESVERSION3 := $(shell echo $(IPTABLESVERSION) | cut -d. -f3 )
-# test if iptables version >= 1.4.3
-TEST := $(shell [ \( \( $(IPTABLESVERSION1) -ge 1 \) -a \( $(IPTABLESVERSION2) -ge 4 \) \) -a \( $(IPTABLESVERSION3) -ge 3 \) ] && echo 1 )
-ifeq ($(TEST), 1)
-CFLAGS += -DIPTABLES_143
-endif
-
-CFLAGS  += $(shell pkg-config --cflags libiptc)
-LIBS    += $(shell pkg-config --libs-only-l libiptc)
-LDFLAGS += $(shell pkg-config --libs-only-L libiptc)
-LDFLAGS += $(shell pkg-config --libs-only-other libiptc)
-
-else
+ALLOBJS = $(BASEOBJS) $(LNXOBJS) $(NETFILTEROBJS)
 
 ifeq "$(wildcard /etc/gentoo-release )" ""
-LIBS ?= -liptc
+#LIBS ?= -liptc
 else # gentoo
 # the following is better, at least on gentoo with iptables 1.4.6
 # see http://miniupnp.tuxfamily.org/forum/viewtopic.php?p=1618
@@ -87,8 +67,8 @@ endif
 
 ARCH ?= $(shell uname -m | grep -q "x86_64" && echo 64)
 ifdef IPTABLESPATH
-CFLAGS := $(CFLAGS) -I$(IPTABLESPATH)/include/
-LDFLAGS := $(LDFLAFGS) -L$(IPTABLESPATH)/libiptc/
+#CFLAGS := $(CFLAGS) -I$(IPTABLESPATH)/include/
+#LDFLAGS := $(LDFLAFGS) -L$(IPTABLESPATH)/libiptc/
 # get iptables version and set IPTABLES_143 macro if needed
 ifeq ($(TARGET_OPENWRT),)
 IPTABLESVERSION := $(shell grep "\#define VERSION" $(IPTABLESPATH)/config.h | tr -d \" |cut -d" " -f3 )
@@ -125,7 +105,7 @@ else # ifdef IPTABLESPATH
 TEST := $(shell test -f /usr/include/xtables.h && grep -q "XTABLES_VERSION_CODE" /usr/include/xtables.h && echo 1)
 ifeq ($(TEST), 1)
 CFLAGS := $(CFLAGS) -DIPTABLES_143
-LIBS = -liptc
+#LIBS = -liptc
 TESTIP4TC := $(shell test -f /lib/libip4tc.so && echo 1)
 ifeq ($(TESTIP4TC), 1)
 LIBS := $(LIBS) -lip4tc
@@ -136,15 +116,15 @@ LIBS := $(LIBS) -lip6tc
 endif # ($(TESTIP6TC), 1)
 endif # ($(TEST), 1)
 endif # ifdef IPTABLESPATH
-endif # ifdef PCFILE_FOUND
 
-LIBS += -lnfnetlink
+#LIBS += -lnfnetlink

-TESTUPNPDESCGENOBJS = testupnpdescgen.o upnpdescgen.o
+LIBS += ${LIBDIR}/libqcmap_client.so.1
+LDFLAGS := $(LDFLAFGS) -L${LIBDIR}/libqcmap_client.so.1
+#CFLAGS += $(qcmap_client_inc)
 
-EXECUTABLES = miniupnpd testupnpdescgen testgetifstats \
+EXECUTABLES = miniupnpd testgetifstats \
               testupnppermissions miniupnpdctl testgetifaddr \
-              testgetroute
 
 .PHONY:	all clean install depend genuuid
 
@@ -153,23 +133,17 @@ all:	$(EXECUTABLES)
 clean:
 	$(RM) $(ALLOBJS)
 	$(RM) $(EXECUTABLES)
-	$(RM) testupnpdescgen.o testgetifstats.o
+	$(RM) UPNP_QCMAP_Client.o
+	$(RM) testgetifstats.o
 	$(RM) testupnppermissions.o testgetifaddr.o
-	$(RM) testgetroute.o
 	$(RM) miniupnpdctl.o
 
 install:	miniupnpd miniupnpd.8 miniupnpd.conf genuuid \
-	netfilter/iptables_init.sh netfilter/iptables_removeall.sh \
-	netfilter/ip6tables_init.sh netfilter/ip6tables_removeall.sh \
 	linux/miniupnpd.init.d.script
 	$(STRIP) miniupnpd
	$(INSTALL) -d $(DESTDIR)$(SBININSTALLDIR)
	$(INSTALL) miniupnpd $(DESTDIR)$(SBININSTALLDIR)
	$(INSTALL) -d $(DESTDIR)$(ETCINSTALLDIR)
-	$(INSTALL) netfilter/iptables_init.sh $(DESTDIR)$(ETCINSTALLDIR)
-	$(INSTALL) netfilter/iptables_removeall.sh $(DESTDIR)$(ETCINSTALLDIR)
-	$(INSTALL) netfilter/ip6tables_init.sh $(DESTDIR)$(ETCINSTALLDIR)
-	$(INSTALL) netfilter/ip6tables_removeall.sh $(DESTDIR)$(ETCINSTALLDIR)
	$(INSTALL) --mode=0644 -b miniupnpd.conf $(DESTDIR)$(ETCINSTALLDIR)
	$(INSTALL) -d $(DESTDIR)$(PREFIX)/etc/init.d
	$(INSTALL) linux/miniupnpd.init.d.script $(DESTDIR)$(PREFIX)/etc/init.d/miniupnpd
@@ -187,9 +161,8 @@ else
 	sed -i -e "s/^uuid=[-0-9a-f]*/uuid=`($(STAGING_DIR_HOST)/bin/genuuid||$(STAGING_DIR_HOST)/bin/uuidgen||$(STAGING_DIR_HOST)/bin/uuid) 2>/dev/null`/" miniupnpd.conf
 endif
 
-miniupnpd:	$(BASEOBJS) $(LNXOBJS) $(NETFILTEROBJS) $(LIBS)
-
-testupnpdescgen:	$(TESTUPNPDESCGENOBJS)
+miniupnpd: $(BASEOBJS) $(CPPOBJS) $(LNXOBJS)
+	$(CXX) $(CFLAGS) $(LDFLAFGS) -o $@ $(BASEOBJS) $(CPPOBJS) $(LNXOBJS) $(LIBS)
 
 testgetifstats:	testgetifstats.o linux/getifstats.o

@@ -197,8 +170,6 @@ testupnppermissions:	testupnppermissions.o upnppermissions.o
 
 testgetifaddr:	testgetifaddr.o getifaddr.o
 
-testgetroute:	testgetroute.o linux/getroute.o upnputils.o -lnfnetlink
-
 miniupnpdctl:	miniupnpdctl.o
 
 config.h:	genconfig.sh VERSION
@@ -207,8 +178,32 @@ config.h:	genconfig.sh VERSION
 depend:	config.h
	makedepend -f$(MAKEFILE_LIST) -Y \
 	$(ALLOBJS:.o=.c) $(TESTUPNPDESCGENOBJS:.o=.c) \
-	testgetifstats.c testupnppermissions.c testgetifaddr.c \
-	testgetroute.c miniupnpdctl.c 2>/dev/null
+	testgetifstats.c 2>/dev/null
+
+qcmap_client_inc = -D__packed__= \
+        -DIMAGE_APPS_PROC \
+        -DFEATURE_Q_NO_SELF_QPTR \
+        -DAEEINTERFACE_CPLUSPLUS \
+        -DFEATURE_SMD \
+        -DFEATURE_DIAG_MP_MASTER_APPS \
+        -DFEATURE_DS_LINUX_ANDROID \
+        -DFEATURE_DSS_LINUX \
+        -DFEATURE_LINUX \
+        -DFEATURE_MULTIPROCESSOR \
+        -DFEATURE_DSUTILS_OFFTARGET \
+        -DFEATURE_NO_REX \
+        -DFEATURE_XMLLIB \
+		 -I$(INCDIR) \
+		 -I$(INCDIR)/rpcsvc \
+        -I$(INCDIR)/data \
+        -I$(INCDIR)/qmi-framework\
+        -I$(INCDIR)/qmi \
+        -I$(INCDIR)/diag \
+        -I$(INCDIR)/dsutils \
+        -I$(INCDIR)/xmllib
+
+CPPFLAGS += -Dstrlcpy=strncpy -Dstrlcat=strncat $(qcmap_client_inc)
+#LIBS += -lpthread -lrt libqcmap_client.la

 # DO NOT DELETE
 
@@ -216,52 +211,47 @@ miniupnpd.o: config.h macros.h upnpglobalvars.h upnppermissions.h
 miniupnpd.o: miniupnpdtypes.h upnphttp.h upnpdescgen.h miniupnpdpath.h
 miniupnpd.o: getifaddr.h upnpsoap.h options.h minissdp.h upnpredirect.h
 miniupnpd.o: upnppinhole.h daemonize.h upnpevents.h natpmp.h commonrdr.h
-miniupnpd.o: upnputils.h ifacewatcher.h
+miniupnpd.o: upnputils.h ifacewatcher.h UPNP_QCMAP_Client.h
 upnphttp.o: config.h upnphttp.h upnpdescgen.h miniupnpdpath.h upnpsoap.h
 upnphttp.o: upnpevents.h upnputils.h
 upnpdescgen.o: config.h getifaddr.h upnpredirect.h upnpdescgen.h
 upnpdescgen.o: miniupnpdpath.h upnpglobalvars.h upnppermissions.h
 upnpdescgen.o: miniupnpdtypes.h upnpdescstrings.h upnpurns.h getconnstatus.h
+upnpdescgen.o: UPNP_QCMAP_Client.h
 upnpsoap.o: macros.h config.h upnpglobalvars.h upnppermissions.h
 upnpsoap.o: miniupnpdtypes.h upnphttp.h upnpsoap.h upnpreplyparse.h
 upnpsoap.o: upnpredirect.h upnppinhole.h getifaddr.h getifstats.h
-upnpsoap.o: getconnstatus.h upnpurns.h
+upnpsoap.o: getconnstatus.h upnpurns.h UPNP_QCMAP_Client.h
 upnpreplyparse.o: upnpreplyparse.h minixml.h
 minixml.o: minixml.h
 upnpredirect.o: macros.h config.h upnpredirect.h upnpglobalvars.h
 upnpredirect.o: upnppermissions.h miniupnpdtypes.h upnpevents.h
-upnpredirect.o: netfilter/iptcrdr.h commonrdr.h
+upnpredirect.o: commonrdr.h
+upnpredirect.o: UPNP_QCMAP_Client.h
+UPNP_QCMAP_Client.o: UPNP_QCMAP_Client.cpp UPNP_QCMAP_Client.h
+	$(CXX) $(CPPFLAGS) -c UPNP_QCMAP_Client.cpp
 getifaddr.o: config.h getifaddr.h
 daemonize.o: daemonize.h config.h
 upnpglobalvars.o: config.h upnpglobalvars.h upnppermissions.h
 upnpglobalvars.o: miniupnpdtypes.h
-options.o: config.h options.h upnppermissions.h upnpglobalvars.h
+options.o: options.h config.h upnppermissions.h upnpglobalvars.h
 options.o: miniupnpdtypes.h
 upnppermissions.o: config.h upnppermissions.h
 minissdp.o: config.h upnpdescstrings.h miniupnpdpath.h upnphttp.h
 minissdp.o: upnpglobalvars.h upnppermissions.h miniupnpdtypes.h minissdp.h
-minissdp.o: upnputils.h getroute.h codelength.h
+minissdp.o: upnputils.h codelength.h
 natpmp.o: macros.h config.h natpmp.h upnpglobalvars.h upnppermissions.h
 natpmp.o: miniupnpdtypes.h getifaddr.h upnpredirect.h commonrdr.h upnputils.h
 upnpevents.o: config.h upnpevents.h miniupnpdpath.h upnpglobalvars.h
 upnpevents.o: upnppermissions.h miniupnpdtypes.h upnpdescgen.h upnputils.h
-upnputils.o: config.h upnputils.h upnpglobalvars.h upnppermissions.h
-upnputils.o: miniupnpdtypes.h getroute.h
+upnputils.o: config.h upnputils.h
 getconnstatus.o: getconnstatus.h getifaddr.h
 upnppinhole.o: macros.h config.h upnpredirect.h upnpglobalvars.h
 upnppinhole.o: upnppermissions.h miniupnpdtypes.h upnpevents.h
-upnppinhole.o: netfilter/iptpinhole.h
 linux/getifstats.o: config.h getifstats.h
 linux/ifacewatcher.o: config.h ifacewatcher.h config.h minissdp.h
 linux/ifacewatcher.o: miniupnpdtypes.h getifaddr.h upnpglobalvars.h
 linux/ifacewatcher.o: upnppermissions.h natpmp.h
-linux/getroute.o: getroute.h upnputils.h
-netfilter/iptcrdr.o: macros.h config.h netfilter/iptcrdr.h commonrdr.h
-netfilter/iptcrdr.o: config.h upnpglobalvars.h upnppermissions.h
-netfilter/iptcrdr.o: miniupnpdtypes.h
-netfilter/iptpinhole.o: config.h netfilter/iptpinhole.h upnpglobalvars.h
-netfilter/iptpinhole.o: upnppermissions.h config.h miniupnpdtypes.h
-testupnpdescgen.o: macros.h config.h upnpdescgen.h
 upnpdescgen.o: config.h getifaddr.h upnpredirect.h upnpdescgen.h
 upnpdescgen.o: miniupnpdpath.h upnpglobalvars.h upnppermissions.h
 upnpdescgen.o: miniupnpdtypes.h upnpdescstrings.h upnpurns.h getconnstatus.h
diff --git a/UPNP_QCMAP_Client.cpp b/UPNP_QCMAP_Client.cpp
new file mode 100644
index 0000000..74018c7
--- /dev/null
+++ b/UPNP_QCMAP_Client.cpp
@@ -0,0 +1,417 @@
+/*
+Copyright (c) 2013, The Linux Foundation. All rights reserved.
+
+MiniUPnPd
+Copyright (c) 2006-2011, Thomas BERNARD
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+    * Neither the name of The Linux Foundation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#include "QCMAP_Client.h"
+#include "getifstats.h"
+
+QCMAP_Client *QcMapClient = NULL;
+
+#ifdef __cplusplus
+       extern "C"
+       {
+#endif
+
+int addStaticNatEntry_wrapper(struct in_addr addr, unsigned int proto, unsigned int local_port, unsigned int g_port)
+{
+    qcmap_msgr_snat_entry_config_v01 snat_entry;
+    qmi_error_type_v01 qmi_err_num;
+
+    /* Port mapping is not present, try to add it */
+    memset(&snat_entry, 0, sizeof(qcmap_msgr_snat_entry_config_v01));
+    snat_entry.private_ip_addr = ntohl(addr.s_addr);
+    snat_entry.protocol = (uint8)proto;
+    snat_entry.private_port = (uint16)local_port;
+    snat_entry.global_port = (uint16)g_port;
+
+    if (!QcMapClient->AddStaticNatEntry(&snat_entry, &qmi_err_num))
+    {
+        if(qmi_err_num == QMI_ERR_INTERFACE_NOT_FOUND_V01)
+            return 0;
+        if(qmi_err_num == QMI_ERR_NO_EFFECT_V01)
+            return -2;
+        return -1;
+    }
+    return 0;
+}
+
+int deleteStaticNatEntry_wrapper(unsigned short port, int proto)
+{
+    qcmap_msgr_snat_entry_config_v01 snat_entry;
+    qcmap_msgr_snat_entry_config_v01 snat_config[QCMAP_MSGR_MAX_SNAT_ENTRIES_V01];
+    int i=0, num_entries=0, r=-1;
+    qmi_error_type_v01 qmi_err_num;
+
+    memset(&snat_entry, 0, sizeof(qcmap_msgr_snat_entry_config_v01));
+    snat_entry.protocol = (uint8)proto;
+    snat_entry.global_port = (uint16)port;
+
+    memset(snat_config, 0, QCMAP_MSGR_MAX_SNAT_ENTRIES_V01*sizeof(qcmap_msgr_snat_entry_config_v01));
+    if (QcMapClient->GetStaticNatConfig(snat_config, &num_entries, &qmi_err_num))
+    {
+        for (i=0; i<num_entries; i++)
+        {
+            if(port == snat_config[i].global_port && proto == snat_config[i].protocol)
+            {
+                snat_entry.private_ip_addr = snat_config[i].private_ip_addr;
+                snat_entry.private_port = snat_config[i].private_port;
+
+                r = QcMapClient->DeleteStaticNatEntry(&snat_entry, &qmi_err_num);
+                if (r == 0)
+                {
+                    if (qmi_err_num == QMI_ERR_INTERFACE_NOT_FOUND_V01)
+                        return 0;
+                    return -1;
+                }
+                return r;
+            }
+        }
+    }
+    return r;
+}
+
+int getStaticNatConfigByEntry(int index, char *addr, int addrlen, unsigned short *eport, unsigned short *iport, int *proto)
+{
+    qmi_error_type_v01 qmi_err_num;
+    in_addr tmpIP;
+    int i=0, num_entries=0;
+    qcmap_msgr_snat_entry_config_v01 snat_config[QCMAP_MSGR_MAX_SNAT_ENTRIES_V01];
+
+    memset(snat_config, 0, QCMAP_MSGR_MAX_SNAT_ENTRIES_V01*sizeof(qcmap_msgr_snat_entry_config_v01));
+    if (QcMapClient->GetStaticNatConfig(snat_config, &num_entries, &qmi_err_num))
+    {
+        for (i=0; i<num_entries; i++)
+        {
+            if(i == index)
+            {
+                tmpIP.s_addr = ntohl(snat_config[i].private_ip_addr);
+                snprintf(addr, addrlen,"%u.%u.%u.%u", tmpIP.s_addr & 0xff, (tmpIP.s_addr >> 8) & 0xff, (tmpIP.s_addr >> 16) & 0xff, tmpIP.s_addr >> 24);
+                *iport = snat_config[i].private_port;
+                *eport = snat_config[i].global_port;
+                *proto = snat_config[i].protocol;
+
+                return 0;
+            }
+        }
+    }
+
+    return -1;
+}
+
+int getSpecificEntry(unsigned int eport, unsigned int proto, char *addr, int addrlen, unsigned short *iport, char * rhost, int rhostlen, unsigned int * timestamp)
+{
+    qmi_error_type_v01 qmi_err_num;
+    in_addr tmpIP;
+    int i=0, num_entries=0;
+    qcmap_msgr_snat_entry_config_v01 snat_config[QCMAP_MSGR_MAX_SNAT_ENTRIES_V01];
+
+    memset(snat_config, 0, QCMAP_MSGR_MAX_SNAT_ENTRIES_V01*sizeof(qcmap_msgr_snat_entry_config_v01));
+    if (QcMapClient->GetStaticNatConfig(snat_config, &num_entries, &qmi_err_num))
+    {
+        for (i=0; i<num_entries; i++)
+        {
+            if((snat_config[i].global_port == (uint16)eport) && (snat_config[i].protocol == (uint8)proto))
+            {
+                tmpIP.s_addr = ntohl(snat_config[i].private_ip_addr);
+                snprintf(addr, addrlen,"%u.%u.%u.%u", tmpIP.s_addr & 0xff, (tmpIP.s_addr >> 8) & 0xff, (tmpIP.s_addr >> 16) & 0xff, tmpIP.s_addr >> 24);
+                *iport = snat_config[i].private_port;
+
+                return 0;
+            }
+        }
+    }
+
+    return -1;
+}
+
+int getIfaceStats(struct ifdata * data)
+{
+    qmi_error_type_v01 qmi_err_num;
+    qcmap_msgr_ip_family_enum_v01 ip_family;
+    qcmap_msgr_wwan_statistics_type_v01 wwan_stats;
+    qcmap_msgr_data_bitrate_v01 data_rate;
+
+    memset(&wwan_stats, 0, sizeof(qcmap_msgr_wwan_statistics_type_v01));
+    memset(&data_rate, 0, sizeof(qcmap_msgr_data_bitrate_v01));
+
+    //IP family, IPV4-4 IPV6-6
+    ip_family = (qcmap_msgr_ip_family_enum_v01) 4;
+
+    if (QcMapClient->GetWWANStatistics(ip_family, &wwan_stats, &qmi_err_num))
+    {
+        data->baudrate = 4200000;	/* that is the answer */
+        data->opackets = wwan_stats.pkts_tx;
+        data->ipackets = wwan_stats.pkts_rx;
+        data->obytes = wwan_stats.bytes_tx;
+        data->ibytes = wwan_stats.bytes_rx;
+
+        if(QcMapClient->GetDataRate(&data_rate, &qmi_err_num))
+        {
+            data->downstream_bitrate = (unsigned long)(data_rate.max_rx_rate & 0xFFFFFFFF);
+            data->upstream_bitrate = (unsigned long)(data_rate.max_tx_rate & 0xFFFFFFFF);
+        }
+        return 0;
+    }
+
+    return -1;
+}
+
+int QCMAPClient(){
+    qmi_error_type_v01 qmi_err_num;
+    if(QcMapClient != NULL)
+    {
+        return 0;
+    }
+
+    QcMapClient = new QCMAP_Client(NULL);
+    QcMapClient->EnableMobileAP(&qmi_err_num);
+    return 1;
+}
+
+int tearDownQCMAPClient(){
+    qmi_error_type_v01 qmi_err_num;
+    if(QcMapClient == NULL)
+    {
+        return 0;
+    }
+
+    QcMapClient->DisableMobileAP(&qmi_err_num);
+    delete(QcMapClient);
+
+    return 1;
+}
+
+int getIPAddr(char *ext_ip_addr, int size){
+    qmi_error_type_v01 qmi_err_num;
+    in_addr public_ip;
+    in_addr primary_dns;
+    in_addr secondary_dns;
+    in_addr tmpIP;
+
+    memset(&public_ip,0,sizeof(in_addr));
+    memset(&primary_dns,0,sizeof(in_addr));
+    memset(&secondary_dns,0,sizeof(in_addr));
+
+    if (QcMapClient->GetIPv4NetworkConfiguration((in_addr_t *)&public_ip.s_addr,
+                                 (uint32 *)&primary_dns.s_addr,
+                                 (in_addr_t *)&secondary_dns.s_addr,
+                                 &qmi_err_num))
+    {
+        if ( public_ip.s_addr != 0 )
+        {
+            tmpIP.s_addr = ntohl(public_ip.s_addr);
+            snprintf(ext_ip_addr, size,"%u.%u.%u.%u", tmpIP.s_addr & 0xff, (tmpIP.s_addr >> 8) & 0xff, (tmpIP.s_addr >> 16) & 0xff, tmpIP.s_addr >> 24);
+            return 0;
+        }
+    }
+
+    return -1;
+}
+
+/**
+ * get the connection status
+ * return values :
+ *  0 - Unconfigured
+ *  1 - Connecting
+ *  2 - Connected
+ *  3 - PendingDisconnect
+ *  4 - Disconnecting
+ *  5 - Disconnected */
+int getWanStatus()
+{
+    int r = 0;
+    qcmap_msgr_wwan_call_type_v01 call_type = QCMAP_MSGR_WWAN_CALL_TYPE_V4_V01;
+    qmi_error_type_v01 qmi_err_num;
+    qcmap_msgr_wwan_status_enum_v01 v4_status, v6_status;
+
+    if (QcMapClient->GetWWANStatus(&v4_status, &v6_status, &qmi_err_num))
+    {
+        if ( v4_status != NULL)
+        {
+            if(v4_status == QCMAP_MSGR_WWAN_STATUS_CONNECTING_V01)
+            {
+                r = 1;
+            }
+            else if(v4_status == QCMAP_MSGR_WWAN_STATUS_CONNECTED_V01)
+            {
+                r = 2;
+            }
+            else if(v4_status == QCMAP_MSGR_WWAN_STATUS_DISCONNECTING_V01)
+            {
+                r = 4;
+            }
+            else if(v4_status == QCMAP_MSGR_WWAN_STATUS_DISCONNECTED_V01)
+            {
+                r = 5;
+            }
+        }
+        //else if ( v6_status != NULL)
+        //{
+            //if(v6_status == QCMAP_MSGR_WWAN_STATUS_IPV6_CONNECTING_V01)
+            //{
+                //r = 1;
+            //}
+            //else if(v6_status == QCMAP_MSGR_WWAN_STATUS_IPV6_CONNECTED_V01)
+            //{
+                //r = 2;
+            //}
+            //else if(v6_status == QCMAP_MSGR_WWAN_STATUS_IPV6_DISCONNECTING_V01)
+            //{
+                //r = 4;
+            //}
+            //else if(v6_status == QCMAP_MSGR_WWAN_STATUS_IPV6_DISCONNECTED_V01)
+            //{
+                //r = 5;
+            //}
+        //}
+    }
+
+	return r;
+}
+
+const char *getWanStatusStr()
+{
+	int status;
+	const char * str = NULL;
+
+	status = getWanStatus();
+
+	switch(status) {
+	case 0:
+		str = "Unconfigured";
+		break;
+	case 1:
+		str = "Connecting";
+		break;
+	case 2:
+		str = "Connected";
+		break;
+	case 3:
+		str = "PendingDisconnect";
+		break;
+	case 4:
+		str = "Disconnecting";
+		break;
+	case 5:
+		str = "Disconnected";
+		break;
+	}
+
+	return str;
+}
+
+/* IPTables cannot store redirection descriptions, so we use our
+ * own structure to store them */
+struct rdr_desc {
+	struct rdr_desc * next;
+	unsigned int timestamp;
+	unsigned short eport;
+	short proto;
+	char str[];
+};
+
+/* pointer to the chained list where descriptions are stored */
+static struct rdr_desc * rdr_desc_list = 0;
+
+/* add a description to the list of redirection descriptions */
+void
+add_redirect_desc(unsigned short eport, int proto,
+                  const char * desc, unsigned int timestamp)
+{
+	struct rdr_desc * p;
+	size_t l;
+	/* set a default description if none given */
+	if(!desc)
+		desc = "miniupnpd";
+	l = strlen(desc) + 1;
+	p = (rdr_desc*) malloc(sizeof(struct rdr_desc) + l);
+	if(p)
+	{
+		p->next = rdr_desc_list;
+		p->timestamp = timestamp;
+		p->eport = eport;
+		p->proto = (short)proto;
+		memcpy(p->str, desc, l);
+		rdr_desc_list = p;
+	}
+}
+
+/* delete a description from the list */
+void
+del_redirect_desc(unsigned short eport, int proto)
+{
+	struct rdr_desc * p, * last;
+	p = rdr_desc_list;
+	last = 0;
+	while(p)
+	{
+		if(p->eport == eport && p->proto == proto)
+		{
+			if(!last)
+				rdr_desc_list = p->next;
+			else
+				last->next = p->next;
+			free(p);
+			return;
+		}
+		last = p;
+		p = p->next;
+	}
+}
+
+/* go through the list to find the description */
+void
+get_redirect_desc(unsigned short eport, int proto,
+                  char * desc, int desclen,
+                  unsigned int * timestamp)
+{
+	struct rdr_desc * p;
+	for(p = rdr_desc_list; p; p = p->next)
+	{
+		if(p->eport == eport && p->proto == (short)proto)
+		{
+			if(desc)
+				strncpy(desc, p->str, desclen);
+			if(timestamp)
+				*timestamp = p->timestamp;
+			return;
+		}
+	}
+	/* if no description was found, return miniupnpd as default */
+	if(desc)
+		strncpy(desc, "miniupnpd", desclen);
+	if(timestamp)
+		*timestamp = 0;
+}
+
+#ifdef __cplusplus
+       }
+#endif
\ No newline at end of file
diff --git a/UPNP_QCMAP_Client.h b/UPNP_QCMAP_Client.h
new file mode 100644
index 0000000..d08dc45
--- /dev/null
+++ b/UPNP_QCMAP_Client.h
@@ -0,0 +1,62 @@
+/*
+Copyright (c) 2013, The Linux Foundation. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+    * Neither the name of The Linux Foundation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "QCMAP_Client.h"
+#include "qualcomm_mobile_access_point_msgr_v01.h"
+extern "C" {
+
+   int addStaticNatEntry_wrapper
+   (
+      struct in_addr    addr,
+      unsigned int      proto,
+      unsigned int      local_port,
+      unsigned int      g_port
+   );
+
+   int deleteStaticNatEntry_wrapper
+   (
+      unsigned short port,
+      int proto
+   );
+
+   int getStaticNatConfigByEntry
+   (
+      int index,
+      char *addr,
+      int addrlen,
+      unsigned short *eport,
+      unsigned short *iport,
+      int *proto
+   );
+
+   int getIfaceStats
+   (
+      struct ifdata * data
+   );
+#endif
\ No newline at end of file
diff --git a/config.h b/config.h
new file mode 100644
index 0000000..e31d95e
--- /dev/null
+++ b/config.h
@@ -0,0 +1,103 @@
+/* MiniUPnP Project
+ * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
+ * (c) 2006-2012 Thomas Bernard
+ * generated by ./genconfig.sh on Mon Dec 17 11:25:57 PST 2012
+ * using command line options  */
+#ifndef CONFIG_H_INCLUDED
+#define CONFIG_H_INCLUDED
+
+#include <inttypes.h>
+
+#define MINIUPNPD_VERSION "1.7"
+
+#define UPNP_VERSION	"20121217"
+#define USE_IFACEWATCHER 1
+#define USE_NETFILTER 0
+#define SUPPORT_REMOTEHOST
+
+#define OS_NAME		"Ubuntu"
+#define OS_VERSION	"Ubuntu/lucid"
+#define OS_URL		"http://www.ubuntu.com/"
+
+/* syslog facility to be used by miniupnpd */
+#define LOG_MINIUPNPD		 LOG_DAEMON
+
+/* Uncomment the following line to allow miniupnpd to be
+ * controlled by miniupnpdctl */
+/*#define USE_MINIUPNPDCTL*/
+
+/* Comment the following line to disable NAT-PMP operations */
+#define ENABLE_NATPMP
+
+/* Uncomment the following line to enable generation of
+ * filter rules with pf */
+/*#define PF_ENABLE_FILTER_RULES*/
+
+/* Uncomment the following line to enable caching of results of
+ * the getifstats() function */
+/*#define ENABLE_GETIFSTATS_CACHING*/
+/* The cache duration is indicated in seconds */
+#define GETIFSTATS_CACHING_DURATION 2
+
+/* Uncomment the following line to enable multiple external ip support */
+/* note : That is EXPERIMENTAL, do not use that unless you know perfectly what you are doing */
+/* Dynamic external ip adresses are not supported when this option is enabled.
+ * Also note that you would need to configure your .conf file accordingly. */
+/*#define MULTIPLE_EXTERNAL_IP*/
+
+/* Comment the following line to use home made daemonize() func instead
+ * of BSD daemon() */
+#define USE_DAEMON
+
+/* Uncomment the following line to enable lease file support */
+/*#define ENABLE_LEASEFILE*/
+
+/* Define one or none of the two following macros in order to make some
+ * clients happy. It will change the XML Root Description of the IGD.
+ * Enabling the Layer3Forwarding Service seems to be the more compatible
+ * option. */
+/*#define HAS_DUMMY_SERVICE*/
+#define ENABLE_L3F_SERVICE
+
+/* Enable IP v6 support */
+/*#define ENABLE_IPV6*/
+
+/* Enable the support of IGD v2 specification.
+ * This is not fully tested yet and can cause incompatibilities with some
+ * control points, so enable with care. */
+/*#define IGD_V2*/
+
+#ifdef IGD_V2
+/* Enable DeviceProtection service (IGDv2) */
+#define ENABLE_DP_SERVICE
+
+/* Enable WANIPv6FirewallControl service (IGDv2). needs IPv6 */
+#ifdef ENABLE_IPV6
+#define ENABLE_6FC_SERVICE
+#endif /* ENABLE_IPV6 */
+#endif /* IGD_V2 */
+
+/* UPnP Events support. Working well enough to be enabled by default.
+ * It can be disabled to save a few bytes. */
+#define ENABLE_EVENTS
+
+/* include interface name in pf and ipf rules */
+#define USE_IFNAME_IN_RULES
+
+/* Experimental NFQUEUE support. */
+/*#define ENABLE_NFQUEUE*/
+
+/* Enable to make MiniUPnPd more strict about UPnP conformance
+ * and the messages it receives from control points */
+#define UPNP_STRICT
+
+/* Add the optional Date: header in all HTTP responses */
+/*#define ENABLE_HTTP_DATE*/
+
+/* disable reading and parsing of config file (miniupnpd.conf) */
+/*#define DISABLE_CONFIG_FILE*/
+
+/* Enable QCMAP */
+#define QCMAP
+
+#endif
diff --git a/getifstats.h b/getifstats.h
index e14b853..cecaa49 100644
--- a/getifstats.h
+++ b/getifstats.h
@@ -7,12 +7,18 @@
 #ifndef GETIFSTATS_H_INCLUDED
 #define GETIFSTATS_H_INCLUDED

+#include "config.h"
+
 struct ifdata {
	unsigned long opackets;
	unsigned long ipackets;
	unsigned long obytes;
	unsigned long ibytes;
	unsigned long baudrate;
+#ifdef QCMAP
+	unsigned long upstream_bitrate;
+	unsigned long downstream_bitrate;
+#endif
 };

 /* getifstats()
diff --git a/linux/miniupnpd.init.d.script b/linux/miniupnpd.init.d.script
index ee6e47b..b29c249 100644
--- a/linux/miniupnpd.init.d.script
+++ b/linux/miniupnpd.init.d.script
@@ -18,33 +18,18 @@ set -e
 MINIUPNPD=/usr/sbin/miniupnpd
 ARGS='-f /etc/miniupnpd/miniupnpd.conf'

-IPTABLES_CREATE=/etc/miniupnpd/iptables_init.sh
-IPTABLES_REMOVE=/etc/miniupnpd/iptables_removeall.sh
-
 test -f $MINIUPNPD || exit 0
 
-. /lib/lsb/init-functions
-
 case "$1" in
   start)
-	log_daemon_msg "Starting miniupnpd" "miniupnpd"
-	$IPTABLES_CREATE > /dev/null 2>&1
 	start-stop-daemon --start --quiet --pidfile /var/run/miniupnpd.pid --startas $MINIUPNPD -- $ARGS $LSBNAMES
-	log_end_msg $?
 	;;
   stop)
-	log_daemon_msg "Stopping miniupnpd" "miniupnpd"
 	start-stop-daemon --stop --quiet --pidfile /var/run/miniupnpd.pid
-	log_end_msg $?
-	$IPTABLES_REMOVE > /dev/null 2>&1
 	;;
   restart|reload|force-reload)
-	log_daemon_msg "Restarting miniupnpd" "miniupnpd"
 	start-stop-daemon --stop --retry 5 --quiet --pidfile /var/run/miniupnpd.pid
-	$IPTABLES_REMOVE > /dev/null 2>&1
-	$IPTABLES_CREATE > /dev/null 2>&1
 	start-stop-daemon --start --quiet --pidfile /var/run/miniupnpd.pid --startas $MINIUPNPD -- $ARGS $LSBNAMES
-	log_end_msg $?
 	;;
   status)
 	status_of_proc /usr/sbin/miniupnpd miniupnpd
diff --git a/minissdp.c b/minissdp.c
index 934d9ca..8645524 100644
--- a/minissdp.c
+++ b/minissdp.c
@@ -484,6 +484,16 @@ SendSSDPNotify(int s, const struct sockaddr * dest,
 }
 
 static void
+_usleep(long usecs)
+{
+	struct timespec sleep_time;
+
+	sleep_time.tv_sec = 0;
+	sleep_time.tv_nsec = usecs * 1000;
+	nanosleep(&sleep_time, NULL);
+}
+
+static void
 SendSSDPNotifies(int s, const char * host, unsigned short port,
                  unsigned int lifetime, int ipv6)
 {
@@ -492,7 +502,7 @@ SendSSDPNotifies(int s, const char * host, unsigned short port,
 #else
 	struct sockaddr_in sockname;
 #endif
-	int i=0;
+	int dup, i=0;
 	char ver_str[4];

	memset(&sockname, 0, sizeof(sockname));
@@ -513,22 +523,30 @@ SendSSDPNotifies(int s, const char * host, unsigned short port,
 		p->sin_addr.s_addr = inet_addr(SSDP_MCAST_ADDR);
 	}

-	while(known_service_types[i].s)
-	{
-		if(i==0)
-			ver_str[0] = '\0';
-		else
-			snprintf(ver_str, sizeof(ver_str), "%d", known_service_types[i].version);
-		SendSSDPNotify(s, (struct sockaddr *)&sockname, host, port,
-		               known_service_types[i].s, ver_str,	/* NT: */
-		               uuidvalue, "::", known_service_types[i].s, /* ver_str,	USN: */
-		               lifetime, ipv6);
-		if(i==0) /* rootdevice */
-			SendSSDPNotify(s, (struct sockaddr *)&sockname, host, port,
-			               uuidvalue, "",	/* NT: */
-			               uuidvalue, "", "", /* ver_str,	USN: */
-			               lifetime, ipv6);
-		i++;
+
+	for( dup=0; dup<2; dup++ )
+	{
+
+		if( dup )
+			_usleep(200000);
+		i=0;
+    	while(known_service_types[i].s)
+    	{
+    		if(i==0)
+    			ver_str[0] = '\0';
+    		else
+    			snprintf(ver_str, sizeof(ver_str), "%d", known_service_types[i].version);
+    		SendSSDPNotify(s, (struct sockaddr *)&sockname, host, port,
+    		               known_service_types[i].s, ver_str,	/* NT: */
+    		               uuidvalue, "::", known_service_types[i].s, /* ver_str,	USN: */
+    		               lifetime, ipv6);
+    		if(i==0) /* rootdevice */
+    			SendSSDPNotify(s, (struct sockaddr *)&sockname, host, port,
+    			               uuidvalue, "",	/* NT: */
+    			               uuidvalue, "", "", /* ver_str,	USN: */
+    			               lifetime, ipv6);
+    		i++;
+		}
 	}
 }
 
@@ -849,7 +867,7 @@ SendSSDPGoodbye(int * sockets, int n_sockets)
 #endif
 	int i, j;
 	char ver_str[4];
-	int ret = 0;
+	int dup, ret = 0;
 	int ipv6 = 0;

     memset(&sockname, 0, sizeof(struct sockaddr_in));
@@ -863,39 +881,42 @@ SendSSDPGoodbye(int * sockets, int n_sockets)
 	inet_pton(AF_INET6, LL_SSDP_MCAST_ADDR, &(sockname6.sin6_addr));
 #endif
 
-	for(j=0; j<n_sockets; j++)
+	for (dup = 0; dup < 2; dup++)
 	{
+		for(j=0; j<n_sockets; j++)
+		{
 #ifdef ENABLE_IPV6
-		ipv6 = j & 1;
+			ipv6 = j & 1;
 #endif
-	    for(i=0; known_service_types[i].s; i++)
-	    {
-			if(i==0)
-				ver_str[0] = '\0';
-			else
-				snprintf(ver_str, sizeof(ver_str), "%d", known_service_types[i].version);
-			ret += SendSSDPbyebye(sockets[j],
+			for(i=0; known_service_types[i].s; i++)
+			{
+				if(i==0)
+					ver_str[0] = '\0';
+				else
+					snprintf(ver_str, sizeof(ver_str), "%d", known_service_types[i].version);
+				ret += SendSSDPbyebye(sockets[j],
 #ifdef ENABLE_IPV6
-			                      ipv6 ? (struct sockaddr *)&sockname6 : (struct sockaddr *)&sockname,
+									  ipv6 ? (struct sockaddr *)&sockname6 : (struct sockaddr *)&sockname,
 #else
-			                      (struct sockaddr *)&sockname,
+									  (struct sockaddr *)&sockname,
 #endif
-			                      known_service_types[i].s, ver_str,	/* NT: */
-			                      uuidvalue, "::", known_service_types[i].s, /* ver_str, USN: */
-			                      ipv6);
-			if(i==0)	/* root device */
-			{
-				ret += SendSSDPbyebye(sockets[j],
+									  known_service_types[i].s, ver_str,	/* NT: */
+									  uuidvalue, "::", known_service_types[i].s, /* ver_str, USN: */
+									  ipv6);
+				if(i==0)	/* root device */
+				{
+					ret += SendSSDPbyebye(sockets[j],
 #ifdef ENABLE_IPV6
-				                      ipv6 ? (struct sockaddr *)&sockname6 : (struct sockaddr *)&sockname,
+										  ipv6 ? (struct sockaddr *)&sockname6 : (struct sockaddr *)&sockname,
 #else
-				                      (struct sockaddr *)&sockname,
+										  (struct sockaddr *)&sockname,
 #endif
-				                      uuidvalue, "",	/* NT: */
-				                      uuidvalue, "", "", /* ver_str, USN: */
-				                      ipv6);
+										  uuidvalue, "",	/* NT: */
+										  uuidvalue, "", "", /* ver_str, USN: */
+										  ipv6);
+				}
 			}
-    	}
+		}
 	}
 	return ret;
 }
diff --git a/miniupnpd.c b/miniupnpd.c
index 1dd3ff3..1243568 100644
--- a/miniupnpd.c
+++ b/miniupnpd.c
@@ -1079,7 +1079,11 @@ init(int argc, char * * argv, struct runtime_vars * v)
 			fprintf(stderr, "Unknown option: %s\n", argv[i]);
 		}
 	}
-	if(!ext_if_name || !lan_addrs.lh_first)
+	if(
+#ifndef QCMAP
+           !ext_if_name ||
+#endif
+           !lan_addrs.lh_first)
 	{
 		/* bad configuration */
 		goto print_usage;
@@ -1161,9 +1165,15 @@ init(int argc, char * * argv, struct runtime_vars * v)
 		syslog(LOG_NOTICE, "Failed to set %s handler", "SIGUSR1");
 	}
 
+#ifndef QCMAP
	if(init_redirect() < 0)
 	{
		syslog(LOG_ERR, "Failed to init redirection engine. EXITING");
+#else
+	if(!QCMAPClient())
+	{
+		syslog(LOG_ERR, "Failed to init QCMAP. EXITING");
+#endif
 		return 1;
 	}
 #ifdef ENABLE_6FC_SERVICE
@@ -1329,14 +1339,22 @@ main(int argc, char * * argv)
 		return 0;
 	}

+#ifndef QCMAP
	syslog(LOG_INFO, "Starting%s%swith external interface %s",
+#else
+	syslog(LOG_INFO, "Starting%s%swith external interface",
+#endif
 #ifdef ENABLE_NATPMP
 	       GETFLAG(ENABLENATPMPMASK) ? " NAT-PMP " : " ",
 #else
 	       " ",
 #endif
-	       GETFLAG(ENABLEUPNPMASK) ? "UPnP-IGD " : "",
-	       ext_if_name);
+	       GETFLAG(ENABLEUPNPMASK) ? "UPnP-IGD " : ""
+#ifndef QCMAP
+               ,ext_if_name);
+#else
+               );
+#endif

 	if(GETFLAG(ENABLEUPNPMASK))
 	{
@@ -1867,6 +1885,14 @@ main(int argc, char * * argv)
 	}	/* end of main loop */

 shutdown:
+#ifdef QCMAP
+        /* Tear Down QCMap Client */
+	if(!tearDownQCMAPClient())
+	{
+		syslog(LOG_ERR, "Unable to tear down QCMAP Client");
+	}
+#endif
+
 	/* close out open sockets */
 	while(upnphttphead.lh_first != NULL)
 	{
diff --git a/miniupnpd.conf b/miniupnpd.conf
old mode 100644
new mode 100755
index e34e088..ad8757e
--- a/miniupnpd.conf
+++ b/miniupnpd.conf
@@ -1,6 +1,6 @@
 # WAN network interface
-ext_ifname=eth1
-#ext_ifname=xl1
+#ext_ifname=eth1
+
 # if the WAN interface has several IP addresses, you
 # can specify the one to use below
 #ext_ip=
@@ -15,8 +15,7 @@ ext_ifname=eth1
 # address associated with the subnet follows. for example :
 #  listening_ip=192.168.0.1/24 88.22.44.13
 #listening_ip=192.168.0.1/24
-listening_ip=192.168.10.109/24
-#listening_ip=eth0
+listening_ip=bridge0
 # port for HTTP (descriptions and SOAP) traffic. set 0 for autoselect.
 port=0
 
@@ -40,11 +39,11 @@ enable_upnp=yes
 #lease_file=/var/log/upnp.leases
 
 # name of this service, default is "`uname -s` Router"
-#friendly_name=MiniUPnPd router
+friendly_name=9x25 MobileAP UPnP
 
 # bitrates reported by daemon in bits per second
-bitrate_up=1000000
-bitrate_down=10000000
+#bitrate_up=1000000
+#bitrate_down=10000000

 # "secure" mode : when enabled, UPnP client are allowed to add mappings only
 # to their IP.
@@ -91,7 +90,7 @@ clean_ruleset_interval=600
 #quickrules=no

 # uuid : generate your own with "make genuuid"
-uuid=3d3cec3a-8cf0-11e0-98ee-001a6bd2d07b
+uuid=e3c41abc-5951-4924-a650-b49ded3450dc

 # serial and model number the daemon will report to clients
 # in its XML description
@@ -105,9 +104,9 @@ model_number=1
 # ip/mask format must be nn.nn.nn.nn/nn
 # it is advised to only allow redirection of port above 1024
 # and to finish the rule set with "deny 0-65535 0.0.0.0/0 0-65535"
-allow 1024-65535 192.168.0.0/24 1024-65535
-allow 1024-65535 192.168.1.0/24 1024-65535
-allow 1024-65535 192.168.0.0/23 22
-allow 12345 192.168.7.113/32 54321
-deny 0-65535 0.0.0.0/0 0-65535
+#allow 1024-65535 192.168.0.0/24 0-65535
+#allow 1024-65535 192.168.1.0/24 1024-65535
+#allow 1024-65535 192.168.0.0/23 22
+#allow 12345 192.168.7.113/32 54321
+allow 0-65535 0.0.0.0/0 0-65535
 
diff --git a/natpmp.c b/natpmp.c
index 2add04a..55d7fb4 100644
--- a/natpmp.c
+++ b/natpmp.c
@@ -203,6 +203,7 @@ void ProcessIncomingNATPMPPacket(int s)
 				/* remove the mapping */
 				if(iport == 0) {
 					/* remove all the mappings for this client */
+#ifndef QCMAP
					int index = 0;
					unsigned short eport2, iport2;
					char iaddr2[16];
@@ -230,6 +231,7 @@ void ProcessIncomingNATPMPPacket(int s)
							index++;
						}
					}
+#endif
 				} else {
 					/* To improve the interworking between nat-pmp and
 					 * UPnP, we should check that we remove only NAT-PMP
@@ -247,10 +249,14 @@ void ProcessIncomingNATPMPPacket(int s)
 			   || !check_upnp_rule_against_permissions(upnppermlist, num_upnpperm, eport, senderaddr.sin_addr, iport)) {
 				resp[3] = 2;	/* Not Authorized/Refused */
 			} else do {
+#ifndef QCMAP
				r = get_redirect_rule(ext_if_name, eport, proto,
				                      iaddr_old, sizeof(iaddr_old),
				                      &iport_old, 0, 0, 0, 0,
				                      &timestamp, 0, 0);
+#else
+                                r=0;
+#endif
 				if(r==0) {
 					if(strcmp(senderaddrstr, iaddr_old)==0
 				       && iport==iport_old) {
@@ -279,9 +285,14 @@ void ProcessIncomingNATPMPPacket(int s)
 					         eport, (proto==IPPROTO_TCP)?"tcp":"udp");
 #endif
 					/* TODO : check return code */
-					if(upnp_redirect_internal(NULL, eport, senderaddrstr,
-					                          iport, proto, desc,
-					                          timestamp) < 0) {
+					if(upnp_redirect_internal(
+#ifndef QCMAP
+                                                                  NULL,
+#endif
+                                                                  eport, senderaddrstr,
+					                          iport, proto
+                                                                  , desc, timestamp
+                                                                  ) < 0) {
 						syslog(LOG_ERR, "Failed to add NAT-PMP %hu %s->%s:%hu '%s'",
 						       eport, (proto==IPPROTO_TCP)?"tcp":"udp", senderaddrstr, iport, desc);
 						resp[3] = 3;  /* Failure */
diff --git a/upnpdescgen.c b/upnpdescgen.c
index 754e06d..2f37a59 100644
--- a/upnpdescgen.c
+++ b/upnpdescgen.c
@@ -1151,7 +1151,11 @@ genEventVars(int * len, const struct serviceDesc * s, const char * servns)
 	str = strcat_str(str, len, &tmplen, "\">");
 	while(v->name) {
 		if(v->itype & 0x80) {
+#ifndef QCMAP
			str = strcat_str(str, len, &tmplen, "<e:property><s:");
+#else
+			str = strcat_str(str, len, &tmplen, "<e:property><");
+#endif
 			str = strcat_str(str, len, &tmplen, v->name);
 			str = strcat_str(str, len, &tmplen, ">");
 			/*printf("<e:property><s:%s>", v->name);*/
@@ -1161,7 +1165,11 @@ genEventVars(int * len, const struct serviceDesc * s, const char * servns)
 			case CONNECTIONSTATUS_MAGICALVALUE:
 				/* or get_wan_connection_status_str(ext_if_name) */
 				str = strcat_str(str, len, &tmplen,
+#ifndef QCMAP
				   upnpallowedvalues[18 + get_wan_connection_status(ext_if_name)]);
+#else
+                                   upnpallowedvalues[18 + getWanStatus()]);
+#endif
 				break;
 #ifdef ENABLE_6FC_SERVICE
 			case FIREWALLENABLED_MAGICALVALUE:
@@ -1198,7 +1206,11 @@ genEventVars(int * len, const struct serviceDesc * s, const char * servns)
 					str = strcat_str(str, len, &tmplen, use_ext_ip_addr);
 				else {
 					char ext_ip_addr[INET_ADDRSTRLEN];
+#ifndef QCMAP
					if(getifaddr(ext_if_name, ext_ip_addr, INET_ADDRSTRLEN, NULL, NULL) < 0) {
+#else
+                                        if(getIPAddr(ext_ip_addr, INET_ADDRSTRLEN) < 0) {
+#endif
 						str = strcat_str(str, len, &tmplen, "0.0.0.0");
 					} else {
 						str = strcat_str(str, len, &tmplen, ext_ip_addr);
@@ -1217,7 +1229,11 @@ genEventVars(int * len, const struct serviceDesc * s, const char * servns)
 			default:
 				str = strcat_str(str, len, &tmplen, upnpallowedvalues[v->ieventvalue]);
 			}
+#ifndef QCMAP
			str = strcat_str(str, len, &tmplen, "</s:");
+#else
+			str = strcat_str(str, len, &tmplen, "</");
+#endif
 			str = strcat_str(str, len, &tmplen, v->name);
 			str = strcat_str(str, len, &tmplen, "></e:property>");
 			/*printf("</s:%s></e:property>\n", v->name);*/
diff --git a/upnpredirect.c b/upnpredirect.c
index 5c9beae..8905d7e 100644
--- a/upnpredirect.c
+++ b/upnpredirect.c
@@ -255,7 +255,11 @@ int reload_from_lease_file()
  *          -3 permission check failed
  */
 int
+#ifndef QCMAP
 upnp_redirect(const char * rhost, unsigned short eport,
+#else
+upnp_redirect(/*const char * rhost,*/unsigned short eport,
+#endif
               const char * iaddr, unsigned short iport,
               const char * protocol, const char * desc,
               unsigned int leaseduration)
@@ -278,6 +282,7 @@ upnp_redirect(const char * rhost, unsigned short eport,
 		                 "%hu->%s:%hu %s", eport, iaddr, iport, protocol);
 		return -3;
 	}
+#ifndef QCMAP
	r = get_redirect_rule(ext_if_name, eport, proto,
	                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,
	                      0, 0,
@@ -295,32 +300,45 @@ upnp_redirect(const char * rhost, unsigned short eport,
			return -2;
		}
	} else {
+#endif
		timestamp = (leaseduration > 0) ? time(NULL) + leaseduration : 0;
		syslog(LOG_INFO, "redirecting port %hu to %s:%hu protocol %s for: %s",
			eport, iaddr, iport, protocol, desc);
+#ifdef QCMAP
+	return upnp_redirect_internal(eport, iaddr, iport, proto, desc, timestamp);
+#else
		return upnp_redirect_internal(rhost, eport, iaddr, iport, proto,
		                              desc, timestamp);
 	}
+#endif

	return 0;
 }
 
 int
-upnp_redirect_internal(const char * rhost, unsigned short eport,
+upnp_redirect_internal(
+#ifndef QCMAP
+                       const char * rhost,
+#endif
+                       unsigned short eport,
                        const char * iaddr, unsigned short iport,
-                       int proto, const char * desc,
+                       int proto,
+                       const char * desc,
                        unsigned int timestamp)
 {
+#ifndef QCMAP
	/*syslog(LOG_INFO, "redirecting port %hu to %s:%hu protocol %s for: %s",
		eport, iaddr, iport, protocol, desc);			*/
	if(add_redirect_rule2(ext_if_name, rhost, eport, iaddr, iport, proto,
	                      desc, timestamp) < 0) {
		return -1;
	}
+#endif
 
 #ifdef ENABLE_LEASEFILE
	lease_file_add( eport, iaddr, iport, proto, desc, timestamp);
 #endif
+#ifndef QCMAP
 /*	syslog(LOG_INFO, "creating pass rule to %s:%hu protocol %s for: %s",
		iaddr, iport, protocol, desc);*/
	if(add_filter_rule2(ext_if_name, rhost, iaddr, eport, iport, proto, desc) < 0) {
@@ -328,8 +346,17 @@ upnp_redirect_internal(const char * rhost, unsigned short eport,
 #if !defined(__linux__)
		delete_redirect_rule(ext_if_name, eport, proto);
 #endif
+#else
+	struct in_addr address;
+
+	if(inet_aton(iaddr, &address) < 0) {
+		syslog(LOG_ERR, "inet_aton(%s) : %m", iaddr);
 		return -1;
 	}
+        if(addStaticNatEntry_wrapper(address, proto, iport, eport) < 0)
+                return -1;
+	add_redirect_desc(eport, proto, desc, timestamp);
+#endif
	if(timestamp > 0) {
		if(!nextruletoclean_timestamp || (timestamp < nextruletoclean_timestamp))
			nextruletoclean_timestamp = timestamp;
@@ -361,17 +388,30 @@ upnp_get_redirection_infos(unsigned short eport, const char * protocol,
 		desc[0] = '\0';
 	if(rhost && (rhostlen > 0))
 		rhost[0] = '\0';
+#ifndef QCMAP
	r = get_redirect_rule(ext_if_name, eport, proto_atoi(protocol),
	                      iaddr, iaddrlen, iport, desc, desclen,
	                      rhost, rhostlen, &timestamp,
	                      0, 0);
	if(r == 0 &&
	   timestamp > 0 &&
+#else
+	r = getSpecificEntry( eport, proto_atoi(protocol),
+	                      iaddr, iaddrlen, iport,
+	                      rhost, rhostlen, &timestamp);
+	if (r == 0) {
+		get_redirect_desc(eport, proto_atoi(protocol), desc, desclen, &timestamp);
+
+		if(timestamp > 0 &&
+#endif
 	   timestamp > (unsigned int)(current_time = time(NULL))) {
 		*leaseduration = timestamp - current_time;
 	} else {
 		*leaseduration = 0;
 	}
+#ifdef QCMAP
+        }
+#endif
 	return r;
 }

@@ -393,13 +433,20 @@ upnp_get_redirection_infos_by_index(int index,
 		desc[0] = '\0';
 	if(rhost && (rhostlen > 0))
 		rhost[0] = '\0';
+#ifndef QCMAP
	if(get_redirect_rule_by_index(index, 0/*ifname*/, eport, iaddr, iaddrlen,
	                              iport, &proto, desc, desclen,
	                              rhost, rhostlen, &timestamp,
	                              0, 0) < 0)
+#else
+	if (getStaticNatConfigByEntry(index, iaddr, iaddrlen, eport, iport, &proto) < 0)
+#endif
 		return -1;
 	else
 	{
+#ifdef QCMAP
+		get_redirect_desc(*eport, proto, desc, desclen, &timestamp);
+#endif
 		current_time = time(NULL);
 		*leaseduration = (timestamp > (unsigned int)current_time)
 		                 ? (timestamp - current_time)
@@ -418,8 +465,12 @@ _upnp_delete_redir(unsigned short eport, int proto)
 {
 	int r;
 #if defined(__linux__)
+#ifndef QCMAP
	r = delete_redirect_and_filter_rules(eport, proto);
 #else
+	r = deleteStaticNatEntry_wrapper( eport, proto);
+#endif
+#else
 	r = delete_redirect_rule(ext_if_name, eport, proto);
 	delete_filter_rule(ext_if_name, eport, proto);
 #endif
@@ -430,6 +481,10 @@ _upnp_delete_redir(unsigned short eport, int proto)
 #ifdef ENABLE_EVENTS
 	upnp_event_var_change_notify(EWanIPC);
 #endif
+#ifdef QCMAP
+	if ( r >= 0 )
+		del_redirect_desc(eport, proto);
+#endif
 	return r;
 }
 
@@ -482,11 +537,18 @@ get_upnp_rules_state_list(int max_rules_number_target)
 		return 0;
 	current_time = time(NULL);
 	nextruletoclean_timestamp = 0;
+#ifndef QCMAP
	while(get_redirect_rule_by_index(i, /*ifname*/0, &tmp->eport, 0, 0,
	                              &iport, &proto, 0, 0, 0,0, &timestamp,
								  &tmp->packets, &tmp->bytes) >= 0)
+#else
+	while(getStaticNatConfigByEntry(i, 0, 0, &tmp->eport, &iport, &proto) >= 0)
+#endif
 	{
 		tmp->to_remove = 0;
+#ifdef QCMAP
+		get_redirect_desc(tmp->eport, proto, 0, 0, &timestamp);
+#endif
 		if(timestamp > 0) {
 			/* need to remove this port mapping ? */
 			if(timestamp <= (unsigned int)current_time)
@@ -547,6 +609,7 @@ remove_unused_rules(struct rule_state * list)
 	while(list)
 	{
 		/* remove the rule if no traffic has used it */
+#ifndef QCMAP
		if(get_redirect_rule(ifname, list->eport, list->proto,
	                         0, 0, &iport, 0, 0, 0, 0, &timestamp,
		                     &packets, &bytes) >= 0)
@@ -557,6 +620,7 @@ remove_unused_rules(struct rule_state * list)
				n++;
			}
		}
+#endif
 		tmp = list;
 		list = tmp->next;
 		free(tmp);
@@ -569,8 +633,11 @@ remove_unused_rules(struct rule_state * list)
  * return a list of all "external" ports for which a port
  * mapping exists */
 unsigned short *
-upnp_get_portmappings_in_range(unsigned short startport,
+upnp_get_portmappings_in_range(
+#ifndef QCMAP
+                               unsigned short startport,
                                unsigned short endport,
+#endif
                                const char * protocol,
                                unsigned int * number)
 {
@@ -578,7 +645,11 @@ upnp_get_portmappings_in_range(unsigned short startport,
 	proto = proto_atoi(protocol);
 	if(!number)
 		return NULL;
+#ifndef QCMAP
	return get_portmappings_in_range(startport, endport, proto, number);
+#else
+        return NULL;
+#endif
 }
 
 /* stuff for miniupnpdctl */
diff --git a/upnpredirect.h b/upnpredirect.h
index b549824..db8f6ac 100644
--- a/upnpredirect.h
+++ b/upnpredirect.h
@@ -26,7 +26,11 @@ int reload_from_lease_file(void);
  *          -3 permission check failed
  */
 int
-upnp_redirect(const char * rhost, unsigned short eport,
+upnp_redirect(
+#ifndef QCMAP
+              const char * rhost,
+#endif
+              unsigned short eport,
               const char * iaddr, unsigned short iport,
               const char * protocol, const char * desc,
               unsigned int leaseduration);
@@ -34,10 +38,16 @@ upnp_redirect(const char * rhost, unsigned short eport,
 /* upnp_redirect_internal()
  * same as upnp_redirect() without any check */
 int
-upnp_redirect_internal(const char * rhost, unsigned short eport,
+upnp_redirect_internal(
+#ifndef QCMAP
+                       const char * rhost,
+#endif
+                       unsigned short eport,
                        const char * iaddr, unsigned short iport,
-                       int proto, const char * desc,
-                       unsigned int timestamp);
+                       int proto,
+                       const char * desc,
+                       unsigned int timestamp
+                       );
 
 /* upnp_get_redirection_infos()
  * returns : 0 on success
@@ -103,8 +113,11 @@ remove_unused_rules(struct rule_state * list);
  * return a list of all "external" ports for which a port
  * mapping exists */
 unsigned short *
-upnp_get_portmappings_in_range(unsigned short startport,
+upnp_get_portmappings_in_range(
+#ifndef QCMAP
+                               unsigned short startport,
                                unsigned short endport,
+#endif
                                const char * protocol,
                                unsigned int * number);
 
diff --git a/upnpsoap.c b/upnpsoap.c
old mode 100644
new mode 100755
index c61ea05..a05c18a
--- a/upnpsoap.c
+++ b/upnpsoap.c
@@ -88,8 +88,11 @@ GetTotalBytesSent(struct upnphttp * h, const char * action)
	char body[512];
 	int bodylen;
 	struct ifdata data;
-
+#ifndef QCMAP
	r = getifstats(ext_if_name, &data);
+#else
+	r = getIfaceStats(&data);
+#endif
 	bodylen = snprintf(body, sizeof(body), resp,
 	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
              r<0?0:data.obytes, action);
@@ -110,8 +113,11 @@ GetTotalBytesReceived(struct upnphttp * h, const char * action)
	char body[512];
 	int bodylen;
 	struct ifdata data;
-
+#ifndef QCMAP
	r = getifstats(ext_if_name, &data);
+#else
+	r = getIfaceStats(&data);
+#endif
 	bodylen = snprintf(body, sizeof(body), resp,
 	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
 	         r<0?0:data.ibytes, action);
@@ -132,8 +138,11 @@ GetTotalPacketsSent(struct upnphttp * h, const char * action)
	char body[512];
 	int bodylen;
 	struct ifdata data;
-
+#ifndef QCMAP
	r = getifstats(ext_if_name, &data);
+#else
+	r = getIfaceStats(&data);
+#endif
 	bodylen = snprintf(body, sizeof(body), resp,
 	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
 	         r<0?0:data.opackets, action);
@@ -154,8 +163,11 @@ GetTotalPacketsReceived(struct upnphttp * h, const char * action)
	char body[512];
 	int bodylen;
 	struct ifdata data;
-
+#ifndef QCMAP
	r = getifstats(ext_if_name, &data);
+#else
+	r = getIfaceStats(&data);
+#endif
 	bodylen = snprintf(body, sizeof(body), resp,
 	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
 	         r<0?0:data.ipackets, action);
@@ -184,6 +196,7 @@ GetCommonLinkProperties(struct upnphttp * h, const char * action)
	                             * Initializing, Unavailable (Optional) */
	char ext_ip_addr[INET_ADDRSTRLEN];

+#ifndef QCMAP
	if((downstream_bitrate == 0) || (upstream_bitrate == 0))
	{
		if(getifstats(ext_if_name, &data) >= 0)
@@ -193,6 +206,19 @@ GetCommonLinkProperties(struct upnphttp * h, const char * action)
 		}
 	}
	if(getifaddr(ext_if_name, ext_ip_addr, INET_ADDRSTRLEN, NULL, NULL) < 0) {
+#else
+	if(getIfaceStats(&data) >= 0)
+	{
+		downstream_bitrate = data.downstream_bitrate;
+		upstream_bitrate = data.upstream_bitrate;
+	}
+	else
+	{
+		downstream_bitrate = 0;
+		upstream_bitrate = 0;
+	}
+	if(getIPAddr(ext_ip_addr, INET_ADDRSTRLEN) < 0) {
+#endif
 		status = "Down";
 	}
 	bodylen = snprintf(body, sizeof(body), resp,
@@ -220,8 +246,11 @@ GetStatusInfo(struct upnphttp * h, const char * action)
	/* ConnectionStatus possible values :
 	 * Unconfigured, Connecting, Connected, PendingDisconnect,
 	 * Disconnecting, Disconnected */
-
+#ifndef QCMAP
	status = get_wan_connection_status_str(ext_if_name);
+#else
+	status = getWanStatusStr();
+#endif
 	uptime = (time(NULL) - startup_time);
 	bodylen = snprintf(body, sizeof(body), resp,
 		action, SERVICE_TYPE_WANIPC,
@@ -270,10 +299,16 @@ GetExternalIPAddress(struct upnphttp * h, const char * action)
 	{
 		strncpy(ext_ip_addr, use_ext_ip_addr, INET_ADDRSTRLEN);
 	}
+#ifndef QCMAP
	else if(getifaddr(ext_if_name, ext_ip_addr, INET_ADDRSTRLEN, NULL, NULL) < 0)
 	{
		syslog(LOG_ERR, "Failed to get ip address for interface %s",
			ext_if_name);
+#else
+	else if(getIPAddr(ext_ip_addr, INET_ADDRSTRLEN) < 0)
+	{
+		syslog(LOG_ERR, "Failed to get ip address for interface");
+#endif
 		strncpy(ext_ip_addr, "0.0.0.0", INET_ADDRSTRLEN);
 	}
 #else
@@ -410,7 +445,11 @@ AddPortMapping(struct upnphttp * h, const char * action)
 	       action, eport, int_ip, iport, protocol, desc, leaseduration,
 	       r_host ? r_host : "NULL");
 
-	r = upnp_redirect(r_host, eport, int_ip, iport, protocol, desc, leaseduration);
+	r = upnp_redirect(
+#ifndef QCMAP
+                          r_host,
+#endif
+                          eport, int_ip, iport, protocol, desc, leaseduration);
 
 	ClearNameValueList(&data);
 
@@ -546,7 +585,11 @@ AddAnyPortMapping(struct upnphttp * h, const char * action)
 	/* TODO : accept a different external port
 	 * have some smart strategy to choose the port */
 	for(;;) {
-		r = upnp_redirect(r_host, eport, int_ip, iport, protocol, desc, leaseduration);
+	                  r = upnp_redirect(
+#ifndef QCMAP
+                          r_host,
+#endif
+                          eport, int_ip, iport, protocol, desc, leaseduration);
 		if(r==-2 && eport < 65535) {
 			eport++;
 		} else {
@@ -764,7 +807,10 @@ DeletePortMappingRange(struct upnphttp * h, const char * action)
 		return;
 	}
 
-	port_list = upnp_get_portmappings_in_range(startport, endport,
+	port_list = upnp_get_portmappings_in_range(
+#ifndef QCMAP
+                                                   startport, endport,
+#endif
	                                           protocol, &number);
 	for(i = 0; i < number; i++)
 	{
@@ -974,7 +1020,10 @@ http://www.upnp.org/schemas/gw/WANIPConnection-v2.xsd">
 	memcpy(body+bodylen, list_start, sizeof(list_start));
 	bodylen += (sizeof(list_start) - 1);
 
-	port_list = upnp_get_portmappings_in_range(startport, endport,
+	port_list = upnp_get_portmappings_in_range(
+#ifndef QCMAP
+                                                   startport, endport,
+#endif
 	                                           protocol, &list_size);
 	/* loop through port mappings */
 	for(i = 0; number > 0 && i < list_size; i++)
@@ -1149,8 +1198,11 @@ QueryStateVariable(struct upnphttp * h, const char * action)
	else if(strcmp(var_name, "ConnectionStatus") == 0)
 	{
 		const char * status;
-
+#ifndef QCMAP
		status = get_wan_connection_status_str(ext_if_name);
+#else
+		status = getWanStatusStr();
+#endif
 		bodylen = snprintf(body, sizeof(body), resp,
                            action, "urn:schemas-upnp-org:control-1-0",
 		                   status, action);
-- 
1.7.8.3

