From 6f96c7f6d80dea530101fc914f2e5dca6324bc44 Mon Sep 17 00:00:00 2001
From: Tyler Wear <twear@codeaurora.org>
Date: Thu, 2 May 2013 17:42:31 -0700
Subject: [PATCH 1/1] qcmap-enabled

---
 Makefile.linux                |   92 ++++++++------
 UPNP_QCMAP_Client.cpp         |  282 +++++++++++++++++++++++++++++++++++++++++
 UPNP_QCMAP_Client.h           |   33 +++++
 config.h                      |  100 +++++++++++++++
 linux/miniupnpd.init.d.script |   15 --
 minissdp.c                    |  203 ++++++++++++++++-------------
 miniupnpd.c                   |   17 ++-
 miniupnpd.conf                |   21 ++--
 natpmp.c                      |   69 +++++-----
 upnpdescgen.c                 |    8 +-
 upnpredirect.c                |  162 ++++--------------------
 upnpredirect.h                |   14 +-
 upnpsoap.c                    |   41 +++---
 13 files changed, 695 insertions(+), 362 deletions(-)
 create mode 100644 UPNP_QCMAP_Client.cpp
 create mode 100644 UPNP_QCMAP_Client.h
 create mode 100644 config.h
 mode change 100644 => 100755 linux/miniupnpd.init.d.script

diff --git a/Makefile.linux b/Makefile.linux
index 3521a5a..0c6137a 100644
--- a/Makefile.linux
+++ b/Makefile.linux
@@ -29,10 +29,10 @@ CFLAGS += -Wall
 CFLAGS += -Wextra -Wstrict-prototypes -Wdeclaration-after-statement
 #CFLAGS += -Wno-missing-field-initializers
 #CFLAGS += -ansi	# iptables headers does use typeof which is a gcc extension
-CC ?= gcc
+#CC ?= gcc
 RM = rm -f
 INSTALL = install
-STRIP ?= strip
+#STRIP ?= strip
 CP = cp
 
 
@@ -48,13 +48,14 @@ BASEOBJS = miniupnpd.o upnphttp.o upnpdescgen.o upnpsoap.o \
            upnpevents.o upnputils.o getconnstatus.o \
            upnppinhole.o
 
-LNXOBJS = linux/getifstats.o linux/ifacewatcher.o linux/getroute.o
-NETFILTEROBJS = netfilter/iptcrdr.o netfilter/iptpinhole.o
+CPPOBJS = UPNP_QCMAP_Client.o
+		   
+LNXOBJS = linux/getifstats.o linux/ifacewatcher.o
 
 ALLOBJS = $(BASEOBJS) $(LNXOBJS) $(NETFILTEROBJS)
 
 ifeq "$(wildcard /etc/gentoo-release )" ""
-LIBS ?= -liptc
+#LIBS ?= -liptc
 else # gentoo
 # the following is better, at least on gentoo with iptables 1.4.6
 # see http://miniupnp.tuxfamily.org/forum/viewtopic.php?p=1618
@@ -65,8 +66,8 @@ endif
 
 ARCH ?= $(shell uname -m | grep -q "x86_64" && echo 64)
 ifdef IPTABLESPATH
-CFLAGS := $(CFLAGS) -I$(IPTABLESPATH)/include/
-LDFLAGS := $(LDFLAFGS) -L$(IPTABLESPATH)/libiptc/
+#CFLAGS := $(CFLAGS) -I$(IPTABLESPATH)/include/
+#LDFLAGS := $(LDFLAFGS) -L$(IPTABLESPATH)/libiptc/
 # get iptables version and set IPTABLES_143 macro if needed
 ifeq ($(TARGET_OPENWRT),)
 IPTABLESVERSION := $(shell grep "\#define VERSION" $(IPTABLESPATH)/config.h | tr -d \" |cut -d" " -f3 )
@@ -103,7 +104,7 @@ else # ifdef IPTABLESPATH
 TEST := $(shell test -f /usr/include/xtables.h && grep -q "XTABLES_VERSION_CODE" /usr/include/xtables.h && echo 1)
 ifeq ($(TEST), 1)
 CFLAGS := $(CFLAGS) -DIPTABLES_143
-LIBS = -liptc
+#LIBS = -liptc
 TESTIP4TC := $(shell test -f /lib/libip4tc.so && echo 1)
 ifeq ($(TESTIP4TC), 1)
 LIBS := $(LIBS) -lip4tc
@@ -115,13 +116,14 @@ endif # ($(TESTIP6TC), 1)
 endif # ($(TEST), 1)
 endif # ifdef IPTABLESPATH
 
-LIBS += -lnfnetlink
+#LIBS += -lnfnetlink

-TESTUPNPDESCGENOBJS = testupnpdescgen.o upnpdescgen.o
+LIBS += ${LIBDIR}/libqcmap_client.so.1
+LDFLAGS := $(LDFLAFGS) -L${LIBDIR}/libqcmap_client.so.1
+#CFLAGS += $(qcmap_client_inc)
 
-EXECUTABLES = miniupnpd testupnpdescgen testgetifstats \
+EXECUTABLES = miniupnpd testgetifstats \
               testupnppermissions miniupnpdctl testgetifaddr \
-              testgetroute
 
 .PHONY:	all clean install depend genuuid
 
@@ -130,26 +132,21 @@ all:	$(EXECUTABLES)
 clean:
 	$(RM) $(ALLOBJS)
 	$(RM) $(EXECUTABLES)
-	$(RM) testupnpdescgen.o testgetifstats.o
+	$(RM) UPNP_QCMAP_Client.o
+	$(RM) testgetifstats.o
 	$(RM) testupnppermissions.o testgetifaddr.o
-	$(RM) testgetroute.o
 	$(RM) miniupnpdctl.o
 
 install:	miniupnpd miniupnpd.8 miniupnpd.conf genuuid \
-	netfilter/iptables_init.sh netfilter/iptables_removeall.sh \
-	netfilter/ip6tables_init.sh netfilter/ip6tables_removeall.sh \
 	linux/miniupnpd.init.d.script
 	$(STRIP) miniupnpd
 	$(INSTALL) -d $(SBININSTALLDIR)
 	$(INSTALL) miniupnpd $(SBININSTALLDIR)
 	$(INSTALL) -d $(ETCINSTALLDIR)
-	$(INSTALL) netfilter/iptables_init.sh $(ETCINSTALLDIR)
-	$(INSTALL) netfilter/iptables_removeall.sh $(ETCINSTALLDIR)
-	$(INSTALL) netfilter/ip6tables_init.sh $(ETCINSTALLDIR)
-	$(INSTALL) netfilter/ip6tables_removeall.sh $(ETCINSTALLDIR)
 	$(INSTALL) --mode=0644 -b miniupnpd.conf $(ETCINSTALLDIR)
 	$(INSTALL) -d $(PREFIX)/etc/init.d
 	$(INSTALL) linux/miniupnpd.init.d.script $(PREFIX)/etc/init.d/miniupnpd
+	$(INSTALL) -d $(MANINSTALLDIR)
 	$(INSTALL) miniupnpd.8 $(MANINSTALLDIR)
 	gzip $(MANINSTALLDIR)/miniupnpd.8
 
@@ -162,9 +159,8 @@ else
 	sed -i -e "s/^uuid=[-0-9a-f]*/uuid=`($(STAGING_DIR_HOST)/bin/genuuid||$(STAGING_DIR_HOST)/bin/uuidgen||$(STAGING_DIR_HOST)/bin/uuid) 2>/dev/null`/" miniupnpd.conf
 endif
 
-miniupnpd:	$(BASEOBJS) $(LNXOBJS) $(NETFILTEROBJS) $(LIBS)
-
-testupnpdescgen:	$(TESTUPNPDESCGENOBJS)
+miniupnpd: $(BASEOBJS) $(CPPOBJS) $(LNXOBJS)
+	$(CXX) $(CFLAGS) $(LDFLAFGS) -o $@ $(BASEOBJS) $(CPPOBJS) $(LNXOBJS) $(LIBS)
 
 testgetifstats:	testgetifstats.o linux/getifstats.o

@@ -172,8 +168,6 @@ testupnppermissions:	testupnppermissions.o upnppermissions.o
 
 testgetifaddr:	testgetifaddr.o getifaddr.o
 
-testgetroute:	testgetroute.o linux/getroute.o upnputils.o -lnfnetlink
-
 miniupnpdctl:	miniupnpdctl.o
 
 config.h:	genconfig.sh VERSION
@@ -184,27 +178,56 @@ depend:	config.h
 	$(ALLOBJS:.o=.c) $(TESTUPNPDESCGENOBJS:.o=.c) \
 	testgetifstats.c 2>/dev/null

+qcmap_client_inc = -D__packed__= \
+        -DIMAGE_APPS_PROC \
+        -DFEATURE_Q_NO_SELF_QPTR \
+        -DAEEINTERFACE_CPLUSPLUS \
+        -DFEATURE_SMD \
+        -DFEATURE_DIAG_MP_MASTER_APPS \
+        -DFEATURE_DS_LINUX_ANDROID \
+        -DFEATURE_DSS_LINUX \
+        -DFEATURE_LINUX \
+        -DFEATURE_MULTIPROCESSOR \
+        -DFEATURE_DSUTILS_OFFTARGET \
+        -DFEATURE_NO_REX \
+        -DFEATURE_XMLLIB \
+		 -I$(INCDIR) \
+		 -I$(INCDIR)/rpcsvc \
+        -I$(INCDIR)/data \
+        -I$(INCDIR)/qmi-framework\
+        -I$(INCDIR)/qmi \
+        -I$(INCDIR)/diag \
+        -I$(INCDIR)/dsutils \
+        -I$(INCDIR)/xmllib
+
+CPPFLAGS += -Dstrlcpy=strncpy -Dstrlcat=strncat $(qcmap_client_inc)
+#LIBS += -lpthread -lrt libqcmap_client.la
+
 # DO NOT DELETE
 
 miniupnpd.o: config.h macros.h upnpglobalvars.h upnppermissions.h
 miniupnpd.o: miniupnpdtypes.h upnphttp.h upnpdescgen.h miniupnpdpath.h
 miniupnpd.o: getifaddr.h upnpsoap.h options.h minissdp.h upnpredirect.h
 miniupnpd.o: upnppinhole.h daemonize.h upnpevents.h natpmp.h commonrdr.h
-miniupnpd.o: upnputils.h ifacewatcher.h
+miniupnpd.o: upnputils.h ifacewatcher.h UPNP_QCMAP_Client.h
 upnphttp.o: config.h upnphttp.h upnpdescgen.h miniupnpdpath.h upnpsoap.h
 upnphttp.o: upnpevents.h upnputils.h
 upnpdescgen.o: config.h getifaddr.h upnpredirect.h upnpdescgen.h
 upnpdescgen.o: miniupnpdpath.h upnpglobalvars.h upnppermissions.h
 upnpdescgen.o: miniupnpdtypes.h upnpdescstrings.h upnpurns.h getconnstatus.h
+upnpdescgen.o: UPNP_QCMAP_Client.h
 upnpsoap.o: macros.h config.h upnpglobalvars.h upnppermissions.h
 upnpsoap.o: miniupnpdtypes.h upnphttp.h upnpsoap.h upnpreplyparse.h
 upnpsoap.o: upnpredirect.h upnppinhole.h getifaddr.h getifstats.h
-upnpsoap.o: getconnstatus.h upnpurns.h
+upnpsoap.o: getconnstatus.h upnpurns.h UPNP_QCMAP_Client.h
 upnpreplyparse.o: upnpreplyparse.h minixml.h
 minixml.o: minixml.h
 upnpredirect.o: macros.h config.h upnpredirect.h upnpglobalvars.h
 upnpredirect.o: upnppermissions.h miniupnpdtypes.h upnpevents.h
-upnpredirect.o: netfilter/iptcrdr.h commonrdr.h
+upnpredirect.o: commonrdr.h
+upnpredirect.o: UPNP_QCMAP_Client.h
+UPNP_QCMAP_Client.o: UPNP_QCMAP_Client.cpp UPNP_QCMAP_Client.h
+	$(CXX) $(CPPFLAGS) -c UPNP_QCMAP_Client.cpp
 getifaddr.o: config.h getifaddr.h
 daemonize.o: daemonize.h config.h
 upnpglobalvars.o: config.h upnpglobalvars.h upnppermissions.h
@@ -214,7 +237,7 @@ options.o: miniupnpdtypes.h
 upnppermissions.o: config.h upnppermissions.h
 minissdp.o: config.h upnpdescstrings.h miniupnpdpath.h upnphttp.h
 minissdp.o: upnpglobalvars.h upnppermissions.h miniupnpdtypes.h minissdp.h
-minissdp.o: upnputils.h getroute.h codelength.h
+minissdp.o: upnputils.h codelength.h
 natpmp.o: macros.h config.h natpmp.h upnpglobalvars.h upnppermissions.h
 natpmp.o: miniupnpdtypes.h getifaddr.h upnpredirect.h commonrdr.h upnputils.h
 upnpevents.o: config.h upnpevents.h miniupnpdpath.h upnpglobalvars.h
@@ -223,20 +246,11 @@ upnputils.o: config.h upnputils.h
 getconnstatus.o: getconnstatus.h getifaddr.h
 upnppinhole.o: macros.h config.h upnpredirect.h upnpglobalvars.h
 upnppinhole.o: upnppermissions.h miniupnpdtypes.h upnpevents.h
-upnppinhole.o: netfilter/iptpinhole.h
 linux/getifstats.o: config.h getifstats.h
 linux/ifacewatcher.o: config.h ifacewatcher.h config.h minissdp.h
 linux/ifacewatcher.o: miniupnpdtypes.h getifaddr.h upnpglobalvars.h
 linux/ifacewatcher.o: upnppermissions.h natpmp.h
-linux/getroute.o: getroute.h upnputils.h
-netfilter/iptcrdr.o: macros.h config.h netfilter/iptcrdr.h commonrdr.h
-netfilter/iptcrdr.o: config.h upnpglobalvars.h upnppermissions.h
-netfilter/iptcrdr.o: miniupnpdtypes.h
-netfilter/iptpinhole.o: config.h netfilter/iptpinhole.h upnpglobalvars.h
-netfilter/iptpinhole.o: upnppermissions.h config.h miniupnpdtypes.h
-netfilter/iptpinhole.o: netfilter/tiny_nf_nat.h
-testupnpdescgen.o: macros.h config.h upnpdescgen.h
 upnpdescgen.o: config.h getifaddr.h upnpredirect.h upnpdescgen.h
 upnpdescgen.o: miniupnpdpath.h upnpglobalvars.h upnppermissions.h
 upnpdescgen.o: miniupnpdtypes.h upnpdescstrings.h upnpurns.h getconnstatus.h
-testgetifstats.o: getifstats.h
+testgetifstats.o: getifstats.h
\ No newline at end of file
diff --git a/UPNP_QCMAP_Client.cpp b/UPNP_QCMAP_Client.cpp
new file mode 100644
index 0000000..7251546
--- /dev/null
+++ b/UPNP_QCMAP_Client.cpp
@@ -0,0 +1,282 @@
+#include "QCMAP_Client.h"
+#include "getifstats.h"
+
+QCMAP_Client *QcMapClient = NULL;
+
+#ifdef __cplusplus
+       extern "C"
+       {
+#endif
+
+int addStaticNatEntry_wrapper(struct in_addr addr, unsigned int proto, unsigned int local_port, unsigned int g_port)
+{
+  qcmap_msgr_snat_entry_config_v01 snat_entry;
+  qmi_error_type_v01 qmi_err_num;
+
+  /* Port mapping is not present, try to add it */
+  memset(&snat_entry, 0, sizeof(qcmap_msgr_snat_entry_config_v01));
+  snat_entry.private_ip_addr = ntohl(addr.s_addr);
+  snat_entry.protocol = (uint8)proto;
+  snat_entry.private_port = (uint16)local_port;
+  snat_entry.global_port = (uint16)g_port;
+  
+  if (!QcMapClient->AddStaticNatEntry(&snat_entry, &qmi_err_num))
+  {
+    if(qmi_err_num == QMI_ERR_NO_EFFECT_V01)
+	  return -2;
+	return -1;
+  }
+  return 0;
+}
+
+int deleteStaticNatEntry_wrapper(unsigned short port, int proto)
+{
+  qcmap_msgr_snat_entry_config_v01 snat_entry;
+  qcmap_msgr_snat_entry_config_v01 snat_config[QCMAP_MSGR_MAX_SNAT_ENTRIES_V01];
+  int i=0, num_entries=0;
+  qmi_error_type_v01 qmi_err_num;
+
+  memset(&snat_entry, 0, sizeof(qcmap_msgr_snat_entry_config_v01));
+  snat_entry.protocol = (uint8)proto;
+  snat_entry.global_port = (uint16)port;
+
+  memset(snat_config, 0, QCMAP_MSGR_MAX_SNAT_ENTRIES_V01*sizeof(qcmap_msgr_snat_entry_config_v01));
+  if (QcMapClient->GetStaticNatConfig(snat_config, &num_entries, &qmi_err_num))
+  {
+    for (i=0; i<num_entries; i++)
+    {
+      if(port == snat_config[i].global_port && proto == snat_config[i].protocol)
+      {
+        snat_entry.private_ip_addr = snat_config[i].private_ip_addr;
+        snat_entry.private_port = snat_config[i].private_port;
+
+        return QcMapClient->DeleteStaticNatEntry(&snat_entry, &qmi_err_num);  //something is going wrong here
+      }
+    }
+  }
+  return -1;
+}
+
+int getStaticNatConfigByEntry(int index, char *addr, int addrlen, unsigned short *eport, unsigned short *iport, int *proto)
+{
+  qmi_error_type_v01 qmi_err_num;
+  in_addr tmpIP;
+  int i=0, num_entries=0;
+  qcmap_msgr_snat_entry_config_v01 snat_config[QCMAP_MSGR_MAX_SNAT_ENTRIES_V01];
+
+  memset(snat_config, 0, QCMAP_MSGR_MAX_SNAT_ENTRIES_V01*sizeof(qcmap_msgr_snat_entry_config_v01));
+  if (QcMapClient->GetStaticNatConfig(snat_config, &num_entries, &qmi_err_num))
+  {
+    for (i=0; i<num_entries; i++)
+    {
+      if(i == index)
+      {
+        tmpIP.s_addr = ntohl(snat_config[i].private_ip_addr);
+        snprintf(addr, addrlen,"%u.%u.%u.%u", tmpIP.s_addr & 0xff, (tmpIP.s_addr >> 8) & 0xff, (tmpIP.s_addr >> 16) & 0xff, tmpIP.s_addr >> 24);
+        *iport = snat_config[i].private_port;
+        *eport = snat_config[i].global_port;
+        *proto = snat_config[i].protocol;
+
+        return 0;
+      }
+    }
+  }
+
+  return -1;
+}
+
+int getSpecificEntry(unsigned int eport, unsigned int proto, char *addr, int addrlen, unsigned short *iport, char * rhost, int rhostlen, unsigned int * timestamp)
+{
+  qmi_error_type_v01 qmi_err_num;
+  in_addr tmpIP;
+  int i=0, num_entries=0;
+  qcmap_msgr_snat_entry_config_v01 snat_config[QCMAP_MSGR_MAX_SNAT_ENTRIES_V01];
+
+  memset(snat_config, 0, QCMAP_MSGR_MAX_SNAT_ENTRIES_V01*sizeof(qcmap_msgr_snat_entry_config_v01));
+  if (QcMapClient->GetStaticNatConfig(snat_config, &num_entries, &qmi_err_num))
+  {
+    for (i=0; i<num_entries; i++)
+    {
+      if((snat_config[i].global_port == (uint16)eport) && (snat_config[i].protocol == (uint8)proto))
+      {
+        tmpIP.s_addr = ntohl(snat_config[i].private_ip_addr);
+        snprintf(addr, addrlen,"%u.%u.%u.%u", tmpIP.s_addr & 0xff, (tmpIP.s_addr >> 8) & 0xff, (tmpIP.s_addr >> 16) & 0xff, tmpIP.s_addr >> 24);
+        *iport = snat_config[i].private_port;
+
+        return 0;
+      }
+    }
+  }
+
+  return -1;
+}
+
+int getIfaceStats(struct ifdata * data)
+{
+  qmi_error_type_v01 qmi_err_num;
+  qcmap_msgr_ip_family_enum_v01 ip_family;
+  qcmap_msgr_wwan_statistics_type_v01 wwan_stats;
+
+  //IP family, IPV4-4 IPV6-6
+  ip_family = (qcmap_msgr_ip_family_enum_v01) 4;
+
+  if (QcMapClient->GetWWANStatistics(ip_family, &wwan_stats, &qmi_err_num))
+  {
+    data->baudrate = 4200000;	/* that is the answer */
+  	data->opackets = wwan_stats.pkts_tx;
+  	data->ipackets = wwan_stats.pkts_rx;
+  	data->obytes = wwan_stats.bytes_tx;
+  	data->ibytes = wwan_stats.bytes_rx;
+    return 0;
+  }
+
+  return -1;
+}
+
+int QCMAPClient(){
+  qmi_error_type_v01 qmi_err_num;
+  if(QcMapClient != NULL)
+  {
+    return 0;
+  }
+
+  QcMapClient = new QCMAP_Client(NULL);
+  QcMapClient->EnableMobileAP(&qmi_err_num);
+  return 1;
+}
+
+int tearDownQCMAPClient(){
+  qmi_error_type_v01 qmi_err_num;
+  if(QcMapClient == NULL)
+  {
+    return 0;
+  }
+
+  QcMapClient->DisableMobileAP(&qmi_err_num);
+  delete(QcMapClient);
+
+  return 1;
+}
+
+int getIPAddr(char *ext_ip_addr, int size){
+  qmi_error_type_v01 qmi_err_num;
+  in_addr public_ip;
+  in_addr primary_dns;
+  in_addr secondary_dns;
+  in_addr tmpIP;
+
+  memset(&public_ip,0,sizeof(in_addr));
+  memset(&primary_dns,0,sizeof(in_addr));
+  memset(&secondary_dns,0,sizeof(in_addr));
+
+  if (QcMapClient->GetIPv4WWANNetworkConfiguration((in_addr_t *)&public_ip.s_addr,
+                                     (uint32 *)&primary_dns.s_addr,
+                                     (in_addr_t *)&secondary_dns.s_addr,
+                                     &qmi_err_num))
+  {
+    if ( public_ip.s_addr != 0 )
+    {
+      tmpIP.s_addr = ntohl(public_ip.s_addr);
+      snprintf(ext_ip_addr, size,"%u.%u.%u.%u", tmpIP.s_addr & 0xff, (tmpIP.s_addr >> 8) & 0xff, (tmpIP.s_addr >> 16) & 0xff, tmpIP.s_addr >> 24);
+      return 0;
+    }
+  }
+
+  return -1;
+}
+
+/**
+ * get the connection status
+ * return values :
+ *  0 - Unconfigured
+ *  1 - Connecting
+ *  2 - Connected
+ *  3 - PendingDisconnect
+ *  4 - Disconnecting
+ *  5 - Disconnected */
+int getWanStatus()
+{
+  int r = 0;
+  qcmap_msgr_wwan_call_type_v01 call_type = QCMAP_MSGR_WWAN_CALL_TYPE_V4_V01;
+  qmi_error_type_v01 qmi_err_num;
+  qcmap_msgr_wwan_status_enum_v01 v4_status, v6_status;
+
+  if (QcMapClient->GetWWANStatus(&v4_status, &v6_status, &qmi_err_num))
+  {
+    if ( v4_status != NULL)
+    {
+      if(v4_status == QCMAP_MSGR_WWAN_STATUS_CONNECTING_V01)
+      {
+        r = 1;
+      }
+      else if(v4_status == QCMAP_MSGR_WWAN_STATUS_CONNECTED_V01)
+      {
+        r = 2;
+      }
+      else if(v4_status == QCMAP_MSGR_WWAN_STATUS_DISCONNECTING_V01)
+      {
+        r = 4;
+      }
+      else if(v4_status == QCMAP_MSGR_WWAN_STATUS_DISCONNECTED_V01)
+      {
+        r = 5;
+      }
+    }
+    //else if ( v6_status != NULL)
+    //{
+      //if(v6_status == QCMAP_MSGR_WWAN_STATUS_IPV6_CONNECTING_V01)
+      //{
+        //r = 1;
+      //}
+      //else if(v6_status == QCMAP_MSGR_WWAN_STATUS_IPV6_CONNECTED_V01)
+      //{
+        //r = 2;
+      //}
+      //else if(v6_status == QCMAP_MSGR_WWAN_STATUS_IPV6_DISCONNECTING_V01)
+      //{
+        //r = 4;
+      //}
+      //else if(v6_status == QCMAP_MSGR_WWAN_STATUS_IPV6_DISCONNECTED_V01)
+      //{
+        //r = 5;
+      //}
+    //}
+  }
+
+	return r;
+}
+
+const char *getWanStatusStr()
+{
+	int status;
+	const char * str = NULL;
+
+	status = getWanStatus();
+
+	switch(status) {
+	case 0:
+		str = "Unconfigured";
+		break;
+	case 1:
+		str = "Connecting";
+		break;
+	case 2:
+		str = "Connected";
+		break;
+	case 3:
+		str = "PendingDisconnect";
+		break;
+	case 4:
+		str = "Disconnecting";
+		break;
+	case 5:
+		str = "Disconnected";
+		break;
+	}
+
+	return str;
+}
+
+#ifdef __cplusplus
+       }
+#endif
\ No newline at end of file
diff --git a/UPNP_QCMAP_Client.h b/UPNP_QCMAP_Client.h
new file mode 100644
index 0000000..30090fc
--- /dev/null
+++ b/UPNP_QCMAP_Client.h
@@ -0,0 +1,33 @@
+#include "QCMAP_Client.h"
+#include "qualcomm_mobile_access_point_msgr_v01.h"
+extern "C" {
+
+   int addStaticNatEntry_wrapper
+   (
+      struct in_addr    addr,
+      unsigned int      proto,
+      unsigned int      local_port,
+      unsigned int      g_port
+   );
+
+   int deleteStaticNatEntry_wrapper
+   (
+      unsigned short port,
+      int proto
+   );
+
+   int getStaticNatConfigByEntry
+   (
+      int index,
+      char *addr,
+      int addrlen,
+      unsigned short *eport,
+      unsigned short *iport,
+      int *proto
+   );
+
+   int getIfaceStats
+   (
+      struct ifdata * data
+   );
+#endif
\ No newline at end of file
diff --git a/config.h b/config.h
new file mode 100644
index 0000000..7ec9e8d
--- /dev/null
+++ b/config.h
@@ -0,0 +1,100 @@
+/* MiniUPnP Project
+ * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
+ * (c) 2006-2012 Thomas Bernard
+ * generated by ./genconfig.sh on Mon Dec 17 11:25:57 PST 2012
+ * using command line options  */
+#ifndef CONFIG_H_INCLUDED
+#define CONFIG_H_INCLUDED
+
+#include <inttypes.h>
+
+#define MINIUPNPD_VERSION "1.7"
+
+#define UPNP_VERSION	"20121217"
+#define USE_IFACEWATCHER 1
+#define USE_NETFILTER 0
+#define SUPPORT_REMOTEHOST
+
+#define OS_NAME		"Ubuntu"
+#define OS_VERSION	"Ubuntu/lucid"
+#define OS_URL		"http://www.ubuntu.com/"
+
+/* syslog facility to be used by miniupnpd */
+#define LOG_MINIUPNPD		 LOG_DAEMON
+
+/* Uncomment the following line to allow miniupnpd to be
+ * controlled by miniupnpdctl */
+/*#define USE_MINIUPNPDCTL*/
+
+/* Comment the following line to disable NAT-PMP operations */
+#define ENABLE_NATPMP
+
+/* Uncomment the following line to enable generation of
+ * filter rules with pf */
+/*#define PF_ENABLE_FILTER_RULES*/
+
+/* Uncomment the following line to enable caching of results of
+ * the getifstats() function */
+/*#define ENABLE_GETIFSTATS_CACHING*/
+/* The cache duration is indicated in seconds */
+#define GETIFSTATS_CACHING_DURATION 2
+
+/* Uncomment the following line to enable multiple external ip support */
+/* note : That is EXPERIMENTAL, do not use that unless you know perfectly what you are doing */
+/* Dynamic external ip adresses are not supported when this option is enabled.
+ * Also note that you would need to configure your .conf file accordingly. */
+/*#define MULTIPLE_EXTERNAL_IP*/
+
+/* Comment the following line to use home made daemonize() func instead
+ * of BSD daemon() */
+#define USE_DAEMON
+
+/* Uncomment the following line to enable lease file support */
+/*#define ENABLE_LEASEFILE*/
+
+/* Define one or none of the two following macros in order to make some
+ * clients happy. It will change the XML Root Description of the IGD.
+ * Enabling the Layer3Forwarding Service seems to be the more compatible
+ * option. */
+/*#define HAS_DUMMY_SERVICE*/
+#define ENABLE_L3F_SERVICE
+
+/* Enable IP v6 support */
+/*#define ENABLE_IPV6*/
+
+/* Enable the support of IGD v2 specification.
+ * This is not fully tested yet and can cause incompatibilities with some
+ * control points, so enable with care. */
+/*#define IGD_V2*/
+
+#ifdef IGD_V2
+/* Enable DeviceProtection service (IGDv2) */
+#define ENABLE_DP_SERVICE
+
+/* Enable WANIPv6FirewallControl service (IGDv2). needs IPv6 */
+#ifdef ENABLE_IPV6
+#define ENABLE_6FC_SERVICE
+#endif /* ENABLE_IPV6 */
+#endif /* IGD_V2 */
+
+/* UPnP Events support. Working well enough to be enabled by default.
+ * It can be disabled to save a few bytes. */
+#define ENABLE_EVENTS
+
+/* include interface name in pf and ipf rules */
+#define USE_IFNAME_IN_RULES
+
+/* Experimental NFQUEUE support. */
+/*#define ENABLE_NFQUEUE*/
+
+/* Enable to make MiniUPnPd more strict about UPnP conformance
+ * and the messages it receives from control points */
+/*#define UPNP_STRICT*/
+
+/* Add the optional Date: header in all HTTP responses */
+/*#define ENABLE_HTTP_DATE*/
+
+/* disable reading and parsing of config file (miniupnpd.conf) */
+/*#define DISABLE_CONFIG_FILE*/
+
+#endif
diff --git a/linux/miniupnpd.init.d.script b/linux/miniupnpd.init.d.script
old mode 100644
new mode 100755
index ee6e47b..b29c249
--- a/linux/miniupnpd.init.d.script
+++ b/linux/miniupnpd.init.d.script
@@ -18,33 +18,18 @@ set -e
 MINIUPNPD=/usr/sbin/miniupnpd
 ARGS='-f /etc/miniupnpd/miniupnpd.conf'

-IPTABLES_CREATE=/etc/miniupnpd/iptables_init.sh
-IPTABLES_REMOVE=/etc/miniupnpd/iptables_removeall.sh
-
 test -f $MINIUPNPD || exit 0
 
-. /lib/lsb/init-functions
-
 case "$1" in
   start)
-	log_daemon_msg "Starting miniupnpd" "miniupnpd"
-	$IPTABLES_CREATE > /dev/null 2>&1
 	start-stop-daemon --start --quiet --pidfile /var/run/miniupnpd.pid --startas $MINIUPNPD -- $ARGS $LSBNAMES
-	log_end_msg $?
 	;;
   stop)
-	log_daemon_msg "Stopping miniupnpd" "miniupnpd"
 	start-stop-daemon --stop --quiet --pidfile /var/run/miniupnpd.pid
-	log_end_msg $?
-	$IPTABLES_REMOVE > /dev/null 2>&1
 	;;
   restart|reload|force-reload)
-	log_daemon_msg "Restarting miniupnpd" "miniupnpd"
 	start-stop-daemon --stop --retry 5 --quiet --pidfile /var/run/miniupnpd.pid
-	$IPTABLES_REMOVE > /dev/null 2>&1
-	$IPTABLES_CREATE > /dev/null 2>&1
 	start-stop-daemon --start --quiet --pidfile /var/run/miniupnpd.pid --startas $MINIUPNPD -- $ARGS $LSBNAMES
-	log_end_msg $?
 	;;
   status)
 	status_of_proc /usr/sbin/miniupnpd miniupnpd
diff --git a/minissdp.c b/minissdp.c
index f937109..bfe105b 100644
--- a/minissdp.c
+++ b/minissdp.c
@@ -394,6 +394,16 @@ static struct {
 };

 static void
+_usleep(long usecs)
+{
+	struct timespec sleep_time;
+
+	sleep_time.tv_sec = 0;
+	sleep_time.tv_nsec = usecs * 1000;
+	nanosleep(&sleep_time, NULL);
+}
+
+static void
 SendSSDPNotifies(int s, const char * host, unsigned short port,
                  unsigned int lifetime, int ipv6)
 {
@@ -402,7 +412,7 @@ SendSSDPNotifies(int s, const char * host, unsigned short port,
 #else
 	struct sockaddr_in sockname;
 #endif
-	int l, n, i=0;
+	int l, n, dup, i=0;
 	char bufr[512];
 	char ver_str[4];

@@ -424,58 +434,66 @@ SendSSDPNotifies(int s, const char * host, unsigned short port,
 		p->sin_addr.s_addr = inet_addr(SSDP_MCAST_ADDR);
 	}

-	while(known_service_types[i].s)
+
+	for( dup=0; dup<2; dup++ )
 	{
-		if(i==0)
-			ver_str[0] = '\0';
-		else
-			snprintf(ver_str, sizeof(ver_str), "%d", known_service_types[i].version);
-		l = snprintf(bufr, sizeof(bufr),
-			"NOTIFY * HTTP/1.1\r\n"
-			"HOST: %s:%d\r\n"
-			"CACHE-CONTROL: max-age=%u\r\n"
-			"lOCATION: http://%s:%d" ROOTDESC_PATH"\r\n"
-			"SERVER: " MINIUPNPD_SERVER_STRING "\r\n"
-			"NT: %s%s\r\n"
-			"USN: %s::%s%s\r\n"
-			"NTS: ssdp:alive\r\n"
-			"OPT: \"http://schemas.upnp.org/upnp/1/0/\"; ns=01\r\n" /* UDA v1.1 */
-			"01-NLS: %u\r\n" /* same as BOOTID field. UDA v1.1 */
-			"BOOTID.UPNP.ORG: %u\r\n" /* UDA v1.1 */
-			"CONFIGID.UPNP.ORG: %u\r\n" /* UDA v1.1 */
-			"\r\n",
-			ipv6 ? "[" LL_SSDP_MCAST_ADDR "]" : SSDP_MCAST_ADDR,
-			SSDP_PORT,
-			lifetime,
-			host, port,
-			known_service_types[i].s, ver_str,
-			uuidvalue, known_service_types[i].s, ver_str,
-			upnp_bootid, upnp_bootid, upnp_configid );
-		if(l<0)
-		{
-			syslog(LOG_ERR, "SendSSDPNotifies() snprintf error");
-			continue;
-		}
-		if((unsigned int)l >= sizeof(bufr))
-		{
-			syslog(LOG_WARNING, "SendSSDPNotifies(): truncated output");
-			l = sizeof(bufr);
-		}
-		n = sendto(s, bufr, l, 0,
-			(struct sockaddr *)&sockname,
-#ifdef ENABLE_IPV6
-			ipv6 ? sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in)
-#else
-			sizeof(struct sockaddr_in)
-#endif
-			);
-		if(n < 0)
+
+		if( dup )
+			_usleep(200000);
+		i=0;
+		while(known_service_types[i].s)
 		{
-			/* XXX handle EINTR, EAGAIN, EWOULDBLOCK */
-			syslog(LOG_ERR, "sendto(udp_notify=%d, %s): %m", s,
-			       host ? host : "NULL");
+			if(i==0)
+				ver_str[0] = '\0';
+			else
+				snprintf(ver_str, sizeof(ver_str), "%d", known_service_types[i].version);
+			l = snprintf(bufr, sizeof(bufr),
+				"NOTIFY * HTTP/1.1\r\n"
+				"HOST: %s:%d\r\n"
+				"CACHE-CONTROL: max-age=%u\r\n"
+				"lOCATION: http://%s:%d" ROOTDESC_PATH"\r\n"
+				"SERVER: " MINIUPNPD_SERVER_STRING "\r\n"
+				"NT: %s%s\r\n"
+				"USN: %s::%s%s\r\n"
+				"NTS: ssdp:alive\r\n"
+				"OPT: \"http://schemas.upnp.org/upnp/1/0/\"; ns=01\r\n" /* UDA v1.1 */
+				"01-NLS: %u\r\n" /* same as BOOTID field. UDA v1.1 */
+				"BOOTID.UPNP.ORG: %u\r\n" /* UDA v1.1 */
+				"CONFIGID.UPNP.ORG: %u\r\n" /* UDA v1.1 */
+				"\r\n",
+				ipv6 ? "[" LL_SSDP_MCAST_ADDR "]" : SSDP_MCAST_ADDR,
+				SSDP_PORT,
+				lifetime,
+				host, port,
+				known_service_types[i].s, ver_str,
+				uuidvalue, known_service_types[i].s, ver_str,
+				upnp_bootid, upnp_bootid, upnp_configid );
+			if(l<0)
+			{
+				syslog(LOG_ERR, "SendSSDPNotifies() snprintf error");
+				continue;
+			}
+			if((unsigned int)l >= sizeof(bufr))
+			{
+				syslog(LOG_WARNING, "SendSSDPNotifies(): truncated output");
+				l = sizeof(bufr);
+			}
+			n = sendto(s, bufr, l, 0,
+				(struct sockaddr *)&sockname,
+	#ifdef ENABLE_IPV6
+				ipv6 ? sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in)
+	#else
+				sizeof(struct sockaddr_in)
+	#endif
+				);
+			if(n < 0)
+			{
+				/* XXX handle EINTR, EAGAIN, EWOULDBLOCK */
+				syslog(LOG_ERR, "sendto(udp_notify=%d, %s): %m", s,
+					   host ? host : "NULL");
+			}
+			i++;
 		}
-		i++;
 	}
 }

@@ -720,7 +738,7 @@ SendSSDPGoodbye(int * sockets, int n_sockets)
 	int i, j;
 	char bufr[512];
 	char ver_str[4];
-	int ret = 0;
+	int dup, ret = 0;
 	int ipv6 = 0;

     memset(&sockname, 0, sizeof(struct sockaddr_in));
@@ -734,49 +752,52 @@ SendSSDPGoodbye(int * sockets, int n_sockets)
 	inet_pton(AF_INET6, LL_SSDP_MCAST_ADDR, &(sockname6.sin6_addr));
 #endif

-	for(j=0; j<n_sockets; j++)
+	for (dup = 0; dup < 2; dup++)
 	{
-#ifdef ENABLE_IPV6
-		ipv6 = j & 1;
-#endif
-	    for(i=0; known_service_types[i].s; i++)
-	    {
-			if(i==0)
-				ver_str[0] = '\0';
-			else
-				snprintf(ver_str, sizeof(ver_str), "%d", known_service_types[i].version);
-	        l = snprintf(bufr, sizeof(bufr),
-                 "NOTIFY * HTTP/1.1\r\n"
-                 "HOST: %s:%d\r\n"
-                 "NT: %s%s\r\n"
-                 "USN: %s::%s%s\r\n"
-                 "NTS: ssdp:byebye\r\n"
-				 "OPT: \"http://schemas.upnp.org/upnp/1/0/\"; ns=01\r\n" /* UDA v1.1 */
-				 "01-NLS: %u\r\n" /* same as BOOTID field. UDA v1.1 */
-				 "BOOTID.UPNP.ORG: %u\r\n" /* UDA v1.1 */
-				 "CONFIGID.UPNP.ORG: %u\r\n" /* UDA v1.1 */
-                 "\r\n",
-                 ipv6 ? "[" LL_SSDP_MCAST_ADDR "]" : SSDP_MCAST_ADDR,
-			     SSDP_PORT,
-				 known_service_types[i].s, ver_str,
-                 uuidvalue, known_service_types[i].s, ver_str,
-                 upnp_bootid, upnp_bootid, upnp_configid);
-	        n = sendto(sockets[j], bufr, l, 0,
-#ifdef ENABLE_IPV6
-	                   ipv6 ? (struct sockaddr *)&sockname6 : (struct sockaddr *)&sockname,
-	                   ipv6 ? sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in)
-#else
-	                   (struct sockaddr *)&sockname,
-	                   sizeof(struct sockaddr_in)
-#endif
-	                 );
-			if(n < 0)
+		for(j=0; j<n_sockets; j++)
+		{
+	#ifdef ENABLE_IPV6
+			ipv6 = j & 1;
+	#endif
+			for(i=0; known_service_types[i].s; i++)
 			{
-				syslog(LOG_ERR, "SendSSDPGoodbye: sendto(udp_shutdown=%d): %m",
-				       sockets[j]);
-				ret = -1;
+				if(i==0)
+					ver_str[0] = '\0';
+				else
+					snprintf(ver_str, sizeof(ver_str), "%d", known_service_types[i].version);
+				l = snprintf(bufr, sizeof(bufr),
+					 "NOTIFY * HTTP/1.1\r\n"
+					 "HOST: %s:%d\r\n"
+					 "NT: %s%s\r\n"
+					 "USN: %s::%s%s\r\n"
+					 "NTS: ssdp:byebye\r\n"
+					 "OPT: \"http://schemas.upnp.org/upnp/1/0/\"; ns=01\r\n" /* UDA v1.1 */
+					 "01-NLS: %u\r\n" /* same as BOOTID field. UDA v1.1 */
+					 "BOOTID.UPNP.ORG: %u\r\n" /* UDA v1.1 */
+					 "CONFIGID.UPNP.ORG: %u\r\n" /* UDA v1.1 */
+					 "\r\n",
+					 ipv6 ? "[" LL_SSDP_MCAST_ADDR "]" : SSDP_MCAST_ADDR,
+					 SSDP_PORT,
+					 known_service_types[i].s, ver_str,
+					 uuidvalue, known_service_types[i].s, ver_str,
+					 upnp_bootid, upnp_bootid, upnp_configid);
+				n = sendto(sockets[j], bufr, l, 0,
+	#ifdef ENABLE_IPV6
+						   ipv6 ? (struct sockaddr *)&sockname6 : (struct sockaddr *)&sockname,
+						   ipv6 ? sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in)
+	#else
+						   (struct sockaddr *)&sockname,
+						   sizeof(struct sockaddr_in)
+	#endif
+						 );
+				if(n < 0)
+				{
+					syslog(LOG_ERR, "SendSSDPGoodbye: sendto(udp_shutdown=%d): %m",
+						   sockets[j]);
+					ret = -1;
+				}
 			}
-    	}
+		}
 	}
 	return ret;
 }
diff --git a/miniupnpd.c b/miniupnpd.c
index 050d8db..0ee9b68 100644
--- a/miniupnpd.c
+++ b/miniupnpd.c
@@ -1074,7 +1074,7 @@ init(int argc, char * * argv, struct runtime_vars * v)
			fprintf(stderr, "Unknown option: %s\n", argv[i]);
		}
	}
-	if(!ext_if_name || !lan_addrs.lh_first)
+	if(!lan_addrs.lh_first)
	{
		/* bad configuration */
		goto print_usage;
@@ -1156,9 +1156,9 @@ init(int argc, char * * argv, struct runtime_vars * v)
 		syslog(LOG_NOTICE, "Failed to set %s handler", "SIGUSR1");
 	}
 
-	if(init_redirect() < 0)
+	if(!QCMAPClient())
 	{
-		syslog(LOG_ERR, "Failed to init redirection engine. EXITING");
+		syslog(LOG_ERR, "Failed to init QCMAP. EXITING");
 		return 1;
 	}
 #ifdef ENABLE_6FC_SERVICE
@@ -1324,14 +1324,13 @@ main(int argc, char * * argv)
 		return 0;
 	}

-	syslog(LOG_INFO, "Starting%s%swith external interface %s",
+	syslog(LOG_INFO, "Starting%s%swith external interface",
 #ifdef ENABLE_NATPMP
 	       GETFLAG(ENABLENATPMPMASK) ? " NAT-PMP " : " ",
 #else
 	       " ",
 #endif
-	       GETFLAG(ENABLEUPNPMASK) ? "UPnP-IGD " : "",
-	       ext_if_name);
+	       GETFLAG(ENABLEUPNPMASK) ? "UPnP-IGD " : "");

 	if(GETFLAG(ENABLEUPNPMASK))
 	{
@@ -1862,6 +1861,12 @@ main(int argc, char * * argv)
 	}	/* end of main loop */

 shutdown:
+    /* Tear Down QCMap Client */
+	if(!tearDownQCMAPClient())
+	{
+		syslog(LOG_ERR, "Unable to tear down QCMAP Client");
+	}
+
 	/* close out open sockets */
 	while(upnphttphead.lh_first != NULL)
 	{
diff --git a/miniupnpd.conf b/miniupnpd.conf
index e34e088..cf1324d 100644
--- a/miniupnpd.conf
+++ b/miniupnpd.conf
@@ -1,6 +1,6 @@
 # WAN network interface
-ext_ifname=eth1
-#ext_ifname=xl1
+#ext_ifname=eth1
+
 # if the WAN interface has several IP addresses, you
 # can specify the one to use below
 #ext_ip=
@@ -15,8 +15,9 @@ ext_ifname=eth1
 # address associated with the subnet follows. for example :
 #  listening_ip=192.168.0.1/24 88.22.44.13
 #listening_ip=192.168.0.1/24
-listening_ip=192.168.10.109/24
-#listening_ip=eth0
+#listening_ip=wlan1
+#listening_ip=rndis0
+listening_ip=bridge0
 # port for HTTP (descriptions and SOAP) traffic. set 0 for autoselect.
 port=0
 
@@ -40,7 +41,7 @@ enable_upnp=yes
 #lease_file=/var/log/upnp.leases
 
 # name of this service, default is "`uname -s` Router"
-#friendly_name=MiniUPnPd router
+friendly_name=9x25 MobileAP UPnP
 
 # bitrates reported by daemon in bits per second
 bitrate_up=1000000
@@ -105,9 +106,9 @@ model_number=1
 # ip/mask format must be nn.nn.nn.nn/nn
 # it is advised to only allow redirection of port above 1024
 # and to finish the rule set with "deny 0-65535 0.0.0.0/0 0-65535"
-allow 1024-65535 192.168.0.0/24 1024-65535
-allow 1024-65535 192.168.1.0/24 1024-65535
-allow 1024-65535 192.168.0.0/23 22
-allow 12345 192.168.7.113/32 54321
-deny 0-65535 0.0.0.0/0 0-65535
+#allow 1024-65535 192.168.0.0/24 0-65535
+#allow 1024-65535 192.168.1.0/24 1024-65535
+#allow 1024-65535 192.168.0.0/23 22
+#allow 12345 192.168.7.113/32 54321
+allow 0-65535 0.0.0.0/0 0-65535
 
diff --git a/natpmp.c b/natpmp.c
index c596781..b85b3e6 100644
--- a/natpmp.c
+++ b/natpmp.c
@@ -203,33 +203,33 @@ void ProcessIncomingNATPMPPacket(int s)
 				/* remove the mapping */
 				if(iport == 0) {
 					/* remove all the mappings for this client */
-					int index = 0;
-					unsigned short eport2, iport2;
-					char iaddr2[16];
-					int proto2;
-					char desc[64];
-					while(get_redirect_rule_by_index(index, 0,
-					          &eport2, iaddr2, sizeof(iaddr2),
-							  &iport2, &proto2,
-							  desc, sizeof(desc),
-					          0, 0, &timestamp, 0, 0) >= 0) {
-						syslog(LOG_DEBUG, "%d %d %hu->'%s':%hu '%s'",
-						       index, proto2, eport2, iaddr2, iport2, desc);
-						if(0 == strcmp(iaddr2, senderaddrstr)
-						  && 0 == memcmp(desc, "NAT-PMP", 7)) {
-							r = _upnp_delete_redir(eport2, proto2);
-							/* TODO : check return value */
-							if(r<0) {
-								syslog(LOG_ERR, "failed to remove port mapping");
-								index++;
-							} else {
-								syslog(LOG_INFO, "NAT-PMP %s port %hu mapping removed",
-								       proto2==IPPROTO_TCP?"TCP":"UDP", eport2);
-							}
-						} else {
-							index++;
-						}
-					}
+//					int index = 0;
+//					unsigned short eport2, iport2;
+//					char iaddr2[16];
+//					int proto2;
+//					char desc[64];
+//					while(get_redirect_rule_by_index(index, 0,
+//					          &eport2, iaddr2, sizeof(iaddr2),
+//							  &iport2, &proto2,
+//							  desc, sizeof(desc),
+//					          0, 0, &timestamp, 0, 0) >= 0) {
+//						syslog(LOG_DEBUG, "%d %d %hu->'%s':%hu '%s'",
+//						       index, proto2, eport2, iaddr2, iport2, desc);
+//						if(0 == strcmp(iaddr2, senderaddrstr)
+//						  && 0 == memcmp(desc, "NAT-PMP", 7)) {
+//							r = _upnp_delete_redir(eport2, proto2);
+//							/* TODO : check return value */
+//							if(r<0) {
+//								syslog(LOG_ERR, "failed to remove port mapping");
+//								index++;
+//							} else {
+//								syslog(LOG_INFO, "NAT-PMP %s port %hu mapping removed",
+//								       proto2==IPPROTO_TCP?"TCP":"UDP", eport2);
+//							}
+//						} else {
+//							index++;
+//						}
+//					}
 				} else {
 					/* To improve the interworking between nat-pmp and
 					 * UPnP, we should check that we remove only NAT-PMP
@@ -247,10 +247,11 @@ void ProcessIncomingNATPMPPacket(int s)
 			   || !check_upnp_rule_against_permissions(upnppermlist, num_upnpperm, eport, senderaddr.sin_addr, iport)) {
 				resp[3] = 2;	/* Not Authorized/Refused */
 			} else do {
-				r = get_redirect_rule(ext_if_name, eport, proto,
-				                      iaddr_old, sizeof(iaddr_old),
-				                      &iport_old, 0, 0, 0, 0,
-				                      &timestamp, 0, 0);
+				//r = get_redirect_rule(ext_if_name, eport, proto,
+				//                      iaddr_old, sizeof(iaddr_old),
+				//                      &iport_old, 0, 0, 0, 0,
+				//                      &timestamp, 0, 0);
+				r=0; //remove this
 				if(r==0) {
 					if(strcmp(senderaddrstr, iaddr_old)==0
 				       && iport==iport_old) {
@@ -279,9 +280,9 @@ void ProcessIncomingNATPMPPacket(int s)
 					         eport, (proto==IPPROTO_TCP)?"tcp":"udp");
 #endif
 					/* TODO : check return code */
-					if(upnp_redirect_internal(NULL, eport, senderaddrstr,
-					                          iport, proto, desc,
-					                          timestamp) < 0) {
+					if(upnp_redirect_internal(/*NULL,*/eport, senderaddrstr, 
+											  iport, proto/*, desc,
+											 timestamp*/) < 0) {
 						syslog(LOG_ERR, "Failed to add NAT-PMP %hu %s->%s:%hu '%s'",
 						       eport, (proto==IPPROTO_TCP)?"tcp":"udp", senderaddrstr, iport, desc);
 						resp[3] = 3;  /* Failure */
diff --git a/upnpdescgen.c b/upnpdescgen.c
index d13f74c..1da3a55 100644
--- a/upnpdescgen.c
+++ b/upnpdescgen.c
@@ -1151,7 +1151,7 @@ genEventVars(int * len, const struct serviceDesc * s, const char * servns)
 	str = strcat_str(str, len, &tmplen, "\">");
 	while(v->name) {
 		if(v->itype & 0x80) {
-			str = strcat_str(str, len, &tmplen, "<e:property><s:");
+			str = strcat_str(str, len, &tmplen, "<e:property><");
 			str = strcat_str(str, len, &tmplen, v->name);
 			str = strcat_str(str, len, &tmplen, ">");
 			/*printf("<e:property><s:%s>", v->name);*/
@@ -1161,7 +1161,7 @@ genEventVars(int * len, const struct serviceDesc * s, const char * servns)
			case CONNECTIONSTATUS_MAGICALVALUE:
				/* or get_wan_connection_status_str(ext_if_name) */
				str = strcat_str(str, len, &tmplen,
-				   upnpallowedvalues[18 + get_wan_connection_status(ext_if_name)]);
+				   upnpallowedvalues[18 + getWanStatus()]);
				break;
 #ifdef ENABLE_6FC_SERVICE
			case FIREWALLENABLED_MAGICALVALUE:
@@ -1198,7 +1198,7 @@ genEventVars(int * len, const struct serviceDesc * s, const char * servns)
					str = strcat_str(str, len, &tmplen, use_ext_ip_addr);
				else {
					char ext_ip_addr[INET_ADDRSTRLEN];
-					if(getifaddr(ext_if_name, ext_ip_addr, INET_ADDRSTRLEN) < 0) {
+					if(getIPAddr(ext_ip_addr, INET_ADDRSTRLEN) < 0) {
						str = strcat_str(str, len, &tmplen, "0.0.0.0");
					} else {
						str = strcat_str(str, len, &tmplen, ext_ip_addr);
@@ -1217,7 +1217,7 @@ genEventVars(int * len, const struct serviceDesc * s, const char * servns)
 			default:
 				str = strcat_str(str, len, &tmplen, upnpallowedvalues[v->ieventvalue]);
 			}
-			str = strcat_str(str, len, &tmplen, "</s:");
+			str = strcat_str(str, len, &tmplen, "</");
 			str = strcat_str(str, len, &tmplen, v->name);
 			str = strcat_str(str, len, &tmplen, "></e:property>");
 			/*printf("</s:%s></e:property>\n", v->name);*/
diff --git a/upnpredirect.c b/upnpredirect.c
index 5c9beae..2643e97 100644
--- a/upnpredirect.c
+++ b/upnpredirect.c
@@ -255,7 +255,7 @@ int reload_from_lease_file()
  *          -3 permission check failed
  */
 int
-upnp_redirect(const char * rhost, unsigned short eport,
+upnp_redirect(/*const char * rhost,*/unsigned short eport, 
               const char * iaddr, unsigned short iport,
               const char * protocol, const char * desc,
               unsigned int leaseduration)
@@ -278,68 +278,28 @@ upnp_redirect(const char * rhost, unsigned short eport,
 		                 "%hu->%s:%hu %s", eport, iaddr, iport, protocol);
 		return -3;
 	}
-	r = get_redirect_rule(ext_if_name, eport, proto,
-	                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,
-	                      0, 0,
-	                      &timestamp, 0, 0);
-	if(r == 0) {
-		/* if existing redirect rule matches redirect request return success
-		 * xbox 360 does not keep track of the port it redirects and will
-		 * redirect another port when receiving ConflictInMappingEntry */
-		if(strcmp(iaddr, iaddr_old)==0 && iport==iport_old) {
-			syslog(LOG_INFO, "ignoring redirect request as it matches existing redirect");
-		} else {
 
-			syslog(LOG_INFO, "port %hu protocol %s already redirected to %s:%hu",
-				eport, protocol, iaddr_old, iport_old);
-			return -2;
-		}
-	} else {
-		timestamp = (leaseduration > 0) ? time(NULL) + leaseduration : 0;
-		syslog(LOG_INFO, "redirecting port %hu to %s:%hu protocol %s for: %s",
-			eport, iaddr, iport, protocol, desc);
-		return upnp_redirect_internal(rhost, eport, iaddr, iport, proto,
-		                              desc, timestamp);
-	}
+	timestamp = (leaseduration > 0) ? time(NULL) + leaseduration : 0;
+	syslog(LOG_INFO, "redirecting port %hu to %s:%hu protocol %s for: %s",
+		eport, iaddr, iport, protocol, desc);
+	return upnp_redirect_internal(/*rhost,*/ eport, iaddr, iport, proto/*, desc, timestamp*/);
 
 	return 0;
 }
 
 int
-upnp_redirect_internal(const char * rhost, unsigned short eport,
+upnp_redirect_internal(unsigned short eport,
                        const char * iaddr, unsigned short iport,
-                       int proto, const char * desc,
-                       unsigned int timestamp)
+                       int proto)
 {
-	/*syslog(LOG_INFO, "redirecting port %hu to %s:%hu protocol %s for: %s",
-		eport, iaddr, iport, protocol, desc);			*/
-	if(add_redirect_rule2(ext_if_name, rhost, eport, iaddr, iport, proto,
-	                      desc, timestamp) < 0) {
-		return -1;
-	}
+	struct in_addr address;
 
-#ifdef ENABLE_LEASEFILE
-	lease_file_add( eport, iaddr, iport, proto, desc, timestamp);
-#endif
-/*	syslog(LOG_INFO, "creating pass rule to %s:%hu protocol %s for: %s",
-		iaddr, iport, protocol, desc);*/
-	if(add_filter_rule2(ext_if_name, rhost, iaddr, eport, iport, proto, desc) < 0) {
-		/* clean up the redirect rule */
-#if !defined(__linux__)
-		delete_redirect_rule(ext_if_name, eport, proto);
-#endif
+	if(inet_aton(iaddr, &address) < 0) {
+		syslog(LOG_ERR, "inet_aton(%s) : %m", iaddr);
 		return -1;
 	}
-	if(timestamp > 0) {
-		if(!nextruletoclean_timestamp || (timestamp < nextruletoclean_timestamp))
-			nextruletoclean_timestamp = timestamp;
-	}
-#ifdef ENABLE_EVENTS
-	/* the number of port mappings changed, we must
-	 * inform the subscribers */
-	upnp_event_var_change_notify(EWanIPC);
-#endif
-	return 0;
+
+	return addStaticNatEntry_wrapper(address, proto, iport, eport);
 }
 
 
@@ -361,10 +321,9 @@ upnp_get_redirection_infos(unsigned short eport, const char * protocol,
 		desc[0] = '\0';
 	if(rhost && (rhostlen > 0))
 		rhost[0] = '\0';
-	r = get_redirect_rule(ext_if_name, eport, proto_atoi(protocol),
-	                      iaddr, iaddrlen, iport, desc, desclen,
-	                      rhost, rhostlen, &timestamp,
-	                      0, 0);
+	r = getSpecificEntry( eport, proto_atoi(protocol),
+	                      iaddr, iaddrlen, iport,
+	                      rhost, rhostlen, &timestamp);
 	if(r == 0 &&
 	   timestamp > 0 &&
 	   timestamp > (unsigned int)(current_time = time(NULL))) {
@@ -384,7 +343,6 @@ upnp_get_redirection_infos_by_index(int index,
                                     char * rhost, int rhostlen,
                                     unsigned int * leaseduration)
 {
-	/*char ifname[IFNAMSIZ];*/
 	int proto = 0;
 	unsigned int timestamp;
 	time_t current_time;
@@ -393,18 +351,18 @@ upnp_get_redirection_infos_by_index(int index,
 		desc[0] = '\0';
 	if(rhost && (rhostlen > 0))
 		rhost[0] = '\0';
-	if(get_redirect_rule_by_index(index, 0/*ifname*/, eport, iaddr, iaddrlen,
-	                              iport, &proto, desc, desclen,
-	                              rhost, rhostlen, &timestamp,
-	                              0, 0) < 0)
+
+	if (getStaticNatConfigByEntry(index, iaddr, iaddrlen, eport, iport, &proto) < 0)
+	{
 		return -1;
+	}
 	else
 	{
 		current_time = time(NULL);
 		*leaseduration = (timestamp > (unsigned int)current_time)
 		                 ? (timestamp - current_time)
 		                 : 0;
-		if(proto == IPPROTO_TCP)
+		if(proto == IPPROTO_TCP) //17 = UDP, 
 			memcpy(protocol, "TCP", 4);
 		else
 			memcpy(protocol, "UDP", 4);
@@ -418,7 +376,7 @@ _upnp_delete_redir(unsigned short eport, int proto)
 {
 	int r;
 #if defined(__linux__)
-	r = delete_redirect_and_filter_rules(eport, proto);
+	r = deleteStaticNatEntry_wrapper( eport, proto);
 #else
 	r = delete_redirect_rule(ext_if_name, eport, proto);
 	delete_filter_rule(ext_if_name, eport, proto);
@@ -466,45 +424,18 @@ upnp_get_portmapping_number_of_entries()
 struct rule_state *
 get_upnp_rules_state_list(int max_rules_number_target)
 {
-	/*char ifname[IFNAMSIZ];*/
-	int proto;
-	unsigned short iport;
-	unsigned int timestamp;
 	struct rule_state * tmp;
 	struct rule_state * list = 0;
 	struct rule_state * * p;
 	int i = 0;
 	time_t current_time;
 
-	/*ifname[0] = '\0';*/
 	tmp = malloc(sizeof(struct rule_state));
 	if(!tmp)
 		return 0;
 	current_time = time(NULL);
 	nextruletoclean_timestamp = 0;
-	while(get_redirect_rule_by_index(i, /*ifname*/0, &tmp->eport, 0, 0,
-	                              &iport, &proto, 0, 0, 0,0, &timestamp,
-								  &tmp->packets, &tmp->bytes) >= 0)
-	{
-		tmp->to_remove = 0;
-		if(timestamp > 0) {
-			/* need to remove this port mapping ? */
-			if(timestamp <= (unsigned int)current_time)
-				tmp->to_remove = 1;
-			else if((nextruletoclean_timestamp <= (unsigned int)current_time)
-			       || (timestamp < nextruletoclean_timestamp))
-				nextruletoclean_timestamp = timestamp;
-		}
-		tmp->proto = (short)proto;
-		/* add tmp to list */
-		tmp->next = list;
-		list = tmp;
-		/* prepare next iteration */
-		i++;
-		tmp = malloc(sizeof(struct rule_state));
-		if(!tmp)
-			break;
-	}
+
 	free(tmp);
 	/* remove the redirections that need to be removed */
 	for(p = &list, tmp = list; tmp; tmp = *p)
@@ -536,27 +467,12 @@ get_upnp_rules_state_list(int max_rules_number_target)
 void
 remove_unused_rules(struct rule_state * list)
 {
-	char ifname[IFNAMSIZ];
-	unsigned short iport;
 	struct rule_state * tmp;
-	u_int64_t packets;
-	u_int64_t bytes;
-	unsigned int timestamp;
 	int n = 0;
 
 	while(list)
 	{
 		/* remove the rule if no traffic has used it */
-		if(get_redirect_rule(ifname, list->eport, list->proto,
-	                         0, 0, &iport, 0, 0, 0, 0, &timestamp,
-		                     &packets, &bytes) >= 0)
-		{
-			if(packets == list->packets && bytes == list->bytes)
-			{
-				_upnp_delete_redir(list->eport, list->proto);
-				n++;
-			}
-		}
 		tmp = list;
 		list = tmp->next;
 		free(tmp);
@@ -569,16 +485,15 @@ remove_unused_rules(struct rule_state * list)
  * return a list of all "external" ports for which a port
  * mapping exists */
 unsigned short *
-upnp_get_portmappings_in_range(unsigned short startport,
-                               unsigned short endport,
-                               const char * protocol,
+upnp_get_portmappings_in_range(const char * protocol,
                                unsigned int * number)
 {
 	int proto;
 	proto = proto_atoi(protocol);
 	if(!number)
 		return NULL;
-	return get_portmappings_in_range(startport, endport, proto, number);
+	//return get_portmappings_in_range(startport, endport, proto, number);
+	return NULL;
 }
 
 /* stuff for miniupnpdctl */
@@ -586,34 +501,7 @@ upnp_get_portmappings_in_range(unsigned short startport,
 void
 write_ruleset_details(int s)
 {
-	int proto = 0;
-	unsigned short eport, iport;
-	char desc[64];
-	char iaddr[32];
-	char rhost[32];
-	unsigned int timestamp;
-	u_int64_t packets;
-	u_int64_t bytes;
-	int i = 0;
-	char buffer[256];
-	int n;
-
 	write(s, "Ruleset :\n", 10);
-	while(get_redirect_rule_by_index(i, 0/*ifname*/, &eport, iaddr, sizeof(iaddr),
-	                                 &iport, &proto, desc, sizeof(desc),
-	                                 rhost, sizeof(rhost),
-	                                 &timestamp,
-	                                 &packets, &bytes) >= 0)
-	{
-		n = snprintf(buffer, sizeof(buffer),
-		             "%2d %s %s:%hu->%s:%hu "
-		             "'%s' %u %" PRIu64 " %" PRIu64 "\n",
-		             /*"'%s' %llu %llu\n",*/
-		             i, proto==IPPROTO_TCP?"TCP":"UDP", rhost,
-		             eport, iaddr, iport, desc, timestamp, packets, bytes);
-		write(s, buffer, n);
-		i++;
-	}
 }
 #endif
 
diff --git a/upnpredirect.h b/upnpredirect.h
index b549824..68a29d6 100644
--- a/upnpredirect.h
+++ b/upnpredirect.h
@@ -26,7 +26,7 @@ int reload_from_lease_file(void);
  *          -3 permission check failed
  */
 int
-upnp_redirect(const char * rhost, unsigned short eport,
+upnp_redirect(/*const char * rhost,*/unsigned short eport, 
               const char * iaddr, unsigned short iport,
               const char * protocol, const char * desc,
               unsigned int leaseduration);
@@ -34,16 +34,16 @@ upnp_redirect(const char * rhost, unsigned short eport,
 /* upnp_redirect_internal()
  * same as upnp_redirect() without any check */
 int
-upnp_redirect_internal(const char * rhost, unsigned short eport,
+upnp_redirect_internal(/*const char * rhost,*/unsigned short eport, 
                        const char * iaddr, unsigned short iport,
-                       int proto, const char * desc,
-                       unsigned int timestamp);
+                       int proto/*, const char * desc,
+                      unsigned int timestamp*/); 
 
 /* upnp_get_redirection_infos()
  * returns : 0 on success
  *           -1 failed to get the port mapping entry or no entry exists */
 int
-upnp_get_redirection_infos(unsigned short eport, const char * protocol,
+upnp_get_redirection_infos(unsigned short eport, const char *protocol,
                            unsigned short * iport, char * iaddr, int iaddrlen,
                            char * desc, int desclen,
                            char * rhost, int rhostlen,
@@ -103,8 +103,8 @@ remove_unused_rules(struct rule_state * list);
  * return a list of all "external" ports for which a port
  * mapping exists */
 unsigned short *
-upnp_get_portmappings_in_range(unsigned short startport,
-                               unsigned short endport,
+upnp_get_portmappings_in_range(/*unsigned short startport,
+                               unsigned short endport,*/
                                const char * protocol,
                                unsigned int * number);
 
diff --git a/upnpsoap.c b/upnpsoap.c
index 0157f72..4950467 100644
--- a/upnpsoap.c
+++ b/upnpsoap.c
@@ -88,7 +88,8 @@ GetTotalBytesSent(struct upnphttp * h, const char * action)
 	int bodylen;
 	struct ifdata data;

-	r = getifstats(ext_if_name, &data);
+	//replaced getifstats(ext_if_name, &data); with call to QCMAP
+	r = getIfaceStats(&data);
 	bodylen = snprintf(body, sizeof(body), resp,
 	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
              r<0?0:data.obytes, action);
@@ -110,7 +111,8 @@ GetTotalBytesReceived(struct upnphttp * h, const char * action)
 	int bodylen;
 	struct ifdata data;

-	r = getifstats(ext_if_name, &data);
+	//replaced getifstats(ext_if_name, &data); with call to QCMAP
+	r = getIfaceStats(&data);
 	bodylen = snprintf(body, sizeof(body), resp,
 	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
 	         r<0?0:data.ibytes, action);
@@ -132,7 +134,8 @@ GetTotalPacketsSent(struct upnphttp * h, const char * action)
 	int bodylen;
 	struct ifdata data;

-	r = getifstats(ext_if_name, &data);
+	//replaced  getifstats(ext_if_name, &data); with call to QCMAP
+	r = getIfaceStats(&data);
 	bodylen = snprintf(body, sizeof(body), resp,
 	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
 	         r<0?0:data.opackets, action);
@@ -154,7 +157,8 @@ GetTotalPacketsReceived(struct upnphttp * h, const char * action)
 	int bodylen;
 	struct ifdata data;

-	r = getifstats(ext_if_name, &data);
+	//replaced getifstats(ext_if_name, &data); with call to QCMAP
+	r = getIfaceStats(&data);
 	bodylen = snprintf(body, sizeof(body), resp,
 	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
 	         r<0?0:data.ipackets, action);
@@ -191,7 +195,7 @@ GetCommonLinkProperties(struct upnphttp * h, const char * action)
 			if(upstream_bitrate == 0) upstream_bitrate = data.baudrate;
 		}
 	}
-	if(getifaddr(ext_if_name, ext_ip_addr, INET_ADDRSTRLEN) < 0) {
+	if(getIPAddr(ext_ip_addr, INET_ADDRSTRLEN) < 0) {
 		status = "Down";
 	}
 	bodylen = snprintf(body, sizeof(body), resp,
@@ -220,7 +224,7 @@ GetStatusInfo(struct upnphttp * h, const char * action)
 	 * Unconfigured, Connecting, Connected, PendingDisconnect,
 	 * Disconnecting, Disconnected */

-	status = get_wan_connection_status_str(ext_if_name);
+	status = getWanStatusStr();
 	uptime = (time(NULL) - startup_time);
 	bodylen = snprintf(body, sizeof(body), resp,
 		action, SERVICE_TYPE_WANIPC,
@@ -269,10 +273,9 @@ GetExternalIPAddress(struct upnphttp * h, const char * action)
 	{
 		strncpy(ext_ip_addr, use_ext_ip_addr, INET_ADDRSTRLEN);
 	}
-	else if(getifaddr(ext_if_name, ext_ip_addr, INET_ADDRSTRLEN) < 0)
+	else if(getIPAddr(ext_ip_addr, INET_ADDRSTRLEN) < 0)
 	{
-		syslog(LOG_ERR, "Failed to get ip address for interface %s",
-			ext_if_name);
+		syslog(LOG_ERR, "Failed to get ip address for interface");
 		strncpy(ext_ip_addr, "0.0.0.0", INET_ADDRSTRLEN);
 	}
 #else
@@ -409,7 +412,7 @@ AddPortMapping(struct upnphttp * h, const char * action)
 	       action, eport, int_ip, iport, protocol, desc, leaseduration,
 	       r_host ? r_host : "NULL");
 
-	r = upnp_redirect(r_host, eport, int_ip, iport, protocol, desc, leaseduration);
+	r = upnp_redirect(/*r_host,*/eport, int_ip, iport, protocol, desc, leaseduration); 
 
 	ClearNameValueList(&data);
 
@@ -545,7 +548,7 @@ AddAnyPortMapping(struct upnphttp * h, const char * action)
 	/* TODO : accept a different external port
 	 * have some smart strategy to choose the port */
 	for(;;) {
-		r = upnp_redirect(r_host, eport, int_ip, iport, protocol, desc, leaseduration);
+		r = upnp_redirect(/*r_host,*/eport, int_ip, iport, protocol, desc, leaseduration); 
 		if(r==-2 && eport < 65535) {
 			eport++;
 		} else {
@@ -631,7 +634,7 @@ GetSpecificPortMappingEntry(struct upnphttp * h, const char * action)
 	 * but different remoteHost to be set up, so that is not
 	 * a priority. */
 	r = upnp_get_redirection_infos(eport, protocol, &iport,
-	                               int_ip, sizeof(int_ip),
+								   int_ip, sizeof(int_ip),
 	                               desc, sizeof(desc),
 	                               NULL, 0,
 	                               &leaseduration);
@@ -763,8 +766,8 @@ DeletePortMappingRange(struct upnphttp * h, const char * action)
 		return;
 	}
 
-	port_list = upnp_get_portmappings_in_range(startport, endport,
-	                                           protocol, &number);
+	port_list = upnp_get_portmappings_in_range(protocol, &number);
+
 	for(i = 0; i < number; i++)
 	{
 		r = upnp_delete_redirection(port_list[i], protocol);
@@ -958,7 +961,7 @@ http://www.upnp.org/schemas/gw/WANIPConnection-v2.xsd">
 	memcpy(body+bodylen, list_start, sizeof(list_start));
 	bodylen += (sizeof(list_start) - 1);
 
-	port_list = upnp_get_portmappings_in_range(startport, endport,
+	port_list = upnp_get_portmappings_in_range(/*startport, endport,*/
 	                                           protocol, &list_size);
 	/* loop through port mappings */
 	for(i = 0; number > 0 && i < list_size; i++)
@@ -980,9 +983,9 @@ http://www.upnp.org/schemas/gw/WANIPConnection-v2.xsd">
 		}
 		rhost[0] = '\0';
 		r = upnp_get_redirection_infos(port_list[i], protocol, &iport,
-		                               int_ip, sizeof(int_ip),
-		                               desc, sizeof(desc),
-		                               rhost, sizeof(rhost),
+								   int_ip, sizeof(int_ip),
+	                               desc, sizeof(desc),
+	                               NULL, 0,
 		                               &leaseduration);
 		if(r == 0)
 		{
@@ -1134,7 +1137,7 @@ QueryStateVariable(struct upnphttp * h, const char * action)
	{
		const char * status;

-		status = get_wan_connection_status_str(ext_if_name);
+		status = getWanStatusStr();
		bodylen = snprintf(body, sizeof(body), resp,
                            action, "urn:schemas-upnp-org:control-1-0",
		                   status, action);
-- 
1.7.8.3

