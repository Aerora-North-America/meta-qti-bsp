From 4f827e71c355e010c2bc555c7dcefcad85a4c383 Mon Sep 17 00:00:00 2001
From: Tyler Wear <twear@codeaurora.org>
Date: Thu, 11 Apr 2013 14:00:32 -0700
Subject: [PATCH 2/2] qcmap-enabled

---
 Makefile.linux                |   82 +++++++++++++--------
 UPNP_QCMAP_Client.cpp         |  163 +++++++++++++++++++++++++++++++++++++++++
 UPNP_QCMAP_Client.h           |   33 ++++++++
 config.h                      |  100 +++++++++++++++++++++++++
 linux/miniupnpd.init.d.script |   21 +----
 miniupnpd.c                   |   10 ++-
 miniupnpd.conf                |   20 +++--
 natpmp.c                      |   69 +++++++++---------
 upnpdescgen.c                 |    4 +-
 upnpredirect.c                |  162 ++++++----------------------------------
 upnpredirect.h                |   14 ++--
 upnpsoap.c                    |   30 ++++---
 12 files changed, 456 insertions(+), 252 deletions(-)
 create mode 100755 UPNP_QCMAP_Client.cpp
 create mode 100755 UPNP_QCMAP_Client.h
 create mode 100644 config.h
 mode change 100644 => 100755 upnpsoap.c

diff --git a/Makefile.linux b/Makefile.linux
index 3521a5a..d51be70 100644
--- a/Makefile.linux
+++ b/Makefile.linux
@@ -29,10 +29,10 @@ CFLAGS += -Wall
 CFLAGS += -Wextra -Wstrict-prototypes -Wdeclaration-after-statement
 #CFLAGS += -Wno-missing-field-initializers
 #CFLAGS += -ansi	# iptables headers does use typeof which is a gcc extension
-CC ?= gcc
+#CC ?= gcc
 RM = rm -f
 INSTALL = install
-STRIP ?= strip
+#STRIP ?= strip
 CP = cp
 
 
@@ -48,13 +48,14 @@ BASEOBJS = miniupnpd.o upnphttp.o upnpdescgen.o upnpsoap.o \
            upnpevents.o upnputils.o getconnstatus.o \
            upnppinhole.o
 
-LNXOBJS = linux/getifstats.o linux/ifacewatcher.o linux/getroute.o
-NETFILTEROBJS = netfilter/iptcrdr.o netfilter/iptpinhole.o
+CPPOBJS = UPNP_QCMAP_Client.o
+		   
+LNXOBJS = linux/getifstats.o linux/ifacewatcher.o
 
 ALLOBJS = $(BASEOBJS) $(LNXOBJS) $(NETFILTEROBJS)
 
 ifeq "$(wildcard /etc/gentoo-release )" ""
-LIBS ?= -liptc
+#LIBS ?= -liptc
 else # gentoo
 # the following is better, at least on gentoo with iptables 1.4.6
 # see http://miniupnp.tuxfamily.org/forum/viewtopic.php?p=1618
@@ -65,8 +66,8 @@ endif
 
 ARCH ?= $(shell uname -m | grep -q "x86_64" && echo 64)
 ifdef IPTABLESPATH
-CFLAGS := $(CFLAGS) -I$(IPTABLESPATH)/include/
-LDFLAGS := $(LDFLAFGS) -L$(IPTABLESPATH)/libiptc/
+#CFLAGS := $(CFLAGS) -I$(IPTABLESPATH)/include/
+#LDFLAGS := $(LDFLAFGS) -L$(IPTABLESPATH)/libiptc/
 # get iptables version and set IPTABLES_143 macro if needed
 ifeq ($(TARGET_OPENWRT),)
 IPTABLESVERSION := $(shell grep "\#define VERSION" $(IPTABLESPATH)/config.h | tr -d \" |cut -d" " -f3 )
@@ -103,7 +104,7 @@ else # ifdef IPTABLESPATH
 TEST := $(shell test -f /usr/include/xtables.h && grep -q "XTABLES_VERSION_CODE" /usr/include/xtables.h && echo 1)
 ifeq ($(TEST), 1)
 CFLAGS := $(CFLAGS) -DIPTABLES_143
-LIBS = -liptc
+#LIBS = -liptc
 TESTIP4TC := $(shell test -f /lib/libip4tc.so && echo 1)
 ifeq ($(TESTIP4TC), 1)
 LIBS := $(LIBS) -lip4tc
@@ -115,13 +116,16 @@ endif # ($(TESTIP6TC), 1)
 endif # ($(TEST), 1)
 endif # ifdef IPTABLESPATH
 
-LIBS += -lnfnetlink
+#LIBS += -lnfnetlink
+
+LIBS += ${LIBDIR}/libqcmap_client.so.1
+LDFLAGS := $(LDFLAFGS) -L${LIBDIR}/libqcmap_client.so.1
+#CFLAGS += $(qcmap_client_inc)
 
 TESTUPNPDESCGENOBJS = testupnpdescgen.o upnpdescgen.o
 
 EXECUTABLES = miniupnpd testupnpdescgen testgetifstats \
               testupnppermissions miniupnpdctl testgetifaddr \
-              testgetroute
 
 .PHONY:	all clean install depend genuuid
 
@@ -130,26 +134,21 @@ all:	$(EXECUTABLES)
 clean:
 	$(RM) $(ALLOBJS)
 	$(RM) $(EXECUTABLES)
+	$(RM) UPNP_QCMAP_Client.o
 	$(RM) testupnpdescgen.o testgetifstats.o
 	$(RM) testupnppermissions.o testgetifaddr.o
-	$(RM) testgetroute.o
 	$(RM) miniupnpdctl.o
 
 install:	miniupnpd miniupnpd.8 miniupnpd.conf genuuid \
-	netfilter/iptables_init.sh netfilter/iptables_removeall.sh \
-	netfilter/ip6tables_init.sh netfilter/ip6tables_removeall.sh \
 	linux/miniupnpd.init.d.script
 	$(STRIP) miniupnpd
 	$(INSTALL) -d $(SBININSTALLDIR)
 	$(INSTALL) miniupnpd $(SBININSTALLDIR)
 	$(INSTALL) -d $(ETCINSTALLDIR)
-	$(INSTALL) netfilter/iptables_init.sh $(ETCINSTALLDIR)
-	$(INSTALL) netfilter/iptables_removeall.sh $(ETCINSTALLDIR)
-	$(INSTALL) netfilter/ip6tables_init.sh $(ETCINSTALLDIR)
-	$(INSTALL) netfilter/ip6tables_removeall.sh $(ETCINSTALLDIR)
 	$(INSTALL) --mode=0644 -b miniupnpd.conf $(ETCINSTALLDIR)
 	$(INSTALL) -d $(PREFIX)/etc/init.d
 	$(INSTALL) linux/miniupnpd.init.d.script $(PREFIX)/etc/init.d/miniupnpd
+	$(INSTALL) -d $(MANINSTALLDIR)
 	$(INSTALL) miniupnpd.8 $(MANINSTALLDIR)
 	gzip $(MANINSTALLDIR)/miniupnpd.8
 
@@ -162,7 +161,8 @@ else
 	sed -i -e "s/^uuid=[-0-9a-f]*/uuid=`($(STAGING_DIR_HOST)/bin/genuuid||$(STAGING_DIR_HOST)/bin/uuidgen||$(STAGING_DIR_HOST)/bin/uuid) 2>/dev/null`/" miniupnpd.conf
 endif
 
-miniupnpd:	$(BASEOBJS) $(LNXOBJS) $(NETFILTEROBJS) $(LIBS)
+miniupnpd: $(BASEOBJS) $(CPPOBJS) $(LNXOBJS)
+	$(CXX) $(CFLAGS) $(LDFLAFGS) -o $@ $(BASEOBJS) $(CPPOBJS) $(LNXOBJS) $(LIBS)
 
 testupnpdescgen:	$(TESTUPNPDESCGENOBJS)
 
@@ -172,8 +172,6 @@ testupnppermissions:	testupnppermissions.o upnppermissions.o
 
 testgetifaddr:	testgetifaddr.o getifaddr.o
 
-testgetroute:	testgetroute.o linux/getroute.o upnputils.o -lnfnetlink
-
 miniupnpdctl:	miniupnpdctl.o
 
 config.h:	genconfig.sh VERSION
@@ -184,13 +182,38 @@ depend:	config.h
 	$(ALLOBJS:.o=.c) $(TESTUPNPDESCGENOBJS:.o=.c) \
 	testgetifstats.c 2>/dev/null

+qcmap_client_inc = -D__packed__= \
+        -DIMAGE_APPS_PROC \
+        -DFEATURE_Q_NO_SELF_QPTR \
+        -DAEEINTERFACE_CPLUSPLUS \
+        -DFEATURE_SMD \
+        -DFEATURE_DIAG_MP_MASTER_APPS \
+        -DFEATURE_DS_LINUX_ANDROID \
+        -DFEATURE_DSS_LINUX \
+        -DFEATURE_LINUX \
+        -DFEATURE_MULTIPROCESSOR \
+        -DFEATURE_DSUTILS_OFFTARGET \
+        -DFEATURE_NO_REX \
+        -DFEATURE_XMLLIB \
+		 -I$(INCDIR) \
+		 -I$(INCDIR)/rpcsvc \
+        -I$(INCDIR)/data \
+        -I$(INCDIR)/qmi-framework\
+        -I$(INCDIR)/qmi \
+        -I$(INCDIR)/diag \
+        -I$(INCDIR)/dsutils \
+        -I$(INCDIR)/xmllib
+
+CPPFLAGS += -Dstrlcpy=strncpy -Dstrlcat=strncat $(qcmap_client_inc)
+#LIBS += -lpthread -lrt libqcmap_client.la
+
 # DO NOT DELETE
 
 miniupnpd.o: config.h macros.h upnpglobalvars.h upnppermissions.h
 miniupnpd.o: miniupnpdtypes.h upnphttp.h upnpdescgen.h miniupnpdpath.h
 miniupnpd.o: getifaddr.h upnpsoap.h options.h minissdp.h upnpredirect.h
 miniupnpd.o: upnppinhole.h daemonize.h upnpevents.h natpmp.h commonrdr.h
-miniupnpd.o: upnputils.h ifacewatcher.h
+miniupnpd.o: upnputils.h ifacewatcher.h UPNP_QCMAP_Client.h
 upnphttp.o: config.h upnphttp.h upnpdescgen.h miniupnpdpath.h upnpsoap.h
 upnphttp.o: upnpevents.h upnputils.h
 upnpdescgen.o: config.h getifaddr.h upnpredirect.h upnpdescgen.h
@@ -204,7 +227,10 @@ upnpreplyparse.o: upnpreplyparse.h minixml.h
 minixml.o: minixml.h
 upnpredirect.o: macros.h config.h upnpredirect.h upnpglobalvars.h
 upnpredirect.o: upnppermissions.h miniupnpdtypes.h upnpevents.h
-upnpredirect.o: netfilter/iptcrdr.h commonrdr.h
+upnpredirect.o: commonrdr.h
+upnpredirect.o: UPNP_QCMAP_Client.h
+UPNP_QCMAP_Client.o: UPNP_QCMAP_Client.cpp UPNP_QCMAP_Client.h
+	$(CXX) $(CPPFLAGS) -c UPNP_QCMAP_Client.cpp
 getifaddr.o: config.h getifaddr.h
 daemonize.o: daemonize.h config.h
 upnpglobalvars.o: config.h upnpglobalvars.h upnppermissions.h
@@ -214,7 +240,7 @@ options.o: miniupnpdtypes.h
 upnppermissions.o: config.h upnppermissions.h
 minissdp.o: config.h upnpdescstrings.h miniupnpdpath.h upnphttp.h
 minissdp.o: upnpglobalvars.h upnppermissions.h miniupnpdtypes.h minissdp.h
-minissdp.o: upnputils.h getroute.h codelength.h
+minissdp.o: upnputils.h codelength.h
 natpmp.o: macros.h config.h natpmp.h upnpglobalvars.h upnppermissions.h
 natpmp.o: miniupnpdtypes.h getifaddr.h upnpredirect.h commonrdr.h upnputils.h
 upnpevents.o: config.h upnpevents.h miniupnpdpath.h upnpglobalvars.h
@@ -223,20 +249,12 @@ upnputils.o: config.h upnputils.h
 getconnstatus.o: getconnstatus.h getifaddr.h
 upnppinhole.o: macros.h config.h upnpredirect.h upnpglobalvars.h
 upnppinhole.o: upnppermissions.h miniupnpdtypes.h upnpevents.h
-upnppinhole.o: netfilter/iptpinhole.h
 linux/getifstats.o: config.h getifstats.h
 linux/ifacewatcher.o: config.h ifacewatcher.h config.h minissdp.h
 linux/ifacewatcher.o: miniupnpdtypes.h getifaddr.h upnpglobalvars.h
 linux/ifacewatcher.o: upnppermissions.h natpmp.h
-linux/getroute.o: getroute.h upnputils.h
-netfilter/iptcrdr.o: macros.h config.h netfilter/iptcrdr.h commonrdr.h
-netfilter/iptcrdr.o: config.h upnpglobalvars.h upnppermissions.h
-netfilter/iptcrdr.o: miniupnpdtypes.h
-netfilter/iptpinhole.o: config.h netfilter/iptpinhole.h upnpglobalvars.h
-netfilter/iptpinhole.o: upnppermissions.h config.h miniupnpdtypes.h
-netfilter/iptpinhole.o: netfilter/tiny_nf_nat.h
 testupnpdescgen.o: macros.h config.h upnpdescgen.h
 upnpdescgen.o: config.h getifaddr.h upnpredirect.h upnpdescgen.h
 upnpdescgen.o: miniupnpdpath.h upnpglobalvars.h upnppermissions.h
 upnpdescgen.o: miniupnpdtypes.h upnpdescstrings.h upnpurns.h getconnstatus.h
-testgetifstats.o: getifstats.h
+testgetifstats.o: getifstats.h
\ No newline at end of file
diff --git a/UPNP_QCMAP_Client.cpp b/UPNP_QCMAP_Client.cpp
new file mode 100755
index 0000000..bb52def
--- /dev/null
+++ b/UPNP_QCMAP_Client.cpp
@@ -0,0 +1,163 @@
+#include "QCMAP_Client.h"
+#include "getifstats.h"
+
+QCMAP_Client *QcMapClient = NULL;
+
+#ifdef __cplusplus
+       extern "C"
+       {
+#endif
+
+int addStaticNatEntry_wrapper(struct in_addr addr, unsigned int proto, unsigned int local_port, unsigned int g_port)
+{
+  qcmap_msgr_snat_entry_config_v01 snat_entry;
+  qmi_error_type_v01 qmi_err_num;
+
+  /* Port mapping is not present, try to add it */
+  memset(&snat_entry, 0, sizeof(qcmap_msgr_snat_entry_config_v01));
+  snat_entry.private_ip_addr = ntohl(addr.s_addr);
+  snat_entry.protocol = (uint8)proto;
+  snat_entry.private_port = (uint16)local_port;
+  snat_entry.global_port = (uint16)g_port;
+  
+  if (!QcMapClient->AddStaticNatEntry(&snat_entry, &qmi_err_num))
+  {
+    if(qmi_err_num == QMI_ERR_NO_EFFECT_V01)
+	  return -2;
+	return -1;
+  }
+  return 0;
+}
+
+int deleteStaticNatEntry_wrapper(unsigned short port, int proto)
+{
+  qcmap_msgr_snat_entry_config_v01 snat_entry;
+  qcmap_msgr_snat_entry_config_v01 snat_config[QCMAP_MSGR_MAX_SNAT_ENTRIES_V01];
+  int i=0, num_entries=0;
+  qmi_error_type_v01 qmi_err_num;
+
+  memset(&snat_entry, 0, sizeof(qcmap_msgr_snat_entry_config_v01));
+  snat_entry.protocol = (uint8)proto;
+  snat_entry.global_port = (uint16)port;
+
+  memset(snat_config, 0, QCMAP_MSGR_MAX_SNAT_ENTRIES_V01*sizeof(qcmap_msgr_snat_entry_config_v01));
+  if (QcMapClient->GetStaticNatConfig(snat_config, &num_entries, &qmi_err_num))
+  {
+    for (i=0; i<num_entries; i++)
+    {
+      if(port == snat_config[i].global_port && proto == snat_config[i].protocol)
+      {
+        snat_entry.private_ip_addr = snat_config[i].private_ip_addr;
+        snat_entry.private_port = snat_config[i].private_port;
+
+        return QcMapClient->DeleteStaticNatEntry(&snat_entry, &qmi_err_num);  //something is going wrong here
+      }
+    }
+  }
+  return -1;
+}
+
+int getStaticNatConfigByEntry(int index, char *addr, int addrlen, unsigned short *eport, unsigned short *iport, int *proto)
+{
+  qmi_error_type_v01 qmi_err_num;
+  in_addr tmpIP;
+  int i=0, num_entries=0;
+  qcmap_msgr_snat_entry_config_v01 snat_config[QCMAP_MSGR_MAX_SNAT_ENTRIES_V01];
+
+  memset(snat_config, 0, QCMAP_MSGR_MAX_SNAT_ENTRIES_V01*sizeof(qcmap_msgr_snat_entry_config_v01));
+  if (QcMapClient->GetStaticNatConfig(snat_config, &num_entries, &qmi_err_num))
+  {
+    for (i=0; i<num_entries; i++)
+    {
+      if(i == index)
+      {
+        tmpIP.s_addr = ntohl(snat_config[i].private_ip_addr);
+        snprintf(addr, addrlen,"%u.%u.%u.%u", tmpIP.s_addr & 0xff, (tmpIP.s_addr >> 8) & 0xff, (tmpIP.s_addr >> 16) & 0xff, tmpIP.s_addr >> 24);
+        *iport = snat_config[i].private_port;
+        *eport = snat_config[i].global_port;
+        *proto = snat_config[i].protocol;
+
+        return 0;
+      }
+    }
+  }
+
+  return -1;
+}
+
+int getSpecificEntry(unsigned int eport, unsigned int proto, char *addr, int addrlen, unsigned short *iport, char * rhost, int rhostlen, unsigned int * timestamp)
+{
+  qmi_error_type_v01 qmi_err_num;
+  in_addr tmpIP;
+  int i=0, num_entries=0;
+  qcmap_msgr_snat_entry_config_v01 snat_config[QCMAP_MSGR_MAX_SNAT_ENTRIES_V01];
+
+  memset(snat_config, 0, QCMAP_MSGR_MAX_SNAT_ENTRIES_V01*sizeof(qcmap_msgr_snat_entry_config_v01));
+  if (QcMapClient->GetStaticNatConfig(snat_config, &num_entries, &qmi_err_num))
+  {
+    for (i=0; i<num_entries; i++)
+    {
+      if((snat_config[i].global_port == (uint16)eport) && (snat_config[i].protocol == (uint8)proto))
+      {
+        tmpIP.s_addr = ntohl(snat_config[i].private_ip_addr);
+        snprintf(addr, addrlen,"%u.%u.%u.%u", tmpIP.s_addr & 0xff, (tmpIP.s_addr >> 8) & 0xff, (tmpIP.s_addr >> 16) & 0xff, tmpIP.s_addr >> 24);
+        *iport = snat_config[i].private_port;
+
+        return 0;
+      }
+    }
+  }
+
+  return 1;
+}
+
+int getIfaceStats(struct ifdata * data)
+{
+  qmi_error_type_v01 qmi_err_num;
+  qcmap_msgr_ip_family_enum_v01 ip_family;
+  qcmap_msgr_wwan_statistics_type_v01 wwan_stats;
+
+  //IP family, IPV4-4 IPV6-6
+  ip_family = (qcmap_msgr_ip_family_enum_v01) 4;
+
+  if (QcMapClient->GetWWANStatistics(ip_family, &wwan_stats, &qmi_err_num))
+  {
+    data->baudrate = 4200000;	/* that is the answer */
+  	data->opackets = wwan_stats.pkts_tx;
+  	data->ipackets = wwan_stats.pkts_rx;
+  	data->obytes = wwan_stats.bytes_tx;
+  	data->ibytes = wwan_stats.bytes_rx;
+    return 0;
+  }
+
+  return -1;
+}
+
+int QCMAPClient(){
+  qmi_error_type_v01 qmi_err_num;
+  if(QcMapClient != NULL)
+  {
+    return 0;
+  }
+
+  QcMapClient = new QCMAP_Client(NULL);
+  QcMapClient->EnableMobileAP(&qmi_err_num);
+  return 1;
+}
+
+int tearDownQCMAPClient(){
+  qmi_error_type_v01 qmi_err_num;
+  if(QcMapClient == NULL)
+  {
+    return 0;
+  }
+
+  QcMapClient->DisableMobileAP(&qmi_err_num);
+  delete(QcMapClient);
+
+  return 1;
+}
+
+#ifdef __cplusplus
+       }
+#endif
\ No newline at end of file
diff --git a/UPNP_QCMAP_Client.h b/UPNP_QCMAP_Client.h
new file mode 100755
index 0000000..30090fc
--- /dev/null
+++ b/UPNP_QCMAP_Client.h
@@ -0,0 +1,33 @@
+#include "QCMAP_Client.h"
+#include "qualcomm_mobile_access_point_msgr_v01.h"
+extern "C" {
+
+   int addStaticNatEntry_wrapper
+   (
+      struct in_addr    addr,
+      unsigned int      proto,
+      unsigned int      local_port,
+      unsigned int      g_port
+   );
+
+   int deleteStaticNatEntry_wrapper
+   (
+      unsigned short port,
+      int proto
+   );
+
+   int getStaticNatConfigByEntry
+   (
+      int index,
+      char *addr,
+      int addrlen,
+      unsigned short *eport,
+      unsigned short *iport,
+      int *proto
+   );
+
+   int getIfaceStats
+   (
+      struct ifdata * data
+   );
+#endif
\ No newline at end of file
diff --git a/config.h b/config.h
new file mode 100644
index 0000000..7ec9e8d
--- /dev/null
+++ b/config.h
@@ -0,0 +1,100 @@
+/* MiniUPnP Project
+ * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
+ * (c) 2006-2012 Thomas Bernard
+ * generated by ./genconfig.sh on Mon Dec 17 11:25:57 PST 2012
+ * using command line options  */
+#ifndef CONFIG_H_INCLUDED
+#define CONFIG_H_INCLUDED
+
+#include <inttypes.h>
+
+#define MINIUPNPD_VERSION "1.7"
+
+#define UPNP_VERSION	"20121217"
+#define USE_IFACEWATCHER 1
+#define USE_NETFILTER 0
+#define SUPPORT_REMOTEHOST
+
+#define OS_NAME		"Ubuntu"
+#define OS_VERSION	"Ubuntu/lucid"
+#define OS_URL		"http://www.ubuntu.com/"
+
+/* syslog facility to be used by miniupnpd */
+#define LOG_MINIUPNPD		 LOG_DAEMON
+
+/* Uncomment the following line to allow miniupnpd to be
+ * controlled by miniupnpdctl */
+/*#define USE_MINIUPNPDCTL*/
+
+/* Comment the following line to disable NAT-PMP operations */
+#define ENABLE_NATPMP
+
+/* Uncomment the following line to enable generation of
+ * filter rules with pf */
+/*#define PF_ENABLE_FILTER_RULES*/
+
+/* Uncomment the following line to enable caching of results of
+ * the getifstats() function */
+/*#define ENABLE_GETIFSTATS_CACHING*/
+/* The cache duration is indicated in seconds */
+#define GETIFSTATS_CACHING_DURATION 2
+
+/* Uncomment the following line to enable multiple external ip support */
+/* note : That is EXPERIMENTAL, do not use that unless you know perfectly what you are doing */
+/* Dynamic external ip adresses are not supported when this option is enabled.
+ * Also note that you would need to configure your .conf file accordingly. */
+/*#define MULTIPLE_EXTERNAL_IP*/
+
+/* Comment the following line to use home made daemonize() func instead
+ * of BSD daemon() */
+#define USE_DAEMON
+
+/* Uncomment the following line to enable lease file support */
+/*#define ENABLE_LEASEFILE*/
+
+/* Define one or none of the two following macros in order to make some
+ * clients happy. It will change the XML Root Description of the IGD.
+ * Enabling the Layer3Forwarding Service seems to be the more compatible
+ * option. */
+/*#define HAS_DUMMY_SERVICE*/
+#define ENABLE_L3F_SERVICE
+
+/* Enable IP v6 support */
+/*#define ENABLE_IPV6*/
+
+/* Enable the support of IGD v2 specification.
+ * This is not fully tested yet and can cause incompatibilities with some
+ * control points, so enable with care. */
+/*#define IGD_V2*/
+
+#ifdef IGD_V2
+/* Enable DeviceProtection service (IGDv2) */
+#define ENABLE_DP_SERVICE
+
+/* Enable WANIPv6FirewallControl service (IGDv2). needs IPv6 */
+#ifdef ENABLE_IPV6
+#define ENABLE_6FC_SERVICE
+#endif /* ENABLE_IPV6 */
+#endif /* IGD_V2 */
+
+/* UPnP Events support. Working well enough to be enabled by default.
+ * It can be disabled to save a few bytes. */
+#define ENABLE_EVENTS
+
+/* include interface name in pf and ipf rules */
+#define USE_IFNAME_IN_RULES
+
+/* Experimental NFQUEUE support. */
+/*#define ENABLE_NFQUEUE*/
+
+/* Enable to make MiniUPnPd more strict about UPnP conformance
+ * and the messages it receives from control points */
+/*#define UPNP_STRICT*/
+
+/* Add the optional Date: header in all HTTP responses */
+/*#define ENABLE_HTTP_DATE*/
+
+/* disable reading and parsing of config file (miniupnpd.conf) */
+/*#define DISABLE_CONFIG_FILE*/
+
+#endif
diff --git a/linux/miniupnpd.init.d.script b/linux/miniupnpd.init.d.script
index ee6e47b..f36ab66 100644
--- a/linux/miniupnpd.init.d.script
+++ b/linux/miniupnpd.init.d.script
@@ -16,35 +16,24 @@
 set -e
 
 MINIUPNPD=/usr/sbin/miniupnpd
-ARGS='-f /etc/miniupnpd/miniupnpd.conf'
-
-IPTABLES_CREATE=/etc/miniupnpd/iptables_init.sh
-IPTABLES_REMOVE=/etc/miniupnpd/iptables_removeall.sh
+ARGS='-f /etc/miniupnpd/miniupnpd.conf -a wlan0'
+WLANARGS='-f /etc/miniupnpd/miniupnpd.conf -i wlan0'
 
 test -f $MINIUPNPD || exit 0
 
-. /lib/lsb/init-functions
-
 case "$1" in
   start)
-	log_daemon_msg "Starting miniupnpd" "miniupnpd"
-	$IPTABLES_CREATE > /dev/null 2>&1
 	start-stop-daemon --start --quiet --pidfile /var/run/miniupnpd.pid --startas $MINIUPNPD -- $ARGS $LSBNAMES
-	log_end_msg $?
+	;;
+  startWLAN)
+	start-stop-daemon --start --quiet --pidfile /var/run/miniupnpd.pid --startas $MINIUPNPD -- $WLANARGS $LSBNAMES
 	;;
   stop)
-	log_daemon_msg "Stopping miniupnpd" "miniupnpd"
 	start-stop-daemon --stop --quiet --pidfile /var/run/miniupnpd.pid
-	log_end_msg $?
-	$IPTABLES_REMOVE > /dev/null 2>&1
 	;;
   restart|reload|force-reload)
-	log_daemon_msg "Restarting miniupnpd" "miniupnpd"
 	start-stop-daemon --stop --retry 5 --quiet --pidfile /var/run/miniupnpd.pid
-	$IPTABLES_REMOVE > /dev/null 2>&1
-	$IPTABLES_CREATE > /dev/null 2>&1
 	start-stop-daemon --start --quiet --pidfile /var/run/miniupnpd.pid --startas $MINIUPNPD -- $ARGS $LSBNAMES
-	log_end_msg $?
 	;;
   status)
 	status_of_proc /usr/sbin/miniupnpd miniupnpd
diff --git a/miniupnpd.c b/miniupnpd.c
index 050d8db..80c88e2 100644
--- a/miniupnpd.c
+++ b/miniupnpd.c
@@ -1156,9 +1156,9 @@ init(int argc, char * * argv, struct runtime_vars * v)
 		syslog(LOG_NOTICE, "Failed to set %s handler", "SIGUSR1");
 	}
 
-	if(init_redirect() < 0)
+	if(!QCMAPClient())
	{
-		syslog(LOG_ERR, "Failed to init redirection engine. EXITING");
+		syslog(LOG_ERR, "Failed to init QCMAP. EXITING");
		return 1;
	}
 #ifdef ENABLE_6FC_SERVICE
@@ -1862,6 +1862,12 @@ main(int argc, char * * argv)
	}	/* end of main loop */

 shutdown:
+    /* Tear Down QCMap Client */
+	if(!tearDownQCMAPClient())
+	{
+		syslog(LOG_ERR, "Unable to tear down QCMAP Client");
+	}
+
	/* close out open sockets */
	while(upnphttphead.lh_first != NULL)
	{
diff --git a/miniupnpd.conf b/miniupnpd.conf
index e34e088..b3de758 100644
--- a/miniupnpd.conf
+++ b/miniupnpd.conf
@@ -1,5 +1,6 @@
 # WAN network interface
-ext_ifname=eth1
+#ext_ifname=eth1
+ext_ifname=rmnet0
 #ext_ifname=xl1
 # if the WAN interface has several IP addresses, you
 # can specify the one to use below
@@ -15,8 +16,9 @@ ext_ifname=eth1
 # address associated with the subnet follows. for example :
 #  listening_ip=192.168.0.1/24 88.22.44.13
 #listening_ip=192.168.0.1/24
-listening_ip=192.168.10.109/24
-#listening_ip=eth0
+listening_ip=wlan1
+listening_ip=rndis0
+listening_ip=ecm0
 # port for HTTP (descriptions and SOAP) traffic. set 0 for autoselect.
 port=0
 
@@ -40,7 +42,7 @@ enable_upnp=yes
 #lease_file=/var/log/upnp.leases
 
 # name of this service, default is "`uname -s` Router"
-#friendly_name=MiniUPnPd router
+friendly_name=9x25 MobileAP UPnP
 
 # bitrates reported by daemon in bits per second
 bitrate_up=1000000
@@ -105,9 +107,9 @@ model_number=1
 # ip/mask format must be nn.nn.nn.nn/nn
 # it is advised to only allow redirection of port above 1024
 # and to finish the rule set with "deny 0-65535 0.0.0.0/0 0-65535"
-allow 1024-65535 192.168.0.0/24 1024-65535
-allow 1024-65535 192.168.1.0/24 1024-65535
-allow 1024-65535 192.168.0.0/23 22
-allow 12345 192.168.7.113/32 54321
-deny 0-65535 0.0.0.0/0 0-65535
+#allow 1024-65535 192.168.0.0/24 0-65535
+#allow 1024-65535 192.168.1.0/24 1024-65535
+#allow 1024-65535 192.168.0.0/23 22
+#allow 12345 192.168.7.113/32 54321
+allow 0-65535 0.0.0.0/0 0-65535
 
diff --git a/natpmp.c b/natpmp.c
index c596781..b85b3e6 100644
--- a/natpmp.c
+++ b/natpmp.c
@@ -203,33 +203,33 @@ void ProcessIncomingNATPMPPacket(int s)
 				/* remove the mapping */
 				if(iport == 0) {
 					/* remove all the mappings for this client */
-					int index = 0;
-					unsigned short eport2, iport2;
-					char iaddr2[16];
-					int proto2;
-					char desc[64];
-					while(get_redirect_rule_by_index(index, 0,
-					          &eport2, iaddr2, sizeof(iaddr2),
-							  &iport2, &proto2,
-							  desc, sizeof(desc),
-					          0, 0, &timestamp, 0, 0) >= 0) {
-						syslog(LOG_DEBUG, "%d %d %hu->'%s':%hu '%s'",
-						       index, proto2, eport2, iaddr2, iport2, desc);
-						if(0 == strcmp(iaddr2, senderaddrstr)
-						  && 0 == memcmp(desc, "NAT-PMP", 7)) {
-							r = _upnp_delete_redir(eport2, proto2);
-							/* TODO : check return value */
-							if(r<0) {
-								syslog(LOG_ERR, "failed to remove port mapping");
-								index++;
-							} else {
-								syslog(LOG_INFO, "NAT-PMP %s port %hu mapping removed",
-								       proto2==IPPROTO_TCP?"TCP":"UDP", eport2);
-							}
-						} else {
-							index++;
-						}
-					}
+//					int index = 0;
+//					unsigned short eport2, iport2;
+//					char iaddr2[16];
+//					int proto2;
+//					char desc[64];
+//					while(get_redirect_rule_by_index(index, 0,
+//					          &eport2, iaddr2, sizeof(iaddr2),
+//							  &iport2, &proto2,
+//							  desc, sizeof(desc),
+//					          0, 0, &timestamp, 0, 0) >= 0) {
+//						syslog(LOG_DEBUG, "%d %d %hu->'%s':%hu '%s'",
+//						       index, proto2, eport2, iaddr2, iport2, desc);
+//						if(0 == strcmp(iaddr2, senderaddrstr)
+//						  && 0 == memcmp(desc, "NAT-PMP", 7)) {
+//							r = _upnp_delete_redir(eport2, proto2);
+//							/* TODO : check return value */
+//							if(r<0) {
+//								syslog(LOG_ERR, "failed to remove port mapping");
+//								index++;
+//							} else {
+//								syslog(LOG_INFO, "NAT-PMP %s port %hu mapping removed",
+//								       proto2==IPPROTO_TCP?"TCP":"UDP", eport2);
+//							}
+//						} else {
+//							index++;
+//						}
+//					}
 				} else {
 					/* To improve the interworking between nat-pmp and
 					 * UPnP, we should check that we remove only NAT-PMP
@@ -247,10 +247,11 @@ void ProcessIncomingNATPMPPacket(int s)
 			   || !check_upnp_rule_against_permissions(upnppermlist, num_upnpperm, eport, senderaddr.sin_addr, iport)) {
 				resp[3] = 2;	/* Not Authorized/Refused */
 			} else do {
-				r = get_redirect_rule(ext_if_name, eport, proto,
-				                      iaddr_old, sizeof(iaddr_old),
-				                      &iport_old, 0, 0, 0, 0,
-				                      &timestamp, 0, 0);
+				//r = get_redirect_rule(ext_if_name, eport, proto,
+				//                      iaddr_old, sizeof(iaddr_old),
+				//                      &iport_old, 0, 0, 0, 0,
+				//                      &timestamp, 0, 0);
+				r=0; //remove this
 				if(r==0) {
 					if(strcmp(senderaddrstr, iaddr_old)==0
 				       && iport==iport_old) {
@@ -279,9 +280,9 @@ void ProcessIncomingNATPMPPacket(int s)
 					         eport, (proto==IPPROTO_TCP)?"tcp":"udp");
 #endif
 					/* TODO : check return code */
-					if(upnp_redirect_internal(NULL, eport, senderaddrstr,
-					                          iport, proto, desc,
-					                          timestamp) < 0) {
+					if(upnp_redirect_internal(/*NULL,*/eport, senderaddrstr, 
+											  iport, proto/*, desc,
+											 timestamp*/) < 0) {
 						syslog(LOG_ERR, "Failed to add NAT-PMP %hu %s->%s:%hu '%s'",
 						       eport, (proto==IPPROTO_TCP)?"tcp":"udp", senderaddrstr, iport, desc);
 						resp[3] = 3;  /* Failure */
diff --git a/upnpdescgen.c b/upnpdescgen.c
index d13f74c..7ad5498 100644
--- a/upnpdescgen.c
+++ b/upnpdescgen.c
@@ -1151,7 +1151,7 @@ genEventVars(int * len, const struct serviceDesc * s, const char * servns)
 	str = strcat_str(str, len, &tmplen, "\">");
 	while(v->name) {
 		if(v->itype & 0x80) {
-			str = strcat_str(str, len, &tmplen, "<e:property><s:");
+			str = strcat_str(str, len, &tmplen, "<e:property><");
 			str = strcat_str(str, len, &tmplen, v->name);
 			str = strcat_str(str, len, &tmplen, ">");
 			/*printf("<e:property><s:%s>", v->name);*/
@@ -1217,7 +1217,7 @@ genEventVars(int * len, const struct serviceDesc * s, const char * servns)
 			default:
 				str = strcat_str(str, len, &tmplen, upnpallowedvalues[v->ieventvalue]);
 			}
-			str = strcat_str(str, len, &tmplen, "</s:");
+			str = strcat_str(str, len, &tmplen, "</");
 			str = strcat_str(str, len, &tmplen, v->name);
 			str = strcat_str(str, len, &tmplen, "></e:property>");
 			/*printf("</s:%s></e:property>\n", v->name);*/
diff --git a/upnpredirect.c b/upnpredirect.c
index 5c9beae..2643e97 100644
--- a/upnpredirect.c
+++ b/upnpredirect.c
@@ -255,7 +255,7 @@ int reload_from_lease_file()
  *          -3 permission check failed
  */
 int
-upnp_redirect(const char * rhost, unsigned short eport,
+upnp_redirect(/*const char * rhost,*/unsigned short eport, 
               const char * iaddr, unsigned short iport,
               const char * protocol, const char * desc,
               unsigned int leaseduration)
@@ -278,68 +278,28 @@ upnp_redirect(const char * rhost, unsigned short eport,
 		                 "%hu->%s:%hu %s", eport, iaddr, iport, protocol);
 		return -3;
 	}
-	r = get_redirect_rule(ext_if_name, eport, proto,
-	                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,
-	                      0, 0,
-	                      &timestamp, 0, 0);
-	if(r == 0) {
-		/* if existing redirect rule matches redirect request return success
-		 * xbox 360 does not keep track of the port it redirects and will
-		 * redirect another port when receiving ConflictInMappingEntry */
-		if(strcmp(iaddr, iaddr_old)==0 && iport==iport_old) {
-			syslog(LOG_INFO, "ignoring redirect request as it matches existing redirect");
-		} else {
 
-			syslog(LOG_INFO, "port %hu protocol %s already redirected to %s:%hu",
-				eport, protocol, iaddr_old, iport_old);
-			return -2;
-		}
-	} else {
-		timestamp = (leaseduration > 0) ? time(NULL) + leaseduration : 0;
-		syslog(LOG_INFO, "redirecting port %hu to %s:%hu protocol %s for: %s",
-			eport, iaddr, iport, protocol, desc);
-		return upnp_redirect_internal(rhost, eport, iaddr, iport, proto,
-		                              desc, timestamp);
-	}
+	timestamp = (leaseduration > 0) ? time(NULL) + leaseduration : 0;
+	syslog(LOG_INFO, "redirecting port %hu to %s:%hu protocol %s for: %s",
+		eport, iaddr, iport, protocol, desc);
+	return upnp_redirect_internal(/*rhost,*/ eport, iaddr, iport, proto/*, desc, timestamp*/);
 
 	return 0;
 }
 
 int
-upnp_redirect_internal(const char * rhost, unsigned short eport,
+upnp_redirect_internal(unsigned short eport,
                        const char * iaddr, unsigned short iport,
-                       int proto, const char * desc,
-                       unsigned int timestamp)
+                       int proto)
 {
-	/*syslog(LOG_INFO, "redirecting port %hu to %s:%hu protocol %s for: %s",
-		eport, iaddr, iport, protocol, desc);			*/
-	if(add_redirect_rule2(ext_if_name, rhost, eport, iaddr, iport, proto,
-	                      desc, timestamp) < 0) {
-		return -1;
-	}
+	struct in_addr address;
 
-#ifdef ENABLE_LEASEFILE
-	lease_file_add( eport, iaddr, iport, proto, desc, timestamp);
-#endif
-/*	syslog(LOG_INFO, "creating pass rule to %s:%hu protocol %s for: %s",
-		iaddr, iport, protocol, desc);*/
-	if(add_filter_rule2(ext_if_name, rhost, iaddr, eport, iport, proto, desc) < 0) {
-		/* clean up the redirect rule */
-#if !defined(__linux__)
-		delete_redirect_rule(ext_if_name, eport, proto);
-#endif
+	if(inet_aton(iaddr, &address) < 0) {
+		syslog(LOG_ERR, "inet_aton(%s) : %m", iaddr);
 		return -1;
 	}
-	if(timestamp > 0) {
-		if(!nextruletoclean_timestamp || (timestamp < nextruletoclean_timestamp))
-			nextruletoclean_timestamp = timestamp;
-	}
-#ifdef ENABLE_EVENTS
-	/* the number of port mappings changed, we must
-	 * inform the subscribers */
-	upnp_event_var_change_notify(EWanIPC);
-#endif
-	return 0;
+
+	return addStaticNatEntry_wrapper(address, proto, iport, eport);
 }
 
 
@@ -361,10 +321,9 @@ upnp_get_redirection_infos(unsigned short eport, const char * protocol,
 		desc[0] = '\0';
 	if(rhost && (rhostlen > 0))
 		rhost[0] = '\0';
-	r = get_redirect_rule(ext_if_name, eport, proto_atoi(protocol),
-	                      iaddr, iaddrlen, iport, desc, desclen,
-	                      rhost, rhostlen, &timestamp,
-	                      0, 0);
+	r = getSpecificEntry( eport, proto_atoi(protocol),
+	                      iaddr, iaddrlen, iport,
+	                      rhost, rhostlen, &timestamp);
 	if(r == 0 &&
 	   timestamp > 0 &&
 	   timestamp > (unsigned int)(current_time = time(NULL))) {
@@ -384,7 +343,6 @@ upnp_get_redirection_infos_by_index(int index,
                                     char * rhost, int rhostlen,
                                     unsigned int * leaseduration)
 {
-	/*char ifname[IFNAMSIZ];*/
 	int proto = 0;
 	unsigned int timestamp;
 	time_t current_time;
@@ -393,18 +351,18 @@ upnp_get_redirection_infos_by_index(int index,
 		desc[0] = '\0';
 	if(rhost && (rhostlen > 0))
 		rhost[0] = '\0';
-	if(get_redirect_rule_by_index(index, 0/*ifname*/, eport, iaddr, iaddrlen,
-	                              iport, &proto, desc, desclen,
-	                              rhost, rhostlen, &timestamp,
-	                              0, 0) < 0)
+
+	if (getStaticNatConfigByEntry(index, iaddr, iaddrlen, eport, iport, &proto) < 0)
+	{
 		return -1;
+	}
 	else
 	{
 		current_time = time(NULL);
 		*leaseduration = (timestamp > (unsigned int)current_time)
 		                 ? (timestamp - current_time)
 		                 : 0;
-		if(proto == IPPROTO_TCP)
+		if(proto == IPPROTO_TCP) //17 = UDP, 
 			memcpy(protocol, "TCP", 4);
 		else
 			memcpy(protocol, "UDP", 4);
@@ -418,7 +376,7 @@ _upnp_delete_redir(unsigned short eport, int proto)
 {
 	int r;
 #if defined(__linux__)
-	r = delete_redirect_and_filter_rules(eport, proto);
+	r = deleteStaticNatEntry_wrapper( eport, proto);
 #else
 	r = delete_redirect_rule(ext_if_name, eport, proto);
 	delete_filter_rule(ext_if_name, eport, proto);
@@ -466,45 +424,18 @@ upnp_get_portmapping_number_of_entries()
 struct rule_state *
 get_upnp_rules_state_list(int max_rules_number_target)
 {
-	/*char ifname[IFNAMSIZ];*/
-	int proto;
-	unsigned short iport;
-	unsigned int timestamp;
 	struct rule_state * tmp;
 	struct rule_state * list = 0;
 	struct rule_state * * p;
 	int i = 0;
 	time_t current_time;
 
-	/*ifname[0] = '\0';*/
 	tmp = malloc(sizeof(struct rule_state));
 	if(!tmp)
 		return 0;
 	current_time = time(NULL);
 	nextruletoclean_timestamp = 0;
-	while(get_redirect_rule_by_index(i, /*ifname*/0, &tmp->eport, 0, 0,
-	                              &iport, &proto, 0, 0, 0,0, &timestamp,
-								  &tmp->packets, &tmp->bytes) >= 0)
-	{
-		tmp->to_remove = 0;
-		if(timestamp > 0) {
-			/* need to remove this port mapping ? */
-			if(timestamp <= (unsigned int)current_time)
-				tmp->to_remove = 1;
-			else if((nextruletoclean_timestamp <= (unsigned int)current_time)
-			       || (timestamp < nextruletoclean_timestamp))
-				nextruletoclean_timestamp = timestamp;
-		}
-		tmp->proto = (short)proto;
-		/* add tmp to list */
-		tmp->next = list;
-		list = tmp;
-		/* prepare next iteration */
-		i++;
-		tmp = malloc(sizeof(struct rule_state));
-		if(!tmp)
-			break;
-	}
+
 	free(tmp);
 	/* remove the redirections that need to be removed */
 	for(p = &list, tmp = list; tmp; tmp = *p)
@@ -536,27 +467,12 @@ get_upnp_rules_state_list(int max_rules_number_target)
 void
 remove_unused_rules(struct rule_state * list)
 {
-	char ifname[IFNAMSIZ];
-	unsigned short iport;
 	struct rule_state * tmp;
-	u_int64_t packets;
-	u_int64_t bytes;
-	unsigned int timestamp;
 	int n = 0;
 
 	while(list)
 	{
 		/* remove the rule if no traffic has used it */
-		if(get_redirect_rule(ifname, list->eport, list->proto,
-	                         0, 0, &iport, 0, 0, 0, 0, &timestamp,
-		                     &packets, &bytes) >= 0)
-		{
-			if(packets == list->packets && bytes == list->bytes)
-			{
-				_upnp_delete_redir(list->eport, list->proto);
-				n++;
-			}
-		}
 		tmp = list;
 		list = tmp->next;
 		free(tmp);
@@ -569,16 +485,15 @@ remove_unused_rules(struct rule_state * list)
  * return a list of all "external" ports for which a port
  * mapping exists */
 unsigned short *
-upnp_get_portmappings_in_range(unsigned short startport,
-                               unsigned short endport,
-                               const char * protocol,
+upnp_get_portmappings_in_range(const char * protocol,
                                unsigned int * number)
 {
 	int proto;
 	proto = proto_atoi(protocol);
 	if(!number)
 		return NULL;
-	return get_portmappings_in_range(startport, endport, proto, number);
+	//return get_portmappings_in_range(startport, endport, proto, number);
+	return NULL;
 }
 
 /* stuff for miniupnpdctl */
@@ -586,34 +501,7 @@ upnp_get_portmappings_in_range(unsigned short startport,
 void
 write_ruleset_details(int s)
 {
-	int proto = 0;
-	unsigned short eport, iport;
-	char desc[64];
-	char iaddr[32];
-	char rhost[32];
-	unsigned int timestamp;
-	u_int64_t packets;
-	u_int64_t bytes;
-	int i = 0;
-	char buffer[256];
-	int n;
-
 	write(s, "Ruleset :\n", 10);
-	while(get_redirect_rule_by_index(i, 0/*ifname*/, &eport, iaddr, sizeof(iaddr),
-	                                 &iport, &proto, desc, sizeof(desc),
-	                                 rhost, sizeof(rhost),
-	                                 &timestamp,
-	                                 &packets, &bytes) >= 0)
-	{
-		n = snprintf(buffer, sizeof(buffer),
-		             "%2d %s %s:%hu->%s:%hu "
-		             "'%s' %u %" PRIu64 " %" PRIu64 "\n",
-		             /*"'%s' %llu %llu\n",*/
-		             i, proto==IPPROTO_TCP?"TCP":"UDP", rhost,
-		             eport, iaddr, iport, desc, timestamp, packets, bytes);
-		write(s, buffer, n);
-		i++;
-	}
 }
 #endif
 
diff --git a/upnpredirect.h b/upnpredirect.h
index b549824..68a29d6 100644
--- a/upnpredirect.h
+++ b/upnpredirect.h
@@ -26,7 +26,7 @@ int reload_from_lease_file(void);
  *          -3 permission check failed
  */
 int
-upnp_redirect(const char * rhost, unsigned short eport,
+upnp_redirect(/*const char * rhost,*/unsigned short eport, 
               const char * iaddr, unsigned short iport,
               const char * protocol, const char * desc,
               unsigned int leaseduration);
@@ -34,16 +34,16 @@ upnp_redirect(const char * rhost, unsigned short eport,
 /* upnp_redirect_internal()
  * same as upnp_redirect() without any check */
 int
-upnp_redirect_internal(const char * rhost, unsigned short eport,
+upnp_redirect_internal(/*const char * rhost,*/unsigned short eport, 
                        const char * iaddr, unsigned short iport,
-                       int proto, const char * desc,
-                       unsigned int timestamp);
+                       int proto/*, const char * desc,
+                      unsigned int timestamp*/); 
 
 /* upnp_get_redirection_infos()
  * returns : 0 on success
  *           -1 failed to get the port mapping entry or no entry exists */
 int
-upnp_get_redirection_infos(unsigned short eport, const char * protocol,
+upnp_get_redirection_infos(unsigned short eport, const char *protocol,
                            unsigned short * iport, char * iaddr, int iaddrlen,
                            char * desc, int desclen,
                            char * rhost, int rhostlen,
@@ -103,8 +103,8 @@ remove_unused_rules(struct rule_state * list);
  * return a list of all "external" ports for which a port
  * mapping exists */
 unsigned short *
-upnp_get_portmappings_in_range(unsigned short startport,
-                               unsigned short endport,
+upnp_get_portmappings_in_range(/*unsigned short startport,
+                               unsigned short endport,*/
                                const char * protocol,
                                unsigned int * number);
 
diff --git a/upnpsoap.c b/upnpsoap.c
old mode 100644
new mode 100755
index 0157f72..dabd500
--- a/upnpsoap.c
+++ b/upnpsoap.c
@@ -88,7 +88,8 @@ GetTotalBytesSent(struct upnphttp * h, const char * action)
	int bodylen;
	struct ifdata data;

-	r = getifstats(ext_if_name, &data);
+	//replaced getifstats(ext_if_name, &data); with call to QCMAP
+	r = getIfaceStats(&data);
	bodylen = snprintf(body, sizeof(body), resp,
	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
              r<0?0:data.obytes, action);
@@ -110,7 +111,8 @@ GetTotalBytesReceived(struct upnphttp * h, const char * action)
	int bodylen;
	struct ifdata data;

-	r = getifstats(ext_if_name, &data);
+	//replaced getifstats(ext_if_name, &data); with call to QCMAP
+	r = getIfaceStats(&data);
	bodylen = snprintf(body, sizeof(body), resp,
	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
	         r<0?0:data.ibytes, action);
@@ -132,7 +134,8 @@ GetTotalPacketsSent(struct upnphttp * h, const char * action)
	int bodylen;
	struct ifdata data;

-	r = getifstats(ext_if_name, &data);
+	//replaced  getifstats(ext_if_name, &data); with call to QCMAP
+	r = getIfaceStats(&data);
	bodylen = snprintf(body, sizeof(body), resp,
	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
	         r<0?0:data.opackets, action);
@@ -154,7 +157,8 @@ GetTotalPacketsReceived(struct upnphttp * h, const char * action)
	int bodylen;
	struct ifdata data;

-	r = getifstats(ext_if_name, &data);
+	//replaced getifstats(ext_if_name, &data); with call to QCMAP
+	r = getIfaceStats(&data);
	bodylen = snprintf(body, sizeof(body), resp,
	         action, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1",
	         r<0?0:data.ipackets, action);
@@ -409,7 +413,7 @@ AddPortMapping(struct upnphttp * h, const char * action)
 	       action, eport, int_ip, iport, protocol, desc, leaseduration,
 	       r_host ? r_host : "NULL");
 
-	r = upnp_redirect(r_host, eport, int_ip, iport, protocol, desc, leaseduration);
+	r = upnp_redirect(/*r_host,*/eport, int_ip, iport, protocol, desc, leaseduration); 
 
 	ClearNameValueList(&data);
 
@@ -545,7 +549,7 @@ AddAnyPortMapping(struct upnphttp * h, const char * action)
 	/* TODO : accept a different external port
 	 * have some smart strategy to choose the port */
 	for(;;) {
-		r = upnp_redirect(r_host, eport, int_ip, iport, protocol, desc, leaseduration);
+		r = upnp_redirect(/*r_host,*/eport, int_ip, iport, protocol, desc, leaseduration); 
 		if(r==-2 && eport < 65535) {
 			eport++;
 		} else {
@@ -631,7 +635,7 @@ GetSpecificPortMappingEntry(struct upnphttp * h, const char * action)
 	 * but different remoteHost to be set up, so that is not
 	 * a priority. */
 	r = upnp_get_redirection_infos(eport, protocol, &iport,
-	                               int_ip, sizeof(int_ip),
+								   int_ip, sizeof(int_ip),
 	                               desc, sizeof(desc),
 	                               NULL, 0,
 	                               &leaseduration);
@@ -763,8 +767,8 @@ DeletePortMappingRange(struct upnphttp * h, const char * action)
 		return;
 	}
 
-	port_list = upnp_get_portmappings_in_range(startport, endport,
-	                                           protocol, &number);
+	port_list = upnp_get_portmappings_in_range(protocol, &number);
+
 	for(i = 0; i < number; i++)
 	{
 		r = upnp_delete_redirection(port_list[i], protocol);
@@ -958,7 +962,7 @@ http://www.upnp.org/schemas/gw/WANIPConnection-v2.xsd">
 	memcpy(body+bodylen, list_start, sizeof(list_start));
 	bodylen += (sizeof(list_start) - 1);
 
-	port_list = upnp_get_portmappings_in_range(startport, endport,
+	port_list = upnp_get_portmappings_in_range(/*startport, endport,*/
 	                                           protocol, &list_size);
 	/* loop through port mappings */
 	for(i = 0; number > 0 && i < list_size; i++)
@@ -980,9 +984,9 @@ http://www.upnp.org/schemas/gw/WANIPConnection-v2.xsd">
 		}
 		rhost[0] = '\0';
 		r = upnp_get_redirection_infos(port_list[i], protocol, &iport,
-		                               int_ip, sizeof(int_ip),
-		                               desc, sizeof(desc),
-		                               rhost, sizeof(rhost),
+								   int_ip, sizeof(int_ip),
+	                               desc, sizeof(desc),
+	                               NULL, 0,
 		                               &leaseduration);
 		if(r == 0)
 		{
-- 
1.7.8.3

